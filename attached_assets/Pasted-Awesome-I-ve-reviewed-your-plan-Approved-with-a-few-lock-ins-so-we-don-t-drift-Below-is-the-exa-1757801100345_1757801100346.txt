Awesome. I’ve reviewed your plan. ✅ Approved with a few lock-ins so we don’t drift. Below is the exact spec for M1: Property Card Foundation plus the “copy/paste” prompt for Replit to implement it deterministically.

Lock-ins (applies to all milestones)

Stable hooks only: each card page must call the same hooks, in the same order, every render. Use useQuery(..., { enabled }) gates — never conditionally create/destroy hooks.

No overlays / no null returns: keep our lockdown in place. Card pages must always render content.

Map only on Property: never import/instantiate GeoMap on Unit, Lease, Tenant, Owner.

Humanized labels: use our format.ts helpers (no CAPS, no underscores).

Contracted routing only: Wouter routes already defined; do not add new routes.

M1 — Property Card Foundation (Hero + Overview + RightRail)
Files to create/edit
src/pages/card/property/Hero.tsx
src/pages/card/property/Tabs.tsx      // shell only (Overview active; others stubbed)
src/pages/card/property/Overview.tsx
src/pages/card/property/RightRail.tsx
src/pages/card/property/api.ts        // DTO wrapper with fallback to /entities
// (Update) src/pages/card/property/index.tsx to compose the above

Data contract (strict)

Preferred DTO (BFF)
GET /api/rpc/get_property_card?id={id} →

{
  property: {
    id: number; name?: string;
    street_1?: string; city?: string; state?: string; zip?: string;
    status?: string; type?: string; class?: string;
    doorloop_id?: string | number;
    lat?: number|null; lng?: number|null;
    owner_id?: number|null;
  };
  units: Array<{ id:number; status?:string; market_rent_cents?:number; }>;
  leases: Array<{ id:number; status?:string; rent_cents?:number; unit_id?:number; property_id?:number; }>;
  owner?: { id:number; name?:string|null };
}


Fallback (until DTO exists)

/entities/properties/{id}

/entities/units?doorloop_property_id=eq.{property.doorloop_id}

/entities/leases?property_id=eq.{property.id}

/entities/owners?id=eq.{property.owner_id} (if owner_id present; otherwise no request)

Important: even with fallbacks, keep the same number of useQuery calls every render; use enabled: to defer fetches.

Resolver pattern (no conditional hooks)

In src/pages/card/property/api.ts:

import { useQuery } from "@tanstack/react-query";
import { apiGet } from "@/lib/api"; // existing helper
type Id = string | number;

export function usePropertyCardData(id: Id) {
  // 1) Try rich DTO first
  const dtoQ = useQuery({
    queryKey: ["propertyCardDTO", id],
    queryFn: async () => {
      try {
        return await apiGet(`/api/rpc/get_property_card?id=${id}`);
      } catch {
        return null; // fall through to entities
      }
    },
    staleTime: 60_000,
  });

  // 2) Entities fallback pieces — hooks are ALWAYS created (constant count)
  const propQ = useQuery({
    queryKey: ["property", id],
    queryFn: () => apiGet(`/entities/properties/${id}`),
    enabled: !dtoQ.data, // use only if DTO failed
    staleTime: 60_000,
  });

  const unitsQ = useQuery({
    queryKey: ["unitsByDoorLoop", propQ.data?.doorloop_id ?? null],
    queryFn: () =>
      apiGet(`/entities/units?doorloop_property_id=eq.${propQ.data!.doorloop_id}`),
    enabled: !!(!dtoQ.data && propQ.data?.doorloop_id),
    staleTime: 60_000,
  });

  const leasesQ = useQuery({
    queryKey: ["leasesByProperty", propQ.data?.id ?? null],
    queryFn: () => apiGet(`/entities/leases?property_id=eq.${propQ.data!.id}`),
    enabled: !!(!dtoQ.data && propQ.data?.id),
    staleTime: 60_000,
  });

  const ownerQ = useQuery({
    queryKey: ["ownerById", propQ.data?.owner_id ?? null],
    queryFn: () => apiGet(`/entities/owners?id=eq.${propQ.data!.owner_id}`),
    enabled: !!(!dtoQ.data && propQ.data?.owner_id),
    select: (arr: any[]) => arr?.[0] ?? null,
    staleTime: 60_000,
  });

  // 3) Uniform shape to the page
  if (dtoQ.data) {
    return {
      data: {
        property: dtoQ.data.property,
        units: dtoQ.data.units ?? [],
        leases: dtoQ.data.leases ?? [],
        owner: dtoQ.data.owner ?? null,
      },
      isLoading: dtoQ.isLoading,
      error: dtoQ.error as any,
    };
  }
  return {
    data: {
      property: propQ.data ?? null,
      units: unitsQ.data ?? [],
      leases: leasesQ.data ?? [],
      owner: ownerQ.data ?? null,
    },
    isLoading: propQ.isLoading || unitsQ.isLoading || leasesQ.isLoading || ownerQ.isLoading,
    error: propQ.error || unitsQ.error || leasesQ.error || ownerQ.error || null,
  };
}

UI spec (exact)
Hero.tsx

Title: property.name else joined address (street_1, city, state).

KPIs (left-to-right):

Units: units.length

Active Leases: leases.filter(s=>s.status?.toLowerCase()==="active").length

Avg Rent: average of rent_cents for active leases (format $X,XXX)

Actions (right): [Edit] [Export PDF] [New Work Order] (buttons render; stubs fine).

Surface: .ecc-object with our canonical padding/radius; text humanized (no CAPS/underscores).

Overview.tsx

Section title “Property Overview”.

Field rows:

Type, Class, Status, DoorLoop ID, Owner (owner name becomes link to /card/owner/{id} when present).

Relationships mini:

Units (count), Active Leases (count).

Use existing FieldRows + format.humanize, fmtMoneyCents.

RightRail.tsx (fixed width ~320px)

Card: “Location” → embed map via GeoMap with address or lat/lng; include “Open in Maps” link.

Card: “Key Dates” → “No upcoming events.” placeholder (stub).

Tabs.tsx

Horizontal list of tabs: Overview, Financials, Legal, Files, Linked, Activity.

For M1, only Overview is enabled; others render stub panels with “Coming soon”.

Export default {active, onChange} or a self-contained internal useState.

index.tsx

Uses usePropertyCardData(id) (above).

Never returns null; shows skeletons inside .ecc-object while loading.

Composes Hero, Tabs (Overview active), Overview in main column; RightRail on the side.

DoD (Definition of Done)

 /card/property/42 and /card/property/57 render real values in Hero + Overview (no placeholders if data exists).

 KPI counts and Avg Rent compute correctly from leases.

 Owner name (when available) is a clickable link to /card/owner/{id}.

 Map is visible in Right Rail; no maps render on other cards.

 Guardrails: node scripts/guardrail-mega.mjs ✅, node scripts/guardrail-overlays.mjs ✅.

 TypeScript: npx tsc -p tsconfig.cards.json has 0 errors.

 Page never blanks; ErrorBoundary shows inline panel if fetch fails.

Demo (STOP after M1)

Navigate: /card/property/42, /card/property/57.

Show:

Title + KPIs populated (units, active leases, avg rent).

Overview fields populated; Owner link works when present.

Map visible only on Property.

Post verification outputs (two guardrails + tscheck).

Copy/paste prompt for Replit (implements M1 exactly)
ECC MILESTONE — Property Card M1 (Hero + Overview + RightRail)

Implement exactly as specified by the Architect:

FILES:
- Create: src/pages/card/property/Hero.tsx
- Create: src/pages/card/property/Tabs.tsx
- Create: src/pages/card/property/Overview.tsx
- Create: src/pages/card/property/RightRail.tsx
- Create: src/pages/card/property/api.ts (with usePropertyCardData as per spec)
- Update: src/pages/card/property/index.tsx to compose these

DATA:
- First attempt DTO GET /api/rpc/get_property_card?id={id}
- If DTO not available, use /entities fallbacks
- IMPORTANT: keep a constant number of useQuery hooks, use {enabled} gates; never conditionally add/remove hooks

UI:
- Hero: title (name or joined address), KPIs (Units, Active Leases, Avg Rent), actions [Edit][Export PDF][New Work Order]
- Overview: Type, Class, Status, DoorLoop ID, Owner (link when present), Relationships (counts)
- RightRail: Location map via GeoMap, Key Dates placeholder
- Tabs: Overview active, other tabs stubbed for now
- Use .ecc-object surfaces; humanized labels; no CAPS/underscores

DOD:
- /card/property/42 and /card/property/57 render real values
- KPIs correct; owner link navigates correctly
- Map only on property
- guardrail-mega ✅, guardrail-overlays ✅, `npx tsc -p tsconfig.cards.json` ✅ 0 errors

DEMO (STOP AFTER THIS):
- Post file list changed
- Post verification outputs (3 commands)
- Post routes to click and “what I should see”