ECC Cards: bring-up patch (apply in order)
0) Quarantine all dev-only code so it can’t break the app

Remove any AtomsGallery usage.

Search and delete any import/route for AtomsGallery (usually in src/App.tsx or a dev router).

Move the file out of Vite’s reach:

mv src/dev/AtomsGallery.tsx src/dev/_disabled/AtomsGallery.tsx

Ensure no dev scripts are auto-mounted.
Open index.html and keep only your main entry:

<!-- REMOVE these if present -->
<!-- <script type="module" src="/src/boot/mountEnhancer.tsx"></script> -->
<!-- <script type="module" src="/src/dev/index.ts"></script> -->
<script type="module" src="/src/main.tsx"></script>

1) Kill the red “removeChild” overlay for good

Open src/components/EccErrorBoundary.tsx and make it a pure error boundary—no document.* mutations, no overlays, no DOM removal. Use this minimal version:

import React from "react";

type State = { error?: Error };

export default class EccErrorBoundary extends React.Component<React.PropsWithChildren, State> {
  state: State = {};
  static getDerivedStateFromError(error: Error) { return { error }; }
  componentDidCatch(err: any, info: any) {
    // eslint-disable-next-line no-console
    console.error("[ECC] Uncaught error", err, info);
  }
  render() {
    if (!this.state.error) return this.props.children;
    return (
      <div style={{ padding: 16 }}>
        <h2 style={{ color: "#e66" }}>Contract violation</h2>
        <pre style={{ whiteSpace: "pre-wrap", opacity: .85 }}>
          {this.state.error?.message || String(this.state.error)}
        </pre>
      </div>
    );
  }
}
export { EccErrorBoundary };


Update src/main.tsx to import default:

import EccErrorBoundary from "./components/EccErrorBoundary";

2) Nuke the last FieldRows landmines

We already migrated to CardKit. Now remove stragglers causing “FieldRows is not defined.”

Search for FieldRows across the repo and replace with CardKit’s FieldGroup:

import { FieldGroup } from "@/components/cardkit/FieldGroup";

// before:
// <FieldRows rows={[{ label: "Email", value: tenant.email || "—" }]} />

// after:
<FieldGroup label="Email" value={tenant?.email ?? "—"} />


Make sure Overview.tsx files for tenant and owner no longer reference FieldRows.

3) Harden all RPCs to always return required roots + normalized fields

Open server/routes/rpc.ts. Add these helpers at the top (if they’re not already present):

const pick = <T extends object, K extends keyof any>(
  src: T | null | undefined,
  keys: K[],
  fallback: any = undefined
) => {
  if (!src) return fallback;
  for (const k of keys) {
    const v = (src as any)[k as any];
    if (v !== undefined && v !== null) return v;
  }
  return fallback;
};

const toCents = (v: any) => {
  if (v == null || v === "") return null;
  const n = Number(v);
  if (Number.isNaN(n)) return null;
  // if already looks like cents (integer, >1000), keep it
  return Math.abs(n) > 1000 && Number.isInteger(n) ? n : Math.round(n * 100);
};

// two-step lookup: primary id first, then doorloop alt keys
async function fetchOneMulti(supabase: any, table: string, id: any, altCols: string[]) {
  if (id != null && id !== "") {
    const { data, error } = await supabase.from(table).select("*").eq("id", id).single();
    if (!error && data) return data;
  }
  for (const col of altCols) {
    const alt = id;
    if (alt == null || alt === "") continue;
    const { data, error } = await supabase.from(table).select("*").eq(col, alt).maybeSingle();
    if (!error && data) return data;
  }
  return null;
}

const normAddress = (row: any) => ({
  line1: pick(row, ["line1", "street1", "addr1", "address1", "address_line1"]) ?? null,
  line2: pick(row, ["line2", "street2", "addr2", "address2", "address_line2"]) ?? null,
  city:  pick(row, ["city", "locality"]) ?? null,
  state: pick(row, ["state", "region"]) ?? null,
  zip:   pick(row, ["zip", "postal_code"]) ?? null
});

const ok = (res: any, body: any) => res.status(200).json(body);
const fail = (res: any, code: number, msg: string) => res.status(code).json({ error: msg });

PROPERTY

Guarantee property object and property.type. Return KPIs with nullable avgRentCents.

rpc.get("/get_property_card", async (req, res) => {
  try {
    const id = req.query.id ?? req.query.doorloop_id;
    const property = await fetchOneMulti(supabase, "properties", id, ["doorloop_id"]);
    if (!property) return fail(res, 404, "property not found");

    const prop = {
      ...property,
      type: property.type ?? property.property_type ?? property.kind ?? "UNKNOWN",
      address: normAddress(property)
    };

    // kpis
    const { data: units = [] } = await supabase.from("units").select("*").eq("property_id", property.id);
    const { data: leases = [] } = await supabase.from("leases").select("*").eq("property_id", property.id);

    const activeLeases = leases.filter(l => (l.status ?? "").toUpperCase() === "ACTIVE").length;
    const unitsCount   = units.length;
    const occPct       = unitsCount ? Math.round((activeLeases / unitsCount) * 10000) / 100 : 0;

    // avg rent from active leases; allow null if none
    const rents = leases
      .filter(l => (l.status ?? "").toUpperCase() === "ACTIVE")
      .map(l => toCents(pick(l, ["rent_cents", "rent", "monthly_rent"])))
      .filter((x): x is number => x != null);
    const avgRentCents = rents.length ? Math.round(rents.reduce((a, b) => a + b, 0) / rents.length) : null;

    return ok(res, { property: prop, kpis: { units: unitsCount, activeLeases, occupancyPct: occPct, avgRentCents } });
  } catch (e: any) {
    return fail(res, 500, e?.message ?? "property error");
  }
});

UNIT
rpc.get("/get_unit_card", async (req, res) => {
  try {
    const id = req.query.id ?? req.query.doorloop_id;
    const unit = await fetchOneMulti(supabase, "units", id, ["doorloop_id"]);
    if (!unit) return fail(res, 404, "unit not found");

    const prop = unit.property_id ? await fetchOneMulti(supabase, "properties", unit.property_id, []) : null;
    const lease = unit.id ? (await supabase.from("leases").select("*").eq("unit_id", unit.id).maybeSingle()).data : null;

    return ok(res, { unit, property: prop ?? null, lease: lease ?? null });
  } catch (e: any) {
    return fail(res, 500, e?.message ?? "unit error");
  }
});

LEASE

Normalize dates/status and cents; guarantee lease.

rpc.get("/get_lease_card", async (req, res) => {
  try {
    const id = req.query.id ?? req.query.doorloop_id;
    const lease = await fetchOneMulti(supabase, "leases", id, ["doorloop_id"]);
    if (!lease) return fail(res, 404, "lease not found");

    const norm = {
      ...lease,
      status: String(lease.status ?? "UNKNOWN").toUpperCase(),
      start:  pick(lease, ["start", "start_date"]) ?? null,
      end:    pick(lease, ["end", "end_date"]) ?? null,
      rentCents: toCents(pick(lease, ["rent_cents", "rent", "monthly_rent"])),
      balanceCents: toCents(pick(lease, ["balance_cents", "balance_due", "outstanding_balance", "totalBalanceDue"]))
    };

    const unit   = lease.unit_id    ? await fetchOneMulti(supabase, "units", lease.unit_id, [])    : null;
    const tenant = lease.tenant_id  ? await fetchOneMulti(supabase, "tenants", lease.tenant_id, []) : null;
    const property = lease.property_id ? await fetchOneMulti(supabase, "properties", lease.property_id, []) : null;

    return ok(res, { lease: norm, unit: unit ?? null, tenant: tenant ?? null, property: property ?? null });
  } catch (e: any) {
    return fail(res, 500, e?.message ?? "lease error");
  }
});

OWNER
rpc.get("/get_owner_card", async (req, res) => {
  try {
    const id = req.query.id ?? req.query.doorloop_owner_id;
    const owner = await fetchOneMulti(supabase, "owners", id, ["doorloop_owner_id"]);
    if (!owner) return fail(res, 404, "owner not found");

    const { data: properties = [] } = await supabase.from("properties").select("*").eq("owner_id", owner.id);

    return ok(res, { owner, properties });
  } catch (e: any) {
    return fail(res, 500, e?.message ?? "owner error");
  }
});

TENANT
rpc.get("/get_tenant_card", async (req, res) => {
  try {
    const id = req.query.id ?? req.query.doorloop_tenant_id;
    const tenant = await fetchOneMulti(supabase, "tenants", id, ["doorloop_tenant_id"]);
    if (!tenant) return fail(res, 404, "tenant not found");

    const { data: leases = [] } = await supabase.from("leases").select("*").eq("tenant_id", tenant.id);
    const active = leases.find(l => String(l.status ?? "").toUpperCase() === "ACTIVE") ?? null;

    return ok(res, { tenant, leases, activeLease: active });
  } catch (e: any) {
    return fail(res, 500, e?.message ?? "tenant error");
  }
});


These handlers ensure the UI always receives the correct root object (no more [CONTRACT] Missing required field: ...) and that critical fields are present (property.type, normalized rent/balance cents, status, dates).

4) Keep Vite happy

You already set server.allowedHosts. Keep:

server: {
  allowedHosts: true,
  hmr: { overlay: true }
}


Remove optimizeDeps.disabled—Vite 5 ignores it and logs warnings.

5) Restart & verify

Stop → Run.

Hit these pages:

/portfolio/properties (table loads)

/card/property/42

/card/unit/45

/card/lease/1

/card/tenant/1

/card/owner/1

You should now see no red overlay, no white screen, and no “[CONTRACT] Missing required field …” banners. If a specific card still shows a banner, paste the JSON body from its matching /api/rpc/get_*_card?id=... call—then I’ll give you the 1-line field map for that response.