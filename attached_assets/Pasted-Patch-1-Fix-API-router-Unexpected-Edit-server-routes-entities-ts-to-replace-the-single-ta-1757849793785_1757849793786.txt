Patch 1 — Fix API router (“Unexpected ?”)

Edit server/routes/entities.ts to replace the single /:table/:id? route with two routes.

// server/routes/entities.ts
import { Router } from "express";
import { createClient } from "@supabase/supabase-js";

const r = Router();
const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_KEY!);

const RESERVED = new Set(["select", "limit", "order"]);

function applyFilters(sb: any, q: Record<string, string>) {
  for (const [key, val] of Object.entries(q)) {
    if (!val || RESERVED.has(key)) continue;
    const [op, ...rest] = val.split(".");
    const v = rest.join(".");
    switch (op) {
      case "eq":   sb = sb.eq(key, v); break;
      case "neq":  sb = sb.neq(key, v); break;
      case "gt":   sb = sb.gt(key, v); break;
      case "gte":  sb = sb.gte(key, v); break;
      case "lt":   sb = sb.lt(key, v); break;
      case "lte":  sb = sb.lte(key, v); break;
      case "ilike":sb = sb.ilike(key, v); break;
      case "like": sb = sb.like(key, v); break;
      case "is":   sb = sb.is(key, v); break;
      case "in":   sb = sb.in(key, v.replace(/^\(|\)$/g, "").split(",")); break;
      default:     sb = sb.eq(key, val);
    }
  }
  return sb;
}

// LIST/QUERY: /api/entities/:table?field=eq.123&order=id.desc&limit=100
r.get("/:table", async (req, res) => {
  try {
    const { table } = req.params as { table: string };
    const q = req.query as Record<string, string>;
    let sb = supabase.from(table).select(q.select || "*");
    sb = applyFilters(sb, q);
    if (q.order) {
      const [field, dir = "asc"] = q.order.split(".");
      sb = sb.order(field, { ascending: dir.toLowerCase() !== "desc" });
    }
    if (q.limit) sb = sb.limit(Number(q.limit));
    const { data, error } = await sb;
    if (error) return res.status(400).json({ error: error.message });
    // Return RAW array
    res.json(data);
  } catch (e: any) {
    res.status(500).json({ error: String(e?.message || e) });
  }
});

// GET ONE: /api/entities/:table/:id
r.get("/:table/:id", async (req, res) => {
  try {
    const { table, id } = req.params as { table: string; id: string };
    const q = req.query as Record<string, string>;
    const { data, error } = await supabase.from(table).select(q.select || "*").eq("id", id).single();
    if (error) return res.status(404).json({ error: error.message });
    // Return RAW object
    res.json(data);
  } catch (e: any) {
    res.status(500).json({ error: String(e?.message || e) });
  }
});

export default r;


Why this works: no ? in the path anymore, so path-to-regexp won’t throw. You keep the filter grammar and raw JSON responses.

Patch 2 — Add missing mount enhancer (no-op)

Create src/boot/mountEnhancer.tsx

// src/boot/mountEnhancer.tsx
import { ReactNode } from "react";

/** Minimal no-op enhancer so main.tsx can import it safely. */
export default function mountEnhancer(node: ReactNode) {
  return node;
}

// Also export a named variant in case main.tsx uses this symbol.
export function withMountEnhancer(node: ReactNode) {
  return node;
}


This satisfies the import and avoids breaking your dev overlays/guardrails.

Optional clean-up (non-blocking)

Vite warning: remove optimizeDeps.disabled from vite.config.ts (Vite ≥5.1 ignores it). This isn’t fatal, just noisy.

Definition of Done (quick checks)

Start app with existing npm run dev (no workflow changes).

API should boot without the PathError.

WEB should mount without the “mountEnhancer” error.

Hit these endpoints in the browser or curl:

/api/entities/properties/42 → object (no { ok, item }).

/api/entities/leases?property_id=eq.42 → array.

Visit cards:

/card/property/42, /card/unit/45, /card/lease/1, /card/tenant/1, /card/owner/1
Pages render (even if some values are still “—”), no startup crashes.