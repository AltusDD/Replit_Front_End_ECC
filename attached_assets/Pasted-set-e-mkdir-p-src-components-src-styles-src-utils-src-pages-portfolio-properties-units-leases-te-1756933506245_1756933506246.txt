set -e
mkdir -p src/components src/styles src/utils src/pages/portfolio/{properties,units,leases,tenants,owners}

############################################
# 0) Formatting helpers (money, percent, dates)
############################################
cat > src/utils/format.ts <<'TS'
export const money = (v: any) =>
  typeof v === "number"
    ? v.toLocaleString(undefined, { style: "currency", currency: "USD" })
    : typeof v === "string" && v.trim() !== "" && !isNaN(Number(v))
    ? Number(v).toLocaleString(undefined, { style: "currency", currency: "USD" })
    : "—";

export const percent = (v: any, digits = 1) => {
  const n = typeof v === "number" ? v : Number(v);
  if (!isFinite(n)) return "—";
  return `${n.toFixed(digits)}%`;
};

export const shortDate = (v: any) => {
  if (!v) return "—";
  const d = new Date(v);
  return isNaN(+d) ? "—" : d.toISOString().slice(0,10);
};

export const boolText = (v: any) => (v ? "true" : "false");
TS

############################################
# 1) Small dict helpers (index / group)
############################################
cat > src/utils/dict.ts <<'TS'
export function indexBy<T extends Record<string, any>>(rows: T[], key: keyof T) {
  const m = new Map<any, T>();
  for (const r of rows || []) m.set(r?.[key], r);
  return m;
}
export function groupBy<T extends Record<string, any>>(rows: T[], key: keyof T) {
  const m = new Map<any, T[]>();
  for (const r of rows || []) {
    const k = r?.[key];
    if (!m.has(k)) m.set(k, []);
    m.get(k)!.push(r);
  }
  return m;
}
TS

############################################
# 2) Polished DataTable component (sorting, search, paging)
############################################
cat > src/components/DataTable.tsx <<'TSX'
import React, { useMemo, useState } from "react";
import "@/styles/table.css";

type Align = "left" | "right" | "center";
export type Col<T> = {
  key: keyof T & string;
  header: string;
  align?: Align;
  width?: number | string;
  render?: (row: T) => React.ReactNode;
};

export function DataTable<T extends Record<string, any>>({
  title,
  columns,
  rows,
  loading,
  error,
  emptyText = "No data",
  searchKeys,
  pageSize = 50,
  rowKey,
}: {
  title?: string;
  columns: Col<T>[];
  rows: T[];
  loading?: boolean;
  error?: string | null;
  emptyText?: string;
  searchKeys?: (keyof T & string)[];
  pageSize?: number;
  rowKey?: (row: T, index: number) => React.Key;
}) {
  const [query, setQuery] = useState("");
  const [sortKey, setSortKey] = useState<string | null>(null);
  const [sortDir, setSortDir] = useState<"asc" | "desc">("asc");
  const [page, setPage] = useState(0);

  const keys = searchKeys || (columns.map(c => c.key) as (keyof T & string)[]);

  const filtered = useMemo(() => {
    if (!query.trim()) return rows;
    const q = query.toLowerCase();
    return rows.filter(r =>
      keys.some(k => (r?.[k] ?? "").toString().toLowerCase().includes(q))
    );
  }, [rows, query, keys]);

  const sorted = useMemo(() => {
    if (!sortKey) return filtered;
    const copy = filtered.slice();
    copy.sort((a, b) => {
      const av = a?.[sortKey as keyof T];
      const bv = b?.[sortKey as keyof T];
      // number first, then string
      const an = typeof av === "number" ? av : Number(av);
      const bn = typeof bv === "number" ? bv : Number(bv);
      if (isFinite(an) && isFinite(bn)) return sortDir === "asc" ? an - bn : bn - an;
      const as = (av ?? "").toString().toLowerCase();
      const bs = (bv ?? "").toString().toLowerCase();
      return sortDir === "asc" ? (as > bs ? 1 : as < bs ? -1 : 0) : (as < bs ? 1 : as > bs ? -1 : 0);
    });
    return copy;
  }, [filtered, sortKey, sortDir]);

  const pages = Math.max(1, Math.ceil(sorted.length / pageSize));
  const current = sorted.slice(page * pageSize, page * pageSize + pageSize);

  function onSort(k: string) {
    setPage(0);
    if (sortKey !== k) {
      setSortKey(k);
      setSortDir("asc");
    } else {
      setSortDir(sortDir === "asc" ? "desc" : "asc");
    }
  }

  return (
    <div className="table-card">
      <div className="table-toolbar">
        <div className="table-title">
          {title ?? "Table"}
          <span className="muted"> {loading ? "Loading…" : `(${filtered.length})`}</span>
        </div>
        <div className="table-tools">
          <input
            className="table-search"
            placeholder="Search…"
            value={query}
            onChange={(e) => { setQuery(e.target.value); setPage(0); }}
          />
        </div>
      </div>

      {error && <div className="table-error">Error: {error}</div>}

      <div className="table-wrap">
        <table className="ecc-table">
          <thead>
            <tr>
              {columns.map((c) => (
                <th
                  key={c.key}
                  style={{ width: c.width, textAlign: c.align ?? "left" }}
                  onClick={() => onSort(c.key)}
                  className={sortKey === c.key ? `sorted ${sortDir}` : undefined}
                  role="button"
                >
                  {c.header}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {loading && current.length === 0 && (
              <tr><td colSpan={columns.length} className="empty">Loading…</td></tr>
            )}
            {!loading && current.length === 0 && (
              <tr><td colSpan={columns.length} className="empty">{emptyText}</td></tr>
            )}
            {current.map((r, i) => (
              <tr key={rowKey ? rowKey(r, i) : i}>
                {columns.map((c) => (
                  <td key={c.key} style={{ textAlign: c.align ?? "left" }}>
                    {c.render ? c.render(r) : display(r[c.key])}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {pages > 1 && (
        <div className="table-pager">
          <button disabled={page === 0} onClick={() => setPage(0)}>&laquo;</button>
          <button disabled={page === 0} onClick={() => setPage(p => Math.max(0, p-1))}>&lsaquo;</button>
          <span>Page {page+1} / {pages}</span>
          <button disabled={page >= pages-1} onClick={() => setPage(p => Math.min(pages-1, p+1))}>&rsaquo;</button>
          <button disabled={page >= pages-1} onClick={() => setPage(pages-1)}>&raquo;</button>
        </div>
      )}
    </div>
  );
}

function display(v: any) {
  if (v == null || v === "") return "—";
  if (Array.isArray(v)) return v.join(", ");
  return String(v);
}
TSX

############################################
# 3) Table CSS (tokens only, sticky header, chips)
############################################
cat > src/styles/table.css <<'CSS'
:root{
  --ink-1: var(--surface-1, #111214);
  --ink-2: var(--surface-2, #15161a);
  --ink-3: var(--surface-3, #1b1d22);
  --text-1: var(--fg-strong, #ffffff);
  --text-2: var(--fg-muted, #c7c9d1);
  --gold: var(--brand-gold, #f7c948);
  --ok: var(--accent-okay, #3fb950);
  --warn: var(--accent-warn, #f7c948);
  --bad: var(--accent-bad, #ff6a69);
}

.table-card { background: var(--ink-1); border: 1px solid var(--ink-3); border-radius: 14px; overflow: hidden; }
.table-toolbar {
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 14px; border-bottom:1px solid var(--ink-3); background: var(--ink-2);
}
.table-title { color: var(--text-1); font-weight:700; letter-spacing:.2px; }
.table-title .muted { color: var(--text-2); font-weight:400; margin-left:6px; }
.table-tools { display:flex; gap:8px; }
.table-search {
  background: var(--ink-1); color: var(--text-1); border:1px solid var(--ink-3);
  border-radius:10px; padding:8px 10px; min-width:220px;
}

.table-error { color: var(--bad); padding:10px 14px; }

.table-wrap { max-width: 100%; overflow:auto; }
.ecc-table { width:100%; border-collapse:separate; border-spacing:0; color: var(--text-1); font-size:14px; }
.ecc-table thead th {
  position: sticky; top: 0; z-index: 1;
  background: var(--ink-2); color: var(--text-2);
  text-transform: uppercase; letter-spacing:.04em; font-weight:600;
  padding:10px 12px; border-bottom:1px solid var(--ink-3); white-space:nowrap; user-select:none;
}
.ecc-table thead th.sorted.asc::after { content:" ▲"; color: var(--gold); }
.ecc-table thead th.sorted.desc::after { content:" ▼"; color: var(--gold); }
.ecc-table tbody td { padding:12px; border-bottom:1px solid var(--ink-3); }
.ecc-table tbody tr:nth-child(2n) { background: color-mix(in oklab, var(--ink-2) 90%, black); }
.ecc-table tbody tr:hover { background: color-mix(in oklab, var(--ink-2) 85%, var(--gold)); }
.ecc-table td.empty { text-align:center; color: var(--text-2); padding: 32px 12px; }
.table-pager { display:flex; align-items:center; gap:12px; padding:10px 14px; color: var(--text-2); }
.table-pager button {
  background: var(--ink-2); color: var(--text-1); border:1px solid var(--ink-3); border-radius:10px; padding:6px 10px;
}
.badge {
  font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid var(--ink-3);
  background: var(--ink-2); color: var(--text-2);
}
.badge.ok { color:#fff; background: color-mix(in oklab, var(--ok) 70%, black); }
.badge.warn { color:#000; background: var(--warn); }
.badge.bad { color:#fff; background: color-mix(in oklab, var(--bad) 70%, black); }
.mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
.right { text-align:right; }
CSS

############################################
# 4) Columns shim (keys only; we render via DataTable)
############################################
cat > src/pages/portfolio/columns.ts <<'TS'
export const PROPERTY_COLUMNS = [
  { key: "name", header: "Property" },
  { key: "type", header: "Type" },
  { key: "class", header: "Class" },
  { key: "state", header: "State" },
  { key: "city", header: "City" },
  { key: "unit_count", header: "Units" },
  { key: "occupancy", header: "Occ%" },
  { key: "active", header: "Active" },
];
export const UNIT_COLUMNS = [
  { key: "property", header: "Property" },
  { key: "unit_number", header: "Unit" },
  { key: "beds", header: "Bd" },
  { key: "baths", header: "Ba" },
  { key: "sq_ft", header: "SqFt" },
  { key: "status", header: "Status" },
  { key: "market_rent", header: "Market Rent" },
];
export const LEASE_COLUMNS = [
  { key: "tenant_names", header: "Tenant(s)" },
  { key: "property", header: "Property" },
  { key: "rent", header: "Rent" },
  { key: "start", header: "Start" },
  { key: "end", header: "End" },
  { key: "status", header: "Status" },
];
export const TENANT_COLUMNS = [
  { key: "name", header: "Name" },
  { key: "property", header: "Property" },
  { key: "unit", header: "Unit" },
  { key: "email", header: "Email" },
  { key: "phone", header: "Phone" },
  { key: "status", header: "Status" },
  { key: "balance", header: "Balance" },
];
export const OWNER_COLUMNS = [
  { key: "name", header: "Owner" },
  { key: "email", header: "Email" },
  { key: "phone", header: "Phone" },
  { key: "property_count", header: "Props" },
  { key: "active", header: "Active" },
];
TS

############################################
# 5) PROPERTIES page — compute unit_count & occupancy
############################################
cat > src/pages/portfolio/properties/index.tsx <<'TSX'
import React, { useMemo } from "react";
import { DataTable, Col } from "@/components/DataTable";
import { PROPERTY_COLUMNS } from "../columns";
import { useCollection } from "@/features/data/useCollection";
import { groupBy } from "@/utils/dict";
import { percent } from "@/utils/format";

type Row = {
  id: any; doorloop_id?: any;
  name: string; type: string; class: string; state: string; city: string;
  unit_count: number; occupancy?: number | string; active: any;
};
export default function PropertiesPage() {
  const props = useCollection<any>("properties");
  const units = useCollection<any>("units");
  const leases = useCollection<any>("leases");

  const rows = useMemo<Row[]>(() => {
    const byPropUnits = groupBy(units.data, "property_id");
    const activeByUnit = new Set(
      leases.data.filter(l => String(l?.status || "").toLowerCase() === "active").map(l => l.unit_id)
    );
    return (props.data || []).map((p: any) => {
      const u = byPropUnits.get(p.id) || [];
      const unit_count = p.unit_count ?? u.length ?? 0;
      const occUnitsStatus = u.filter((x:any) => String(x?.status||"").toLowerCase() === "occupied").length;
      const occUnitsLease = u.filter((x:any)=> activeByUnit.has(x.id)).length;
      const occUnits = Math.max(occUnitsStatus, occUnitsLease);
      const occPct = p.occupancy ?? p.occupancy_rate ?? (unit_count ? (occUnits / unit_count) * 100 : null);
      return {
        id: p.id ?? p.doorloop_id,
        doorloop_id: p.doorloop_id,
        name: p.name ?? "",
        type: p.type ?? p.category ?? "",
        class: p.class ?? p.asset_class ?? p.property_class ?? "",
        state: p.address_state ?? p.state ?? "",
        city: p.address_city ?? p.city ?? "",
        unit_count,
        occupancy: occPct,
        active: p.active ?? p.isActive ?? false,
      };
    });
  }, [props.data, units.data, leases.data]);

  const cols: Col<Row>[] = [
    { key: "name", header: "Property" },
    { key: "type", header: "Type" },
    { key: "class", header: "Class" },
    { key: "state", header: "State" },
    { key: "city", header: "City" },
    { key: "unit_count", header: "Units", align: "right", render: (r) => <span className="mono">{r.unit_count ?? "—"}</span> },
    { key: "occupancy", header: "Occ%", align: "right", render: (r) => <span className="mono">{r.occupancy == null ? "—" : percent(r.occupancy)}</span> },
    { key: "active", header: "Active", render: (r) => <span className={`badge ${r.active ? "ok" : "bad"}`}>{String(r.active)}</span> },
  ];

  return (
    <DataTable
      title="Properties"
      columns={cols}
      rows={rows}
      loading={props.loading}
      error={props.error ?? undefined}
      searchKeys={PROPERTY_COLUMNS.map(c => c.key as keyof Row & string)}
      pageSize={50}
      rowKey={(r) => r.id}
      emptyText="No properties"
    />
  );
}
TSX

############################################
# 6) UNITS page — fill property & money
############################################
cat > src/pages/portfolio/units/index.tsx <<'TSX'
import React, { useMemo } from "react";
import { DataTable, Col } from "@/components/DataTable";
import { UNIT_COLUMNS } from "../columns";
import { useCollection } from "@/features/data/useCollection";
import { indexBy } from "@/utils/dict";
import { money } from "@/utils/format";

type Row = {
  id:any; doorloop_id?:any; property:string; unit_number:string;
  beds:any; baths:any; sq_ft:any; status:any; market_rent:any;
};
export default function UnitsPage() {
  const units = useCollection<any>("units");
  const props = useCollection<any>("properties");

  const rows = useMemo<Row[]>(() => {
    const pById = indexBy(props.data, "id");
    return (units.data || []).map((u: any) => ({
      id: u.id ?? u.doorloop_id,
      doorloop_id: u.doorloop_id,
      property: u.property ?? u.property_name ?? pById.get(u.property_id)?.name ?? "",
      unit_number: u.unit_number ?? u.number ?? u.name ?? "",
      beds: u.beds ?? u.bedrooms ?? "",
      baths: u.baths ?? u.bathrooms ?? "",
      sq_ft: u.sq_ft ?? u.sqft ?? "",
      status: u.status ?? (u.id && u.property_id ? "" : ""),
      market_rent: typeof u.rent_cents === "number" ? u.rent_cents/100 : (u.market_rent ?? u.rent ?? u.rent_amount),
    }));
  }, [units.data, props.data]);

  const cols: Col<Row>[] = [
    { key: "property", header: "Property" },
    { key: "unit_number", header: "Unit" },
    { key: "beds", header: "Bd", align: "right" },
    { key: "baths", header: "Ba", align: "right" },
    { key: "sq_ft", header: "SqFt", align: "right" },
    { key: "status", header: "Status", render: (r) => <span className={`badge ${String(r.status).toLowerCase()==="occupied"?"ok":""}`}>{r.status || "—"}</span> },
    { key: "market_rent", header: "Market Rent", align: "right", render: (r)=> <span className="mono">{money(r.market_rent)}</span> },
  ];

  return (
    <DataTable
      title="Units"
      columns={cols}
      rows={rows}
      loading={units.loading}
      error={units.error ?? undefined}
      searchKeys={UNIT_COLUMNS.map(c => c.key as keyof Row & string)}
      pageSize={50}
      rowKey={(r)=>r.id}
      emptyText="No units"
    />
  );
}
TSX

############################################
# 7) LEASES page — tenant names, dates, money
############################################
cat > src/pages/portfolio/leases/index.tsx <<'TSX'
import React, { useMemo } from "react";
import { DataTable, Col } from "@/components/DataTable";
import { LEASE_COLUMNS } from "../columns";
import { useCollection } from "@/features/data/useCollection";
import { indexBy } from "@/utils/dict";
import { money, shortDate } from "@/utils/format";

type Row = {
  id:any; doorloop_id?:any; tenant_names:string; property:string; rent:any; start:any; end:any; status:any;
};
export default function LeasesPage() {
  const leases = useCollection<any>("leases");
  const tenants = useCollection<any>("tenants");
  const props = useCollection<any>("properties");

  const rows = useMemo<Row[]>(() => {
    const tById = indexBy(tenants.data, "id");
    const pById = indexBy(props.data, "id");
    return (leases.data || []).map((l: any) => {
      const names =
        l.tenant_names ||
        tById.get(l.primary_tenant_id)?.display_name ||
        tById.get(l.tenant_id)?.display_name ||
        tById.get(l.primary_tenant_id)?.full_name ||
        tById.get(l.tenant_id)?.full_name || "";
      return {
        id: l.id ?? l.doorloop_id,
        doorloop_id: l.doorloop_id,
        tenant_names: names,
        property: l.property ?? pById.get(l.property_id)?.name ?? "",
        rent: typeof l.rent_cents === "number" ? l.rent_cents/100 : (l.rent ?? l.total_recurring_rent),
        start: l.start ?? l.start_date,
        end: l.end ?? l.end_date,
        status: l.status ?? "",
      };
    });
  }, [leases.data, tenants.data, props.data]);

  const cols: Col<Row>[] = [
    { key: "tenant_names", header: "Tenant(s)" },
    { key: "property", header: "Property" },
    { key: "rent", header: "Rent", align: "right", render: (r)=> <span className="mono">{money(r.rent)}</span> },
    { key: "start", header: "Start", render: (r)=> shortDate(r.start) },
    { key: "end", header: "End", render: (r)=> shortDate(r.end) },
    { key: "status", header: "Status", render: (r)=> <span className={`badge ${String(r.status).toLowerCase()==="active"?"ok":String(r.status).toLowerCase()==="ended"?"bad":"warn"}`}>{r.status || "—"}</span> },
  ];

  return (
    <DataTable
      title="Leases"
      columns={cols}
      rows={rows}
      loading={leases.loading}
      error={leases.error ?? undefined}
      searchKeys={LEASE_COLUMNS.map(c => c.key as keyof Row & string)}
      pageSize={50}
      rowKey={(r)=>r.id}
      emptyText="No leases"
    />
  );
}
TSX

############################################
# 8) TENANTS page — latest lease to fill property/unit
############################################
cat > src/pages/portfolio/tenants/index.tsx <<'TSX'
import React, { useMemo } from "react";
import { DataTable, Col } from "@/components/DataTable";
import { TENANT_COLUMNS } from "../columns";
import { useCollection } from "@/features/data/useCollection";
import { indexBy } from "@/utils/dict";
import { money } from "@/utils/format";

type Row = { id:any; doorloop_id?:any; name:string; property:string; unit:string; email:string; phone:string; status:any; balance:any };
export default function TenantsPage() {
  const tenants = useCollection<any>("tenants");
  const leases = useCollection<any>("leases");
  const units = useCollection<any>("units");
  const props = useCollection<any>("properties");

  const rows = useMemo<Row[]>(() => {
    const uById = indexBy(units.data, "id");
    const pById = indexBy(props.data, "id");

    const latest = new Map<any, any>();
    for (const l of leases.data || []) {
      const tids = [l.primary_tenant_id, l.tenant_id].filter(Boolean);
      for (const tid of tids) {
        const cur = latest.get(tid);
        const score = Date.parse(l.updated_at || l.start_date || "") || 0;
        const curScore = cur ? (Date.parse(cur.updated_at || cur.start_date || "") || 0) : -1;
        if (!cur || score >= curScore) latest.set(tid, l);
      }
    }

    return (tenants.data || []).map((t: any) => {
      const l = latest.get(t.id);
      const u = l ? uById.get(l.unit_id) : undefined;
      const p = u ? pById.get(u.property_id) : (l ? pById.get(l.property_id) : undefined);
      const name =
        t.name || t.display_name || t.full_name || [t.first_name, t.last_name].filter(Boolean).join(" ");
      return {
        id: t.id ?? t.doorloop_id,
        doorloop_id: t.doorloop_id,
        name,
        property: p?.name ?? "",
        unit: u?.unit_number ?? u?.number ?? u?.name ?? "",
        email: t.primary_email ?? t.email ?? "",
        phone: t.primary_phone ?? t.phone ?? "",
        status: l?.status ?? t.status ?? t.type ?? "",
        balance: t.balance,
      };
    });
  }, [tenants.data, leases.data, units.data, props.data]);

  const cols: Col<Row>[] = [
    { key: "name", header: "Name" },
    { key: "property", header: "Property" },
    { key: "unit", header: "Unit" },
    { key: "email", header: "Email" },
    { key: "phone", header: "Phone" },
    { key: "status", header: "Status", render: (r)=> <span className={`badge ${String(r.status).toLowerCase().includes("lease")?"ok":""}`}>{r.status || "—"}</span> },
    { key: "balance", header: "Balance", align: "right", render: (r)=> <span className="mono">{money(r.balance)}</span> },
  ];

  return (
    <DataTable
      title="Tenants"
      columns={cols}
      rows={rows}
      loading={tenants.loading}
      error={tenants.error ?? undefined}
      searchKeys={TENANT_COLUMNS.map(c => c.key as keyof Row & string)}
      pageSize={50}
      rowKey={(r)=>r.id}
      emptyText="No tenants"
    />
  );
}
TSX

############################################
# 9) OWNERS page — badges & counts
############################################
cat > src/pages/portfolio/owners/index.tsx <<'TSX'
import React, { useMemo } from "react";
import { DataTable, Col } from "@/components/DataTable";
import { OWNER_COLUMNS } from "../columns";
import { useCollection } from "@/features/data/useCollection";

type Row = { id:any; doorloop_id?:any; name:string; email:string; phone:string; property_count:number; active:any };
export default function OwnersPage() {
  const owners = useCollection<any>("owners");

  const rows = useMemo<Row[]>(() => {
    return (owners.data || []).map((o:any) => ({
      id: o.id ?? o.doorloop_id,
      doorloop_id: o.doorloop_id,
      name: o.name ?? o.display_name ?? o.full_name ?? [o.first_name, o.last_name].filter(Boolean).join(" "),
      email: o.primary_email ?? o.email ?? "",
      phone: o.primary_phone ?? o.phone ?? "",
      property_count: o.property_count ?? 0,
      active: o.active ?? o.isActive ?? false,
    }));
  }, [owners.data]);

  const cols: Col<Row>[] = [
    { key: "name", header: "Owner" },
    { key: "email", header: "Email" },
    { key: "phone", header: "Phone" },
    { key: "property_count", header: "Props", align: "right", render: (r)=> <span className="mono">{r.property_count ?? 0}</span> },
    { key: "active", header: "Active", render: (r)=> <span className={`badge ${r.active ? "ok":"bad"}`}>{String(r.active)}</span> },
  ];

  return (
    <DataTable
      title="Owners"
      columns={cols}
      rows={rows}
      loading={owners.loading}
      error={owners.error ?? undefined}
      searchKeys={OWNER_COLUMNS.map(c => c.key as keyof Row & string)}
      pageSize={50}
      rowKey={(r)=>r.id}
      emptyText="No owners"
    />
  );
}
TSX

echo "✓ Tables upgraded. Refresh the app and try sorting/searching each page."
