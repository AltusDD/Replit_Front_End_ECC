ECC Cards — Final Stabilize & Light-Up Patch

Goal: eliminate the UI unmount error and satisfy the card DTO contracts so all five cards render with real data.

0) Safety & restart plan

Create a checkpoint.

After changes, run:
npm run dev (the current script already starts Vite on 5173 + API on 8787).

1) Fix the UI crash: make EccErrorBoundary pure React (no DOM surgery)

Why: The red “ECC boot error… removeChild is not a child of this node” is caused by an error overlay manipulating the DOM outside React and then being removed twice during HMR/StrictMode. We’ll replace it with a pure in-tree error boundary.

Edit: src/components/EccErrorBoundary.tsx — replace file contents with:

import React from "react";

type Props = { children: React.ReactNode };

function toMessage(err: unknown) {
  if (!err) return "Unknown error";
  // Preserve contract error text
  if (typeof err === "string") return err;
  if (err instanceof Error) return err.message || String(err);
  // React Query / fetch JSON
  try { return JSON.stringify(err); } catch { return String(err); }
}

class Boundary extends React.Component<Props, { error: unknown }> {
  state = { error: null as unknown };

  static getDerivedStateFromError(error: unknown) {
    return { error };
  }

  componentDidCatch(error: unknown, info: unknown) {
    console.error("[ECC] ErrorBoundary caught:", error, info);
  }

  render() {
    if (this.state.error) {
      const msg = toMessage(this.state.error);
      return (
        <div className="p-4">
          <h2 className="text-red-300 font-semibold mb-2">Contract violation</h2>
          <pre className="text-red-200 text-xs whitespace-pre-wrap">{msg}</pre>
        </div>
      );
    }
    return this.props.children as React.ReactElement;
  }
}

export default function EccErrorBoundary({ children }: Props) {
  return <Boundary>{children}</Boundary>;
}


Edit: src/main.tsx — ensure we import default:

import EccErrorBoundary from "./components/EccErrorBoundary";


(This removes any portal/DOM manipulation and prevents the removeChild error.)

2) Purge the last legacy import: replace FieldRows with CardKit FieldGroup

Why: You’re seeing FieldRows is not defined on Tenant/Owner. That’s a leftover from the old portfolio code.

Do this search & replace (exact):

Search: FieldRows

For each match in card tab files (Tenant/Owner/Property/Unit/Lease Overview/RightRail/etc):

Remove the FieldRows import (usually from @/features/...).

Add:
import { FieldGroup } from "@/components/cardkit/FieldGroup";

Replace each usage with the simple CardKit line style, e.g.:

<FieldGroup label="Email" value={tenant?.email ?? "—"} />
<FieldGroup label="Phone" value={tenant?.phone ?? "—"} />
<FieldGroup label="Status" value={lease?.status ?? "—"} />


(You already have CardPanel/RightRailPanel; this just removes the last legacy reference.)

3) Server contract fixes: always return the required objects/fields

You’re getting:

Missing required field: property.type (Property card)

Missing required field: lease (Lease card)

Similar schema gaps on other cards

We’ll fix the RPC builders to always include the required object keys and map likely column names to the contract fields. No masking on the client; the server will shape the DTOs correctly.

Edit: server/routes/rpc.ts

3A) Helpers (top of file, keep your existing fetchOne/fetchOneMulti)

Add near your helpers:

function pick(...vals: Array<string | null | undefined>) {
  return vals.find(v => v !== undefined && v !== null);
}

function toCents(n: any): number | null {
  if (n === null || n === undefined) return null;
  const num = Number(n);
  return Number.isFinite(num) ? Math.round(num * 100) : null;
}

3B) Property card: include property.type

Inside /get_property_card handler, after you load the raw prop:

const type = pick(
  (prop as any).type,
  (prop as any).property_type,
  (prop as any).kind
);
// Fail fast if still missing
if (!type) throw new Error("[CONTRACT] Missing required field: property.type");

const property = {
  id: prop.id,
  name: pick((prop as any).name, (prop as any).display_name, `Property #${prop.id}`),
  type, // <-- REQUIRED
  address: {
    line1: pick((prop as any).line1, (prop as any).address1, (prop as any).address_line1),
    city:  (prop as any).city ?? null,
    state: (prop as any).state ?? null,
    postalCode: pick((prop as any).postal_code, (prop as any).zip, (prop as any).zipcode),
  }
};

// ...your existing KPI calc; ensure avgRentCents can be null when no active leases
res.json({ property, kpis, units, leases });

3C) Lease card: always return the lease object

Inside /get_lease_card:

const leaseRow = await fetchOneMulti(supabase, "leases", id, ["doorloop_id"]);
if (!leaseRow) throw new Error("[CONTRACT] Missing required field: lease");

const unit = leaseRow.unit_id ? await fetchOne(supabase, "units", leaseRow.unit_id) : null;
const property = leaseRow.property_id ? await fetchOne(supabase, "properties", leaseRow.property_id) : null;
const tenant = leaseRow.tenant_id ? await fetchOne(supabase, "tenants", leaseRow.tenant_id) : null;

const lease = {
  id: leaseRow.id,
  status: leaseRow.status ?? null,
  start_date: pick(leaseRow.start_date, leaseRow.start),
  end_date: pick(leaseRow.end_date, leaseRow.end),
  rent_cents: toCents(pick(leaseRow.rent, leaseRow.monthly_rent)),
  balance_cents: toCents(pick(leaseRow.balance_due, leaseRow.outstanding_balance, leaseRow.totalBalanceDue)),
};

const kpis = {
  status: lease.status ?? "UNKNOWN",
  rentCents: lease.rent_cents,
  balanceCents: lease.balance_cents,
  term: { start: lease.start_date ?? null, end: lease.end_date ?? null },
};

res.json({ lease, unit, property, tenant, kpis });

3D) Tenant/Owner/unit handlers — ensure required root objects exist

Tenant: must include { tenant: {...} }

Owner: must include { owner: {...} }

Unit: must include { unit: {...} }

If any of those were returning only KPIs/relations, wrap the raw row into the expected root key similarly to the lease example.

(Keep fail-fast — throw if the required root row isn’t found; don’t send placeholders.)

4) Frontend resolvers: no masking, but allow null for optional KPIs

You already switched the HeroBlocks to fail-fast and handle null KPI values (e.g., avgRentCents === null). Just confirm:

No ?? 0 or || "—" for values that the contract marks optional.

Money/percent formatters should display “—” when the value is null, not when the field is missing. The server guarantees the field exists, even if null.

5) Verify (stop on first failure)

Open a shell in Replit (or use the web preview’s console):

API checks

curl -s http://localhost:8787/api/health
curl -s "http://localhost:8787/api/rpc/get_property_card?id=52" | jq .
curl -s "http://localhost:8787/api/rpc/get_unit_card?id=45"     | jq .
curl -s "http://localhost:8787/api/rpc/get_lease_card?id=1"     | jq .
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=1"    | jq .
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=1"     | jq .


Each payload must include its root object: property, unit, lease, tenant, owner (plus kpis where defined).

UI checks

/card/property/52 should render (no “property.type” error).

/card/lease/1 should render (no “Missing required field: lease”).

/card/tenant/1 should render (no FieldRows error).

Any “removeChild” crash should be gone.

6) If anything still trips

If DTO validation still fails, log the raw returned object in the resolver just before Zod parse to see what field is missing.

If you see AbortError spam again, keep StrictMode disabled in dev (Fragment). We can re-enable after this stabilizes.

Why this works

The UI crash was a React/DOM mismatch from an overlay doing manual appendChild/removeChild. The new boundary stays inside React’s tree.

The server now guarantees the contract shape: required root objects are always present; optional KPI values may be null, not missing.

The last legacy import is gone, so there’s no “FieldRows is not defined”.

Run the patch above and you should be able to click through all five cards without contract violations or red overlays.