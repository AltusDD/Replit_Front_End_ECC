Apply this patch

Save as genesis-dashboard-hotfix3.patch in the repo root, then run:

git checkout -b fix/genesis-dashboard-hotfix3
git apply --whitespace=fix genesis-dashboard-hotfix3.patch
git commit -am "Dashboard: lease-window occupancy derivation, city table + map alignment"

Patch
From 9d9f0a2abcd0000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Altus Genesis Bot <genesis@altus>
Date: Sat, 6 Sep 2025 13:44:00 -0700
Subject: [PATCH] Dashboard: lease-window occupancy derivation, city table + map
 alignment

diff --git a/src/features/dashboard/hooks/useDashboardData.ts b/src/features/dashboard/hooks/useDashboardData.ts
index 999999a..999999b 100644
--- a/src/features/dashboard/hooks/useDashboardData.ts
+++ b/src/features/dashboard/hooks/useDashboardData.ts
@@ -58,6 +58,53 @@ function normalizeId(id:any){ return String(id ?? "") }
+// --- Occupancy engine (robust, status-agnostic) ------------------------------
+type LeaseLite = { unit_id?:any; unitId?:any; start_date?:any; startDate?:any; end_date?:any; endDate?:any; status?:any };
+
+const asDate = (d:any) => d ? new Date(d) : null;
+const isActiveLease = (l: LeaseLite, at = new Date()) => {
+  const s = asDate(l.start_date ?? l.startDate);
+  const e = asDate(l.end_date ?? l.endDate);
+  if (!s || !e) return false;
+  const st = (l.status ?? "").toString().toLowerCase();
+  // treat non-ended leases as active if we're inside the window
+  const ended = st.includes("end") || st === "terminated" || st === "inactive";
+  return !ended && s.getTime() <= at.getTime() && at.getTime() <= e.getTime();
+};
+
+function indexLeasesByUnit(leases: LeaseLite[]){
+  const m = new Map<string, LeaseLite[]>();
+  for (const l of leases){
+    const key = normalizeId(l.unit_id ?? l.unitId);
+    if (!key) continue;
+    if (!m.has(key)) m.set(key, []);
+    m.get(key)!.push(l);
+  }
+  return m;
+}
+
+/**
+ * Derive unit occupancy:
+ * 1) If unit.status is explicitly set, respect "occupied"/"vacant".
+ * 2) Otherwise, inspect leases for the unit and mark "occupied" if any active window.
+ * 3) Fallback: "vacant".
+ */
+function deriveUnitOccupancy(u:any, leaseIdx:Map<string, LeaseLite[]>, at = new Date()){
+  const raw = (u?.status ?? u?.unitStatus ?? u?.occupancy_status ?? "")
+    .toString()
+    .trim()
+    .toLowerCase();
+  if (raw === "occupied" || raw === "occ" || raw === "o") return "occupied";
+  if (raw === "vacant" || raw === "vac" || raw === "v") return "vacant";
+  const leases = leaseIdx.get(normalizeId(u?.id)) || [];
+  const active = leases.some(l => isActiveLease(l, at));
+  return active ? "occupied" : "vacant";
+}
@@ -72,33 +119,33 @@ function generateMapProperties(props:any[], units:any[], tenants:any[], leases:any[]){
-  return props
+  // build lease index once for performance + consistency
+  const leaseIdx = indexLeasesByUnit(leases);
+  return props
     .filter(p => typeof p.lat === "number" && typeof p.lng === "number")
     .map(p => {
       const pid = normalizeId(p?.id);
-      const occupied = units.some(u => normalizeId(u?.property_id ?? u?.propertyId) === pid &&
-        normalizeUnitStatus(u, new Map()) === "occupied");
-      const rentReady = units.some(u => normalizeId(u?.property_id ?? u?.propertyId) === pid &&
-        normalizeUnitStatus(u, new Map()) === "vacant" && (!!u?.rent_ready || !!u?.rentReady));
+      const occupied = units.some(u => normalizeId(u?.property_id ?? u?.propertyId) === pid &&
+        deriveUnitOccupancy(u, leaseIdx) === "occupied");
+      const rentReady = units.some(u => normalizeId(u?.property_id ?? u?.propertyId) === pid &&
+        deriveUnitOccupancy(u, leaseIdx) === "vacant" && (!!u?.rent_ready || !!u?.rentReady));
       const delinquent = tenants.some(t => normalizeId(t?.property_id ?? t?.propertyId) === pid &&
         ((t?.balance_cents ?? t?.balanceCents ?? 0) > 0));
       const lat = p.lat ?? 0;
       const lng = p.lng ?? 0;
       let color = "#31c48d"; // green
       if (delinquent && occupied) color = "#ef5953"; // red
       else if (!occupied && rentReady) color = "#f3c969"; // yellow
       else if (!occupied && !rentReady) color = "#e98a2e"; // orange
       return { id:p.id, lat, lng, color, occupied, rentReady, delinquent, address:p.address, city:p.city, state:p.state };
     });
 }
 
 function buildData({ props, units, leases, tenants, workorders, txns }: any) {
-  // Indexing
-  const leaseByUnit = indexLeasesByUnit(leases);
-  // Occupancy from Units (+ derive status if missing)
-  const totalUnits = units.length;
-  const occupiedUnits = units.filter(u => normalizeUnitStatus(u, leaseByUnit) === "occupied").length;
+  // Occupancy from leases (date-window) with status override when present
+  const leaseIdx = indexLeasesByUnit(leases);
+  const totalUnits = units.length;
+  const occupiedUnits = units.filter(u => deriveUnitOccupancy(u, leaseIdx) === "occupied").length;
   const occupancyPct = totalUnits ? (occupiedUnits / totalUnits) * 100 : 0;
   const vacantUnits = Math.max(0, totalUnits - occupiedUnits);
-  const rentReadyUnits = units.filter(u => normalizeUnitStatus(u, leaseByUnit) === "vacant" && (!!u?.rent_ready || !!u?.rentReady)).length;
+  const rentReadyUnits = units.filter(u => deriveUnitOccupancy(u, leaseIdx) === "vacant" && (!!u?.rent_ready || !!u?.rentReady)).length;
@@ -140,22 +187,32 @@ function buildData({ props, units, leases, tenants, workorders, txns }: any) {
-  const occByCity = aggregateOccByCityFromUnits(props, units, leases);
+  const occByCity = aggregateOccByCityFromUnits(props, units, leases);
 
   const fmt = (d?:string)=>fmtDate(d);
   return { kpis, propertiesForMap, actionFeed: buildActionFeed(tenants, leases, workorders), cashflow90, funnel30, occByCity, fmt };
 }
 
-function aggregateOccByCityFromUnits(props:any[], units:any[], leases:any[]){
+function aggregateOccByCityFromUnits(props:any[], units:any[], leases:any[]){
   const propIdx = new Map<string, any>();
   for (const p of props) propIdx.set(normalizeId(p?.id), p);
-  const leaseIdx = indexLeasesByUnit(leases);
+  const leaseIdx = indexLeasesByUnit(leases);
   const cityAgg = new Map<string, {props:Set<string>, occ:number, vac:number}>();
-  for (const u of units){
+  for (const u of units){
     const pid = normalizeId(u?.property_id ?? u?.propertyId);
     const p = propIdx.get(pid);
     const city = (p?.city ?? "—").toString();
-    const status = normalizeUnitStatus(u, leaseIdx);
+    const status = deriveUnitOccupancy(u, leaseIdx);
     const rec = cityAgg.get(city) ?? { props:new Set<string>(), occ:0, vac:0 };
     rec.props.add(pid);
     if (status === "occupied") rec.occ++; else rec.vac++;
     cityAgg.set(city, rec);
   }
   const rows = Array.from(cityAgg.entries()).map(([city, v])=>{
     const total = v.occ + v.vac;
     return { city, properties: v.props.size, occupied: v.occ, vacant: v.vac, occPct: total ? (v.occ/total)*100 : 0 };
   }).sort((a,b)=> a.city.localeCompare(b.city));
   return rows;
 }

What to expect after merge

Occupancy KPI will reflect real unit occupancy based on lease windows (no hard dependency on units.status).

Rent Ready stays accurate (subset of vacant with rent_ready true).

Occupancy by City will populate occupied/vacant counts per market (no more zeros).

Map pin colors will match the new occupancy engine.

No mock data, no randomization; Collections MTD still live-only (shows “—” until transactions API is wired).

Quick verification script (Replit shell)
# Occupancy engine present
rg -n "deriveUnitOccupancy|isActiveLease|indexLeasesByUnit" src/features/dashboard/hooks/useDashboardData.ts

# City aggregation references deriveUnitOccupancy
rg -n "aggregateOccByCityFromUnits|deriveUnitOccupancy" src/features/dashboard/hooks/useDashboardData.ts

# No jitter/mock
rg -n "Math\.random|faker|mock" src | rg -v node_modules || echo "OK: no mock/random"

# AbortError safety still in place
rg -n "isAbortError" src/features/dashboard/hooks/useDashboardData.ts