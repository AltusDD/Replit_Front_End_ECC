Step 1 — Pull a real error (no CLI)

Fill in your publish profile creds and run in your Replit Shell:

APP="empirecommandcenter-altus-staging"
USER="<publishProfile userName>"
PASS="<publishProfile userPWD>"
KUDU="https://$APP.scm.azurewebsites.net"

# List function log folders
curl -s -u "$USER:$PASS" "$KUDU/api/vfs/home/LogFiles/Application/Functions/Function/" | jq '.[].name'

# Grab the latest entities_properties log (adjust if different function name)
LAST=$(curl -s -u "$USER:$PASS" "$KUDU/api/vfs/home/LogFiles/Application/Functions/Function/entities_properties/" \
  | jq -r '.[].name' | sort | tail -1)
curl -s -u "$USER:$PASS" "$KUDU/api/vfs/home/LogFiles/Application/Functions/Function/entities_properties/$LAST" | tail -n 200


If you get a traceback (e.g., KeyError, ModuleNotFoundError, requests.exceptions, 401 from Supabase), paste just the last ~20 lines to me. If that stalls, go to Step 2 to isolate root cause without logs.

Step 2 — Atomic “stub” to prove platform is fine (no redeploy)

This overwrites only the entities_properties/__init__.py with a minimal handler. If this returns 200, our Supabase code is the culprit; if it still 500s, it’s platform/config.

APP="empirecommandcenter-altus-staging"
USER="<publishProfile userName>"
PASS="<publishProfile userPWD>"
BASE="https://$APP.azurewebsites.net"
KUDU="https://$APP.scm.azurewebsites.net"

# Overwrite the function file with a stub
curl -s -u "$USER:$PASS" -X PUT -H "If-Match: *" -H "Content-Type: application/octet-stream" \
  --data-binary @- "$KUDU/api/vfs/site/wwwroot/entities_properties/__init__.py" <<'PY'
import json, azure.functions as func
def main(req: func.HttpRequest) -> func.HttpResponse:
    return func.HttpResponse(json.dumps({"ok": True, "msg": "stub alive"}), mimetype="application/json")
PY

# Hit the endpoint
curl -s -i "$BASE/api/entities/properties?limit=1" | head -n1


Interpretation:

HTTP/1.1 200 OK ⇒ platform is good; the crash is inside our Supabase call logic.

Still 500 ⇒ platform/config issue (we’ll kill the process and re-extract, but let’s try step 3 first).

Step 3 — Patch the real handler with bullet-proof error reporting (live, no redeploy)

We’ll replace entities_properties/__init__.py to:

validate env vars (no silent None)

call Supabase with explicit params

on error, return upstream status & body so you see the real reason, not a generic 500

APP="empirecommandcenter-altus-staging"
USER="<publishProfile userName>"
PASS="<publishProfile userPWD>"
BASE="https://$APP.azurewebsites.net"
KUDU="https://$APP.scm.azurewebsites.net"

curl -s -u "$USER:$PASS" -X PUT -H "If-Match: *" -H "Content-Type: application/octet-stream" \
  --data-binary @- "$KUDU/api/vfs/site/wwwroot/entities_properties/__init__.py" <<'PY'
import os, json, urllib.parse, requests
import azure.functions as func

SUPABASE_URL = (os.environ.get("SUPABASE_URL") or "").rstrip("/")
SUPABASE_KEY = os.environ.get("SUPABASE_SERVICE_ROLE_KEY")
TABLE = "properties"

def H():
    return {
        "apikey": SUPABASE_KEY or "",
        "Authorization": f"Bearer {SUPABASE_KEY or ''}",
        "Accept": "application/json"
    }

def err(status, msg, extra=None):
    body = {"error": msg}
    if extra: body.update(extra)
    return func.HttpResponse(json.dumps(body), status_code=status, mimetype="application/json")

def main(req: func.HttpRequest) -> func.HttpResponse:
    if not SUPABASE_URL or not SUPABASE_KEY:
        return err(500, "Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY")
    try:
        rid = req.route_params.get("id") or req.params.get("id")
        q = req.get_query_params()
        select = q.get("select", "*")
        limit = int(q.get("limit", "50"))
        params = {"select": select}
        if rid:
            params["id"] = f"eq.{rid}"
        else:
            params["limit"] = str(limit)
        url = f"{SUPABASE_URL}/rest/v1/{TABLE}"
        r = requests.get(url, headers=H(), params=params, timeout=20)
        if r.status_code >= 400:
            return err(502, "Supabase error", {"upstream_status": r.status_code, "upstream_body": r.text})
        data = r.json()
        if rid and isinstance(data, list):
            data = data[0] if data else None
        return func.HttpResponse(json.dumps(data), mimetype="application/json")
    except Exception as e:
        return err(500, "Unhandled exception", {"exception": str(e)})
PY

# Test again and show first line + body for insight
echo "Status:" && curl -s -i "$BASE/api/entities/properties?limit=1" | head -n1
echo "Body:" && curl -s "$BASE/api/entities/properties?limit=1"


What to look for in the body if still failing:

"Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY" ⇒ set real values in App Settings (Portal → Configuration), Restart.

"Supabase error", "upstream_status": 401 ⇒ wrong service role key.

"Supabase error", "upstream_status": 404 or 400 ⇒ table name mismatch, RLS, or query params problem.

"exception": "..." ⇒ network/DNS/TLS, etc.

Once entities/properties is green, we replicate this hardened pattern to entities_units, owners_search, owners_transfercontext (I can paste those in one shot if needed), or redeploy with the fixed code.

If the stub in Step 2 still returns 500

That means the runtime didn’t reload files or the site process is wedged. Do this Kudu-only reset (it won’t touch your secrets):

# kill all site processes so the runtime cold-starts
curl -s -u "$USER:$PASS" -X POST "$KUDU/api/processes/kill?all=true"

# force extracted redeploy of your last vendor zip (re-uploads and unzips)
ZIP="ecc_deployment_complete.vendor.zip"
curl -s -u "$USER:$PASS" --data-binary @"$ZIP" "$KUDU/api/zipdeploy?isAsync=true"
sleep 10
curl -s -u "$USER:$PASS" "$KUDU/api/deployments/latest" | jq '.status,.progress'


Then re-run the Step 2 stub test (should be 200). If it is, apply Step 3’s hardened function code and move on.

Tell me exactly what the Step 3 Body prints for /api/entities/properties?limit=1.

From that one response I’ll give you the single follow-up line (e.g., fix secret, fix table, adjust RLS, etc.) and mirror the fix across the other endpoints.