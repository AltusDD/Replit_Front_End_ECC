Thanks for the screenshots—that red “ECC boot error” is the smoking gun. You’ve still got a dev overlay script manipulating the DOM outside React; when React unmounts (HMR/StrictMode), it tries to removeChild a node that overlay code already yanked. That’s why you see:

Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node.

Let’s kill the overlay at the source and light up all cards. Do these in order, exactly:

1) Remove the DOM overlay that’s crashing the app

Edit index.html and delete these lines if they exist (they’re the culprits):

<!-- REMOVE THESE TWO -->
<script type="module" src="/src/boot/mountEnhancer.tsx"></script>
<script type="module" src="/src/dev/index.ts"></script>


If either file still contains code that appends/removes elements from document.body, also delete their contents or delete the files. All dev helpers must run inside React only.

Ensure src/components/EccErrorBoundary.tsx is a pure in-tree boundary (no portals/DOM surgery) and that you import it as a default export in src/main.tsx:

// main.tsx
import EccErrorBoundary from "./components/EccErrorBoundary";
// and wrap <App /> with it (you already do)


(This removes the “removeChild” crash entirely.)

2) Remove the last legacy component causing “FieldRows is not defined”

Search the repo for FieldRows and replace with CardKit’s FieldGroup:

// add once per file where you show fields
import { FieldGroup } from "@/components/cardkit/FieldGroup";

// then replace any FieldRows(...) usage with individual lines, e.g.
<FieldGroup label="Email"  value={tenant?.email ?? "—"} />
<FieldGroup label="Phone"  value={tenant?.phone ?? "—"} />
<FieldGroup label="Status" value={lease?.status ?? "—"} />


This is usually in Tenant/Owner cards (and maybe a Property/Unit tab if it slipped through).

3) Fix server DTOs so every card gets its required root object

You’re seeing [CONTRACT] Missing required field: property.type and Missing required field: lease. That means the RPC is returning rows without the shape your Zod schemas expect. Harden the RPC mappers so they always return the required root key and map synonymous columns.

Open server/routes/rpc.ts and add tiny helpers at the top (near your other helpers):

function pick<T>(...vals: (T | null | undefined)[]) {
  return vals.find((v) => v !== undefined && v !== null) as T | undefined;
}
function toCents(n: any): number | null {
  if (n === null || n === undefined) return null;
  const num = Number(n);
  return Number.isFinite(num) ? Math.round(num * 100) : null;
}

3a) Property card – provide property.type

Inside /get_property_card, after you’ve loaded prop, build the DTO like this:

const type =
  pick<string>((prop as any).type, (prop as any).property_type, (prop as any).kind) ?? "UNKNOWN"; // keeps UI alive

const property = {
  id: prop.id,
  name:
    pick<string>(
      (prop as any).name,
      (prop as any).display_name,
      (prop as any).title
    ) ?? `Property #${prop.id}`,
  type, // REQUIRED
  address: {
    line1: pick<string>(
      (prop as any).line1,
      (prop as any).address1,
      (prop as any).address_line1
    ) ?? null,
    city: (prop as any).city ?? null,
    state: (prop as any).state ?? null,
    postalCode: pick<string>(
      (prop as any).postal_code,
      (prop as any).zip,
      (prop as any).zipcode
    ) ?? null,
  },
};

// keep your existing KPI calc (avgRentCents may be null when no leases)
res.json({ property, kpis, units, leases });


If you want strict fail-fast instead of "UNKNOWN", replace the ?? "UNKNOWN" with
if (!type) throw new Error("[CONTRACT] Missing required field: property.type").

3b) Lease card – always return lease root

Inside /get_lease_card:

const leaseRow = await fetchOneMulti(supabase, "leases", id, ["doorloop_id"]);
if (!leaseRow) throw new Error("[CONTRACT] Missing required field: lease");

const unit = leaseRow.unit_id ? await fetchOne(supabase, "units", leaseRow.unit_id) : null;
const property = leaseRow.property_id ? await fetchOne(supabase, "properties", leaseRow.property_id) : null;
const tenant = leaseRow.tenant_id ? await fetchOne(supabase, "tenants", leaseRow.tenant_id) : null;

const lease = {
  id: leaseRow.id,
  status: leaseRow.status ?? null,
  start_date: pick<string>(leaseRow.start_date as any, leaseRow.start as any) ?? null,
  end_date: pick<string>(leaseRow.end_date as any, leaseRow.end as any) ?? null,
  rent_cents: toCents(pick(leaseRow.rent, leaseRow.monthly_rent)),
  balance_cents: toCents(pick(leaseRow.balance_due, leaseRow.outstanding_balance, leaseRow.totalBalanceDue)),
};

const kpis = {
  status: lease.status ?? "UNKNOWN",
  rentCents: lease.rent_cents,
  balanceCents: lease.balance_cents,
  term: { start: lease.start_date, end: lease.end_date },
};

res.json({ lease, unit, property, tenant, kpis });

3c) Tenant / Owner / Unit cards — guarantee the root key exists

For each handler, ensure you wrap the raw row:

// tenant
const row = await fetchOneMulti(supabase, "tenants", id, ["doorloop_tenant_id"]);
if (!row) throw new Error("[CONTRACT] Missing required field: tenant");
const tenant = { id: row.id, name: pick(row.display_name, row.name) ?? `Tenant #${row.id}`, email: row.email ?? null, phone: row.phone ?? null };
res.json({ tenant, /* relations & kpis */ });

// owner
const oRow = await fetchOneMulti(supabase, "owners", id, ["doorloop_owner_id"]);
if (!oRow) throw new Error("[CONTRACT] Missing required field: owner");
const owner = { id: oRow.id, name: pick(oRow.display_name, oRow.name) ?? `Owner #${oRow.id}` };
res.json({ owner, /* properties, kpis */ });

// unit
const uRow = await fetchOneMulti(supabase, "units", id, ["doorloop_id"]);
if (!uRow) throw new Error("[CONTRACT] Missing required field: unit");
const unit = { id: uRow.id, unit_number: pick(uRow.unit_number, uRow.unitId) ?? null, beds: uRow.beds ?? null, baths: uRow.baths ?? null, sqft: uRow.sqft ?? null, status: uRow.status ?? null };
res.json({ unit, /* property, lease, kpis */ });

4) Verify (stop on first failure)

API:

curl -s http://localhost:8787/api/health
curl -s "http://localhost:8787/api/rpc/get_property_card?id=42" | jq .
curl -s "http://localhost:8787/api/rpc/get_unit_card?id=45"     | jq .
curl -s "http://localhost:8787/api/rpc/get_lease_card?id=1"     | jq .
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=1"    | jq .
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=1"     | jq .


Each response must include its root key (property, unit, lease, tenant, owner) and no HTML.

UI:

/card/property/42 should render (no property.type error, no red overlay).

/card/lease/1, /card/unit/45, /card/tenant/1, /card/owner/1 render without “Missing required field”.

Why this will stop the tail-chasing

The red overlay crash is 100% a side effect of a dev script appending/removing DOM nodes outside React. Removing those two <script> tags and keeping the boundary pure fixes it for good.

The “missing required field” errors come from server shape drift. The server now guarantees the root object exists and maps common column aliases. Optional KPIs can be null without breaking the UI.

The last legacy component (FieldRows) is gone, so no undefined component errors.

Run those three chunks of work and the cards will light up. If any endpoint still fails a Zod parse, log the raw payload just before parsing and we’ll map the last odd field—no more DOM crashes while we do it.