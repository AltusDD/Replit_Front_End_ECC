ECC Fix Pack M1.1 — Property card renders even if relations fail
What this fixes

Only the base property failing can block the page.

Units/Leases/Owner errors become non-blocking warnings (shown inline), not page killers.

Moves the resolver file out of /pages to satisfy the “no apiGet in page” guardrail.

Adds owner endpoint fallbacks so it won’t error if the backend exposes either /entities/owners/:id or ?id=eq. or owner (singular) table.

1) Move resolver file (guardrail compliance)

Delete

src/pages/card/property/api.ts


Create

src/lib/cards/property.api.ts


Content (drop-in)

import { useQuery } from "@tanstack/react-query";
import { apiGet } from "@/lib/api";

type Id = string | number;

type Property = {
  id: number;
  name?: string | null;
  street_1?: string | null;
  city?: string | null;
  state?: string | null;
  zip?: string | null;
  status?: string | null;
  type?: string | null;
  class?: string | null;
  doorloop_id?: string | number | null;
  owner_id?: number | null;
  lat?: number | null;
  lng?: number | null;
};

export function usePropertyCardData(id: Id) {
  // 1) DTO-first (never throws – returns null on failure)
  const dtoQ = useQuery({
    queryKey: ["propertyCardDTO", id],
    queryFn: async () => {
      try {
        return await apiGet(`/api/rpc/get_property_card?id=${id}`);
      } catch {
        return null;
      }
    },
    staleTime: 60_000,
  });

  // 2) Entities fallback (constant hook count; use enabled gates)
  const propQ = useQuery<Property | null>({
    queryKey: ["property", id],
    queryFn: async () => {
      // try /entities/properties/:id
      try {
        return await apiGet(`/entities/properties/${id}`);
      } catch {
        // try filter form
        const arr = await apiGet(`/entities/properties?id=eq.${id}`);
        return Array.isArray(arr) ? (arr[0] ?? null) : null;
      }
    },
    enabled: !dtoQ.data,
    staleTime: 60_000,
  });

  const unitsQ = useQuery({
    queryKey: ["unitsByDoorLoop", propQ.data?.doorloop_id ?? null],
    queryFn: async () =>
      apiGet(`/entities/units?doorloop_property_id=eq.${propQ.data!.doorloop_id}`),
    enabled: !!(!dtoQ.data && propQ.data?.doorloop_id),
    staleTime: 60_000,
  });

  const leasesQ = useQuery({
    queryKey: ["leasesByProperty", propQ.data?.id ?? null],
    queryFn: async () => apiGet(`/entities/leases?property_id=eq.${propQ.data!.id}`),
    enabled: !!(!dtoQ.data && propQ.data?.id),
    staleTime: 60_000,
  });

  const ownerQ = useQuery({
    queryKey: ["ownerById", propQ.data?.owner_id ?? null],
    queryFn: async () => {
      const oid = propQ.data!.owner_id!;
      // try /entities/owners/:id
      try {
        return await apiGet(`/entities/owners/${oid}`);
      } catch {
        // try owners? filter
        try {
          const arr = await apiGet(`/entities/owners?id=eq.${oid}`);
          if (Array.isArray(arr)) return arr[0] ?? null;
        } catch {}
        // try singular table
        try {
          const arr = await apiGet(`/entities/owner?id=eq.${oid}`);
          if (Array.isArray(arr)) return arr[0] ?? null;
        } catch {}
        return null;
      }
    },
    enabled: !!(!dtoQ.data && propQ.data?.owner_id),
    staleTime: 60_000,
  });

  // 3) Normalize output + error policy
  const data = dtoQ.data
    ? {
        property: dtoQ.data.property ?? null,
        units: dtoQ.data.units ?? [],
        leases: dtoQ.data.leases ?? [],
        owner: dtoQ.data.owner ?? null,
      }
    : {
        property: propQ.data ?? null,
        units: unitsQ.data ?? [],
        leases: leasesQ.data ?? [],
        owner: ownerQ.data ?? null,
      };

  // Only a missing base property is fatal
  const fatalError =
    dtoQ.data ? null : (!data.property ? (propQ.error ?? null) : null);

  const relationErrors = [
    dtoQ.data ? null : unitsQ.error,
    dtoQ.data ? null : leasesQ.error,
    dtoQ.data ? null : ownerQ.error,
  ].filter(Boolean) as Error[];

  const isLoading =
    dtoQ.isLoading ||
    (!dtoQ.data &&
      (propQ.isLoading || unitsQ.isLoading || leasesQ.isLoading || ownerQ.isLoading));

  return { data, isLoading, fatalError, relationErrors };
}


Update imports in:

src/pages/card/property/index.tsx


Replace:

import { usePropertyCardData } from "./api";


with:

import { usePropertyCardData } from "@/lib/cards/property.api";

2) Make the page non-blocking on relationship errors

Edit:

src/pages/card/property/index.tsx


Use the returned { fatalError, relationErrors }.

Only show the big error panel if fatalError is present (base property missing).

If relationErrors.length, render a small inline warning inside the Relationships section (do not block the page).

Minimal diff (conceptually):

const { data, isLoading, fatalError, relationErrors } = usePropertyCardData(id);

// BEFORE: if (error) render error panel
// AFTER:
if (fatalError) {
  return <Section className="ecc-object">Error loading property. Please try again.</Section>;
}

// ...render Hero, Tabs, Overview, RightRail

// Inside Overview (or below Relationships header):
{relationErrors.length > 0 && (
  <div className="ecc-object" style={{padding:8, opacity:.8}}>
    Some related data failed to load (units/leases/owner). The base property is shown.
  </div>
)}

3) Run checks (must pass)

node scripts/guardrail-mega.mjs → no violations (api moved out of /pages)

node scripts/guardrail-overlays.mjs → pass

npx tsc -p tsconfig.cards.json → 0 errors

4) Demo (what I should see)

/card/property/42 and /card/property/57:

Hero shows title + KPIs (Units, Active Leases, Avg Rent).

Overview fields populated; Owner clickable when present.

Right Rail map visible.

If any relation endpoint fails, I see the small inline warning but the page renders.

Copy-paste prompt for Replit
ECC FIX PACK M1.1 — make Property card resilient + guardrail clean

1) MOVE resolver:
- DELETE src/pages/card/property/api.ts
- CREATE src/lib/cards/property.api.ts with the DTO-first + entities-fallback resolver (constant hook count) exactly as provided.
- UPDATE src/pages/card/property/index.tsx to import from "@/lib/cards/property.api"

2) NON-BLOCKING ERRORS:
- In index.tsx, accept { data, isLoading, fatalError, relationErrors }.
- Render the big error panel ONLY if fatalError is present (missing base property).
- If relationErrors.length > 0, show a small inline warning inside the Relationships area; DO NOT block the page.

3) OWNER ENDPOINT FALLBACKS:
- Ensure the resolver tries owners/:id, owners?id=eq., and owner?id=eq. before giving up.

4) VERIFY:
- Run guardrail-mega, guardrail-overlays, and cards typecheck (tsconfig.cards.json) — all must pass 0 violations / 0 errors.
- Post the outputs.

5) DEMO:
- Post routes: /card/property/42 and /card/property/57.
- Confirm: page renders hero, overview, map; shows partial data even if any relation fetch fails.
