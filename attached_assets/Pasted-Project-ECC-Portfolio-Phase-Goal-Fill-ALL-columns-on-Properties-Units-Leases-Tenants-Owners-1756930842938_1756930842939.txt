Project: ECC — Portfolio Phase
Goal: Fill ALL columns on Properties, Units, Leases, Tenants, Owners by enriching backend endpoints. Do not touch the nav or styling.

HARD GUARDRAILS (do not violate):
- Do NOT modify src/layout/components/Sidebar.tsx or src/config/navigation.ts.
- Keep wouter; do NOT add react-router-dom.
- No mock data. Read from our live database only.
- Keep CSS/theme as-is.
- Backup any file you overwrite.

WHERE TO WORK:
- server/index.ts (replace the collection handlers only)
- Leave frontend files alone (pages already wired).

BACKEND MODE:
- We’re using Postgres (Supabase Postgres under the hood).
- Connection is already working; keep using our existing Pool/client.
- Table names default to: properties, units, leases, tenants, owners.
  - If env overrides (TBL_PROPERTIES, TBL_UNITS, TBL_LEASES, TBL_TENANTS, TBL_OWNERS) exist, use them.

WHAT TO CHANGE (server/index.ts):
1) Keep GET /api/health.
2) Replace GET /api/portfolio/:collection with a switch that runs **JOINed SQL per entity** and returns JSON arrays. Use the aliases below so the UI columns fill.

--- SQL SHAPES TO IMPLEMENT ---

-- PROPERTIES: include city/state/units/occupancy with safe fallbacks
/* aliases expected by UI: id, doorloop_id, name, type, class, active, city, state, unit_count, occupancy */
WITH unit_counts AS (
  SELECT u.property_id,
         COUNT(*) AS unit_count,
         COUNT(*) FILTER (WHERE lower(COALESCE(u.status,'')) = 'occupied') AS occ_units_status
  FROM units u
  GROUP BY u.property_id
),
lease_occ AS (
  SELECT u.property_id,
         COUNT(DISTINCT u.id) AS occ_units_lease
  FROM units u
  JOIN leases l ON l.unit_id = u.id AND lower(l.status) = 'active'
  GROUP BY u.property_id
),
merged AS (
  SELECT COALESCE(c.property_id, lo.property_id) AS property_id,
         COALESCE(c.unit_count, 0) AS unit_count,
         GREATEST(COALESCE(c.occ_units_status,0), COALESCE(lo.occ_units_lease,0)) AS occupied_units
  FROM unit_counts c
  FULL JOIN lease_occ lo ON lo.property_id = c.property_id
)
SELECT
  p.id, p.doorloop_id, p.name, p.type, p.class, p.active,
  COALESCE(p.address_city, '')   AS city,
  COALESCE(p.address_state, '')  AS state,
  COALESCE(p.unit_count, m.unit_count) AS unit_count,
  COALESCE(
    p.occupancy_rate,
    CASE WHEN m.unit_count > 0 THEN ROUND(100.0 * m.occupied_units / m.unit_count, 1) END
  ) AS occupancy
FROM properties p
LEFT JOIN merged m ON m.property_id = p.id
ORDER BY p.name NULLS LAST;

-- UNITS: include property name + normalized fields
/* aliases: id, doorloop_id, property, unit_number, beds, baths, sq_ft, status, market_rent */
SELECT
  u.id, u.doorloop_id,
  p.name AS property,
  COALESCE(u.unit_number, u.number, u.name, '') AS unit_number,
  COALESCE(u.beds, u.bedrooms)  AS beds,
  COALESCE(u.baths, u.bathrooms) AS baths,
  COALESCE(u.sq_ft, u.sqft)     AS sq_ft,
  COALESCE(
    u.status,
    CASE WHEN EXISTS (
      SELECT 1 FROM leases l WHERE l.unit_id = u.id AND lower(l.status) = 'active'
    ) THEN 'Occupied' ELSE 'Vacant' END
  ) AS status,
  COALESCE(u.market_rent, u.rent, u.asking_rent) AS market_rent
FROM units u
LEFT JOIN properties p ON p.id = u.property_id
ORDER BY p.name NULLS LAST, unit_number NULLS LAST;

-- LEASES: include property name, tenant names, rent, start, end, status
/* aliases: id, doorloop_id, tenant_names, property, rent, start, end, status */
WITH tn AS (
  -- prefer link table if present; otherwise fall back to leases.tenant_id
  SELECT l.id AS lease_id,
         COALESCE(
           (SELECT STRING_AGG(t.name, ', ' ORDER BY t.name)
              FROM lease_tenants lt
              JOIN tenants t ON t.id = lt.tenant_id
             WHERE lt.lease_id = l.id),
           (SELECT t2.name FROM tenants t2 WHERE t2.id = l.tenant_id)
         ) AS tenant_names
  FROM leases l
)
SELECT
  l.id, l.doorloop_id,
  tn.tenant_names,
  p.name AS property,
  COALESCE(l.total_recurring_rent, l.rent) AS rent,
  l.start_date AS start,
  l.end_date   AS "end",
  l.status
FROM leases l
LEFT JOIN properties p ON p.id = l.property_id
LEFT JOIN tn ON tn.lease_id = l.id
ORDER BY l.start_date DESC NULLS LAST;

-- TENANTS: include property + unit via current/most-recent lease
/* aliases: id, doorloop_id, name, property, unit, email, phone, status, balance */
WITH latest_lease AS (
  SELECT DISTINCT ON (t.id)
         t.id AS tenant_id, l.id AS lease_id, l.status,
         l.unit_id, l.property_id,
         l.start_date, l.end_date
  FROM tenants t
  LEFT JOIN leases l ON l.tenant_id = t.id
  ORDER BY t.id, COALESCE(l.updated_at, l.start_date) DESC NULLS LAST
)
SELECT
  t.id, t.doorloop_id,
  COALESCE(t.name, CONCAT_WS(' ', t.first_name, t.last_name)) AS name,
  p.name AS property,
  COALESCE(u.unit_number, u.number, u.name, '') AS unit,
  COALESCE(t.primary_email, t.email) AS email,
  COALESCE(t.primary_phone, t.phone) AS phone,
  COALESCE(ll.status, t.status) AS status,
  t.balance
FROM tenants t
LEFT JOIN latest_lease ll ON ll.tenant_id = t.id
LEFT JOIN units u ON u.id = ll.unit_id
LEFT JOIN properties p ON p.id = COALESCE(u.property_id, ll.property_id)
ORDER BY name NULLS LAST;

-- OWNERS: include property_count; prefer crosswalk table, else owners_json
/* aliases: id, doorloop_id, name, email, phone, property_count, active */
WITH pc AS (
  SELECT po.owner_id, COUNT(DISTINCT po.property_id) AS property_count
  FROM property_owners po
  GROUP BY po.owner_id
)
SELECT
  o.id, o.doorloop_id,
  COALESCE(o.name, o.company_name) AS name,
  COALESCE(o.primary_email, o.email) AS email,
  COALESCE(o.primary_phone, o.phone) AS phone,
  COALESCE(o.property_count, pc.property_count, 0) AS property_count,
  o.active
FROM owners o
LEFT JOIN pc ON pc.owner_id = o.id
ORDER BY name NULLS LAST;

IMPLEMENTATION NOTES:
- If a helper table (e.g., lease_tenants, property_owners) is missing, code the SQL to fall back gracefully (the tn CTE above already does this for tenants).
- Keep endpoint URLs the same: /api/portfolio/{properties|units|leases|tenants|owners}.
- Return raw arrays; keys must exactly match the aliases above (snake_case) so the existing column mappers can read them.
- Do not change the frontend.

TEST PLAN (must pass):
1) GET /api/health → JSON ok:true.
2) Each endpoint returns an array with the aliased fields above (not HTML).
3) In the UI, go to Portfolio V3 → each page now shows values in all columns (not just names).
4) No console errors. No nav changes.

REPORT BACK:
- Confirm the SQL you used for each endpoint (or adjusted for schema).
- List any helper tables that didn’t exist and what fallback you applied.
- Paste the first 2 sample rows from each endpoint (with keys only, no sensitive values).
