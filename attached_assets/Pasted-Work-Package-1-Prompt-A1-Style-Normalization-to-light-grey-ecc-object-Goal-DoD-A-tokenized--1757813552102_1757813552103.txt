Work Package 1 — Prompt A1: Style Normalization to light-grey .ecc-object

Goal (DoD):

A tokenized light-grey card surface used everywhere.

No page returns null; all content lives inside .ecc-object sections via a shared Section component.

Global import wired once in main.tsx (or your root).

Paste this to Replit AI (exactly):

TITLE: Apply light-grey .ecc-object globally + add Section
RULES:

Do not modify workflows or package.json.

Keep overlay guardrails intact.

No route changes.
CHANGES:

Create src/styles/ecc.css (new) with the token set and section styles below.

Create src/components/Section.tsx (new) with the shared section wrapper below.

Import import '@/styles/ecc.css' once in src/main.tsx (top-level).

Replace ad-hoc card panel wrappers in card pages (Property/Unit/Lease/Tenant/Owner) with <Section> (one or two places per page is enough for this step; we’ll expand later).

Do not change any data logic.

/* src/styles/ecc.css */
:root {
  /* Palette */
  --ecc-bg: #0b0e12;
  --ecc-surface: #1b1f26;          /* app chrome */
  --ecc-object: #232834;           /* light-grey card surface (relative to dark bg) */
  --ecc-border: #2f3542;
  --ecc-border-soft: #2a2f3b;
  --ecc-text: #d7dbe3;
  --ecc-text-dim: #a5adba;
  --ecc-gold: #d6b36a;
  --ecc-green: #35c28d;
  --ecc-red: #f47575;
  --ecc-yellow: #d6b86a;

  /* Spacing + radius */
  --ecc-radius-card: 14px;
  --ecc-radius-btn: 10px;
  --ecc-gap-1: 8px;
  --ecc-gap-2: 12px;
  --ecc-gap-3: 16px;
}

html, body, #root { height: 100%; background: var(--ecc-bg); color: var(--ecc-text); }
* { box-sizing: border-box; }

/* The normalized card surface */
.ecc-object {
  background: var(--ecc-object);
  border: 1px solid var(--ecc-border);
  border-radius: var(--ecc-radius-card);
  box-shadow: 0 1px 0 rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.02);
}

/* Section grammar */
.ecc-section {
  padding: 16px;
}
.ecc-section + .ecc-section { margin-top: 12px; }
.ecc-section__head {
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: 10px;
}
.ecc-section__title {
  font-weight: 600; letter-spacing: .2px; color: var(--ecc-text);
}
.ecc-section__hint {
  color: var(--ecc-text-dim); font-size: 12px;
}
.ecc-divider { height: 1px; background: var(--ecc-border-soft); margin: 8px 0 12px; }

/* FieldRows baseline (atoms will add variants) */
.ecc-fields { display: grid; grid-template-columns: 180px 1fr; gap: 8px 16px; }
.ecc-label { color: var(--ecc-text-dim); }
.ecc-value { color: var(--ecc-text); }

/* Simple skeleton */
@keyframes ecc-skel { 0%{opacity:.6} 50%{opacity:.3} 100%{opacity:.6} }
.ecc-skel { background: var(--ecc-border-soft); border-radius: 8px; height: 12px; animation: ecc-skel 1.2s ease-in-out infinite; }

// src/components/Section.tsx
import React from 'react';

type SectionProps = {
  title?: string;
  hint?: React.ReactNode;
  actions?: React.ReactNode;
  children?: React.ReactNode;
  id?: string;
  className?: string;
  pad?: boolean; // default true
};

export default function Section({
  title, hint, actions, children, id, className='', pad=true
}: SectionProps) {
  return (
    <section id={id} className={`ecc-object ecc-section ${className}`} role="region" aria-label={title ?? undefined}>
      {(title || actions || hint) && (
        <header className="ecc-section__head">
          <div>
            {title && <div className="ecc-section__title">{title}</div>}
            {hint && <div className="ecc-section__hint">{hint}</div>}
          </div>
          <div>{actions}</div>
        </header>
      )}
      {(title || actions || hint) && <div className="ecc-divider" />}
      <div style={{ padding: pad ? 0 : 0 }}>
        {children}
      </div>
    </section>
  );
}


Verification (DoD):

App runs unchanged; global chrome unchanged.

Any Property/Unit/Lease card shows at least two panels rendered with .ecc-object style (visibly lighter than page bg).

No “full-screen overlay” artifacts. No page goes blank.

Lighthouse/contrast quick check: section titles ≥ AA against .ecc-object.

Work Package 1 — Prompt A2: Security Hardening (BFF action + kill client token)

Goal (DoD):

“New Work Order” calls BFF POST /api/bff/work-orders/create (no direct admin APIs).

Any usage of VITE_ADMIN_SYNC_TOKEN from client code is removed.

UI action is role/flag gated and shows loading, success, failure.

Paste this to Replit AI (exactly):

TITLE: Route “New Work Order” through BFF and remove client token usage
RULES:

Do not add tokens to client code.

No workflow/package changes.

Preserve guardrails.
CHANGES:

Create src/lib/bff.ts (new) with a safe postJson and typed createWorkOrder.

Update the Property card hero action to use createWorkOrder(propertyId, summary); show a toast/inline notice on result. If no toast system exists, use alert() as fallback.

Remove all references to import.meta.env.VITE_ADMIN_SYNC_TOKEN from src/**. (If any server-side code uses it, leave server code untouched.)

Add a tiny feature gate: if window.__FEATURES__?.workOrders !== true, render the button disabled with a tooltip “Coming soon”.

// src/lib/bff.ts
export type WorkOrderPayload = {
  propertyId: string;
  summary: string;
  priority?: 'low'|'normal'|'high';
};

async function postJson<T>(url: string, body: any): Promise<T> {
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type':'application/json' },
    body: JSON.stringify(body),
    credentials: 'include'
  });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json() as Promise<T>;
}

export async function createWorkOrder(input: WorkOrderPayload): Promise<{ ok: boolean; workOrderId?: string; }> {
  return postJson<{ ok: boolean; workOrderId?: string; }>('/api/bff/work-orders/create', input);
}

// Example patch inside Property Hero (where actions render)
// Pseudocode – integrate at the action where "New Work Order" button is defined.
import { createWorkOrder } from '@/lib/bff';
// ...
const canWO = (window as any).__FEATURES__?.workOrders === true;
const [woBusy, setWoBusy] = React.useState(false);

async function handleNewWO() {
  if (!property?.id) return;
  try {
    setWoBusy(true);
    const r = await createWorkOrder({ propertyId: String(property.id), summary: `WO from Property #${property.id}`, priority: 'normal' });
    (window as any).toast?.success?.('Work order created') ?? alert('Work order created');
    console.log('WO:', r);
  } catch (e:any) {
    (window as any).toast?.error?.('Failed to create work order') ?? alert('Failed to create work order');
    console.error(e);
  } finally {
    setWoBusy(false);
  }
}

// In JSX:
<button
  className="ecc-object"
  disabled={!canWO || woBusy}
  title={!canWO ? 'Coming soon' : undefined}
  onClick={handleNewWO}
>
  {woBusy ? 'Creating…' : 'New Work Order'}
</button>


Delete client token usages:

Grep the client: src/** for VITE_ADMIN_SYNC_TOKEN. Remove any reference/import, and ensure no headers are built from it in the browser. (Server/BFF can still read it from env; client must not.)

Verification (DoD):

Searching src/** shows no VITE_ADMIN_SYNC_TOKEN.

Clicking “New Work Order” issues POST /api/bff/work-orders/create with {propertyId,summary,priority} and handles the response.

If the feature flag is false, the button is disabled with “Coming soon” tooltip.

No direct calls to admin APIs from the browser.