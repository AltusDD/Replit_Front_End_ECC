ECC Compliance — Legacy Purge & Runtime Sync Pack v6
0) Execution mode (paste first into Replit AI)
MODE: Contract Compliance Executor (CSP v2)
Rules:
- Only apply the changes below.
- Backup touched files to *.bak before writing.
- After each section, print unified diffs and run the proof commands.

1) PURGE legacy code (remove files/dirs + block re-introductions)
1.1 Delete legacy sources (hard delete)
# backup and remove legacy portfolio components and Section
mkdir -p .attic/legacy

[ -d src/features/portfolio/components ] && \
  tar -czf .attic/legacy/portfolio_components_$(date +%s).tgz src/features/portfolio/components && \
  rm -rf src/features/portfolio/components

for f in src/components/Section.tsx src/components/Section/index.tsx src/components/Section.jsx; do
  if [ -f "$f" ]; then
    mkdir -p .attic/legacy && cp "$f" ".attic/legacy/$(basename $f).bak"
    rm -f "$f"
  fi
done

# if a shim exists, keep only re-export to single resolver (done earlier), else create it
cat > src/lib/ecc-card-queries.ts <<'EOF'
export * from "./ecc-resolvers";
EOF

1.2 Extend guardrail to fail the build if legacy ever reappears

Append this block to scripts/guardrail-check.mjs (create the file if it doesn’t exist):

// === Legacy Purge Enforcement ===
import fs from "fs"; import path from "path"; import glob from "glob";
const ROOT = process.cwd();
let failures = 0;

const forbiddenDirs = [
  "src/features/portfolio/components",
  "src/components/Section",
];
for (const d of forbiddenDirs) {
  if (fs.existsSync(path.join(ROOT, d))) {
    console.error("[guardrail] forbidden directory present:", d); failures++;
  }
}

const forbiddenImports = [
  "@/features/portfolio/components",
  "@/components/Section",
];
for (const rel of glob.sync("src/**/*.{ts,tsx,js,jsx}", { cwd: ROOT })) {
  const s = fs.readFileSync(path.join(ROOT, rel), "utf8");
  for (const bad of forbiddenImports) {
    if (s.includes(bad)) {
      console.error("[guardrail] forbidden import in", rel, "→", bad); failures++;
    }
  }
}

if (typeof globalThis.failuresSum === "number") globalThis.failuresSum += failures;
else globalThis.failuresSum = failures;

1.3 Add ESLint import bans (repo-wide)

Create or update .eslintrc.cjs (or .eslintrc.js) to include:

module.exports = {
  root: true,
  extends: ["eslint:recommended", "plugin:react/recommended", "plugin:@typescript-eslint/recommended"],
  parser: "@typescript-eslint/parser",
  plugins: ["@typescript-eslint", "react"],
  rules: {
    "no-restricted-imports": ["error", {
      "paths": [
        { "name": "@/features/portfolio/components", "message": "Legacy components are banned. Use @/components/cardkit/*" },
        { "name": "@/components/Section", "message": "Legacy Section is banned. Use CardShell." }
      ],
      "patterns": ["@/features/portfolio/components/*"]
    }]
  },
  settings: { react: { version: "detect" } }
};

2) Contract fixes still outstanding (tenant + owner DTO parity)

Update server/routes/rpc.ts if not already done (idempotent):

// TENANT: add activeLease in response
// after leases normalization in /get_tenant_card:
const activeLease = leases.find(l => (String(l.status||'').toLowerCase()==='active')) || null;
return res.json({ tenant, leases, properties, activeLease });

// OWNER: add avgRentCents parity
// in /get_owner_card after leases normalization:
const active = leases.filter(l => l.status === 'active');
const occPct = units.length ? Math.round((active.length/units.length)*1000)/10 : 0;
const rentNums = active.map(l => Number((l as any).rent_cents ?? (l as any).rent ?? 0)).filter(Number.isFinite);
const avgRentCents = rentNums.length ? Math.round(rentNums.reduce((a,b)=>a+b,0)/rentNums.length) : 0;
return res.json({
  owner,
  properties: properties.map(p => ({ ...p, ...mapAddress(p) })),
  kpis: { units: units.length, activeLeases: active.length, occupancyPct: occPct, avgRentCents }
});

3) Import path consistency (absolute alias + TS paths)
3.1 Ensure Vite alias (idempotent)

Edit vite.config.* to include:

import path from "path";
export default {
  // ...
  resolve: { alias: { "@": path.resolve(__dirname, "src") } }
};

3.2 Ensure tsconfig.json paths
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}

4) Clean rebuild to eliminate runtime drift (HMR/cache)
# stop any running dev servers (Replit: stop the process)
rm -rf node_modules/.vite .vite dist .cache .parcel-cache 2>/dev/null || true
npm ci
npm run guardrail
npm run build
npm run dev

5) Proofs (runtime, not just file scan)

Pick a real property id (e.g., 42); then:

# Backend DTOs
curl -s "http://localhost:8787/api/rpc/get_property_card?id=42" | jq '{kpis:.kpis, city:.property.city, state:.property.state, zip:.property.zip}'
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=1" | jq '{hasActiveLease: (.activeLease!=null), leases: (.leases|length)}'
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=1" | jq '{units:(.kpis.units), active:(.kpis.activeLeases), occ:(.kpis.occupancyPct), avg:(.kpis.avgRentCents)}'

# Frontend (open with Vite, not API port)
# http://localhost:5173/card/property/42
# http://localhost:5173/card/unit/172
# http://localhost:5173/card/lease/1
# http://localhost:5173/card/tenant/1
# http://localhost:5173/card/owner/1

# In DevTools console (optional DOM proof):
['kpi-units','kpi-active','kpi-occupancy','kpi-avgrent','address',
 'kpi-lease-status','kpi-rent','kpi-bedbath','kpi-sqft',
 'kpi-term','kpi-balance',
 'kpi-active-leases','kpi-current-balance','kpi-on-time-rate','kpi-open-workorders',
 'kpi-portfolio-units','kpi-occupancy','kpi-avg-rent'
].every(id=>!!document.querySelector(`[data-testid="${id}"]`))


Expected:

Guardrail: PASS (no legacy dirs/imports, single resolver system, route+ID coercion, test IDs).

RPC proofs: non-null KPIs; tenant has activeLease when appropriate; owner KPIs include avgRentCents.

UI: all five /card/*/:id routes render; hero blocks show populated values with required data-testids.

6) Commit the purge + compliance gate
git add -A
git commit -m "ECC: Legacy purge + guardrail enforcement; DTO parity; alias/paths; clean rebuild; runtime proofs pass"

What this guarantees

No legacy code anywhere (directories removed, imports banned at lint + guardrail, CI fails if it reappears).

Unified architecture on all five cards (CardShell + KPIRow/KPI + HeroBlock naming).

DTO parity across Tenant/Owner with the fields your UI expects.

Consistent imports with @ alias and TS paths.

Runtime correctness, not just file-level—clean rebuild + proofs.

If any guardrail or proof fails, paste that exact error output and I’ll hand you a surgical patch for that file only.