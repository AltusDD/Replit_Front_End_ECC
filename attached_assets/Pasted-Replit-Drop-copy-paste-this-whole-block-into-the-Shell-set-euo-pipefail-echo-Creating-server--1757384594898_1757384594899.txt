Replit Drop (copy–paste this whole block into the Shell)
set -euo pipefail

echo "▶ Creating server helpers and routes…"

mkdir -p server/lib server/routes src/utils src/styles

# --- server/lib/geocode.ts ---
cat > server/lib/geocode.ts <<'TS'
/**
 * Lightweight geocoding helper with Google (preferred) or OSM fallback.
 * Uses: GEOCODER_PROVIDER=google|osm, GOOGLE_MAPS_API_KEY
 */
type GeoResult = { lat: number; lng: number } | null;

const sleep = (ms:number)=> new Promise(r=>setTimeout(r, ms));

async function geocodeGoogle(address: string): Promise<GeoResult> {
  const apiKey = process.env.GOOGLE_MAPS_API_KEY || "";
  if (!apiKey) return null;
  const url = new URL("https://maps.googleapis.com/maps/api/geocode/json");
  url.searchParams.set("address", address);
  url.searchParams.set("key", apiKey);
  const res = await fetch(url.toString());
  if (!res.ok) return null;
  const j = await res.json();
  const loc = j?.results?.[0]?.geometry?.location;
  if (!loc || typeof loc.lat !== "number" || typeof loc.lng !== "number") return null;
  return { lat: loc.lat, lng: loc.lng };
}

async function geocodeOSM(address: string): Promise<GeoResult> {
  const url = new URL("https://nominatim.openstreetmap.org/search");
  url.searchParams.set("q", address);
  url.searchParams.set("format", "json");
  url.searchParams.set("limit", "1");
  const res = await fetch(url.toString(), { headers: { "User-Agent": "ECC/1.0" }});
  if (!res.ok) return null;
  const j = await res.json();
  const row = j?.[0];
  if (!row || !row.lat || !row.lon) return null;
  return { lat: Number(row.lat), lng: Number(row.lon) };
}

export async function geocodeAddress(address: string): Promise<GeoResult> {
  const provider = (process.env.GEOCODER_PROVIDER || "google").toLowerCase();
  if (provider === "google") {
    const g = await geocodeGoogle(address);
    if (g) return g;
    return geocodeOSM(address);
  } else {
    const o = await geocodeOSM(address);
    if (o) return o;
    return geocodeGoogle(address);
  }
}

export async function backfillPropertyCoords(
  { limit=50, delayMs=1100, admin, fromOwnerId }:
  { limit?: number; delayMs?: number; admin: any; fromOwnerId?: number }
) {
  // fetch properties missing lat/lng (optionally only a specific owner)
  let q = admin.from("properties")
    .select("id,name,address1,city,state,zip,lat,lng")
    .is("lat", null)
    .is("lng", null)
    .limit(limit);

  if (fromOwnerId) q = q.eq("owner_id", fromOwnerId);

  const { data, error } = await q;
  if (error) throw new Error(error.message);

  let updated = 0;
  for (const p of (data || [])) {
    const parts = [p.address1, p.city, p.state, p.zip].filter(Boolean);
    if (!parts.length) continue;
    const addr = parts.join(", ");
    const geo = await geocodeAddress(addr);
    if (geo) {
      const { error: uerr } = await admin.from("properties")
        .update({ lat: geo.lat, lng: geo.lng })
        .eq("id", p.id);
      if (!uerr) updated++;
    }
    await sleep(delayMs); // be polite to APIs
  }
  return { checked: (data||[]).length, updated };
}
TS

# --- server/routes/owners.ts ---
cat > server/routes/owners.ts <<'TS'
import type { Express } from "express";
import { sbAdmin } from "../lib/supabaseAdmin";

export function installOwnerRoutes(app: Express) {
  // live type-ahead (company or first/last)
  app.get("/api/owners/search", async (req, res) => {
    const q = String(req.query.q || "").trim();
    if (!q) return res.json({ owners: [] });

    const like = `%${q}%`;
    const { data, error } = await sbAdmin
      .from("owners")
      .select("id,company_name,first_name,last_name,email,phone,status")
      .or(`company_name.ilike.${like},first_name.ilike.${like},last_name.ilike.${like}`)
      .order("company_name", { ascending: true })
      .limit(25);

    if (error) return res.status(500).json({ error: error.message });

    const owners = (data||[]).map(o => ({
      id: o.id,
      display_name: o.company_name?.trim()
        ? o.company_name.trim()
        : [o.last_name, o.first_name].filter(Boolean).join(", "),
      meta: o.company_name?.trim() && (o.first_name || o.last_name)
        ? [o.last_name, o.first_name].filter(Boolean).join(", ")
        : undefined,
      email: o.email, phone: o.phone, status: o.status,
    }));
    res.json({ owners });
  });

  // properties that belong to an owner (for Owner Card & Transfer modal)
  app.get("/api/owners/:id/properties", async (req, res) => {
    const ownerId = Number(req.params.id);
    if (!Number.isFinite(ownerId)) return res.status(400).json({ error: "bad owner id" });

    const { data, error } = await sbAdmin
      .from("properties")
      .select("id,doorloop_id,name,address1,city,state,zip,units_count,lat,lng")
      .eq("owner_id", ownerId)
      .order("name", { ascending: true });

    if (error) return res.status(500).json({ error: error.message });
    res.json({ properties: data || [] });
  });
}
TS

# --- server/routes/properties.ts ---
cat > server/routes/properties.ts <<'TS'
import type { Express } from "express";
import { sbAdmin } from "../lib/supabaseAdmin";

export function installPropertyRoutes(app: Express) {
  // first try internal id
  app.get("/api/properties/:id", async (req, res) => {
    const id = Number(req.params.id);
    if (!Number.isFinite(id)) return res.status(400).json({ error: "bad id" });

    const { data, error } = await sbAdmin
      .from("properties")
      .select("*, owner:owners(id,company_name,first_name,last_name)")
      .eq("id", id)
      .single();

    if (error && error.code !== "PGRST116") return res.status(500).json({ error: error.message });
    if (!data) return res.status(404).json({ error: "not_found" });
    res.json({ property: data });
  });

  // fallback by DoorLoop id (deep links that use external ids)
  app.get("/api/properties/by-doorloop/:dlId", async (req, res) => {
    const dlId = String(req.params.dlId);
    const { data, error } = await sbAdmin
      .from("properties")
      .select("*, owner:owners(id,company_name,first_name,last_name)")
      .eq("doorloop_id", dlId)
      .single();

    if (error && error.code !== "PGRST116") return res.status(500).json({ error: error.message });
    if (!data) return res.status(404).json({ error: "not_found" });
    res.json({ property: data });
  });
}
TS

# --- server/routes/geocode.ts ---
cat > server/routes/geocode.ts <<'TS'
import type { Express } from "express";
import { sbAdmin } from "../lib/supabaseAdmin";
import { backfillPropertyCoords } from "../lib/geocode";

function ok(req: any): boolean {
  const hdr = String(req.headers["authorization"] || "");
  const token = hdr.startsWith("Bearer ") ? hdr.slice(7) : (req.query.token || "");
  const want = process.env.ADMIN_SYNC_TOKEN || "";
  return want && token && String(token) === String(want);
}

export function installGeocodeRoutes(app: Express) {
  // quick status (total vs with coords)
  app.get("/api/admin/geocode/status", async (_req, res) => {
    const [{ data: total }, { data: withCoords }] = await Promise.all([
      sbAdmin.from("properties").select("id", { count: "exact", head: true }),
      sbAdmin.from("properties").select("id", { count: "exact", head: true }).not("lat", "is", null).not("lng", "is", null),
    ]);
    res.json({ total: total?.length || 0, with_coords: withCoords?.length || 0 });
  });

  // secure backfill (accepts optional owner_id)
  app.post("/api/admin/geocode/backfill", async (req, res) => {
    if (!ok(req)) return res.status(401).json({ error: "unauthorized" });
    const ownerId = req.body?.owner_id ? Number(req.body.owner_id) : undefined;
    try {
      const result = await backfillPropertyCoords({ admin: sbAdmin, fromOwnerId: ownerId, limit: 100, delayMs: 1100 });
      res.json({ ok: true, ...result });
    } catch (e:any) {
      res.status(500).json({ error: e?.message || "failed" });
    }
  });
}
TS

# --- src/utils/display.ts (tiny helper used in UI if you want) ---
cat > src/utils/display.ts <<'TS'
export function ownerDisplay(company?: string|null, first?: string|null, last?: string|null) {
  if (company && company.trim()) return company.trim();
  const parts = [last, first].filter(Boolean);
  return parts.length ? parts.join(", ") : "Unknown Owner";
}
TS

# (Optional) a tiny css used by enhanced modal if/when you adopt it later
cat > src/styles/transfer-modal.css <<'CSS'
.modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;z-index:50}
.modal-card{background:var(--panel-elev);border:1px solid var(--line);border-radius:16px;min-width:720px;max-width:900px;padding:20px;box-shadow:0 8px 40px rgba(0,0,0,.5)}
.modal-title{font-size:18px;font-weight:600;margin-bottom:12px}
.lbl{font-size:12px;color:var(--text-dim);display:block;margin-bottom:6px}
.input{width:100%;background:#101316;border:1px solid var(--line);border-radius:10px;padding:10px 12px;color:var(--text)}
.menu{margin-top:6px;max-height:220px;overflow:auto;border:1px solid var(--line);border-radius:10px;background:#0e1114}
.menu-item{padding:10px 12px;cursor:pointer}
.menu-item:hover,.menu-item.active{background:#14181d}
.list{border:1px solid var(--line);border-radius:10px;background:#0e1114;padding:8px;max-height:260px;overflow:auto}
.list.tall{max-height:320px}
.row{display:flex;align-items:center;padding:8px 6px}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.muted{color:var(--text-dim)}
.mt-1{margin-top:6px}.mt-2{margin-top:10px}.mt-3{margin-top:16px}
.actions{display:flex;justify-content:flex-end;gap:10px;margin-top:18px}
.btn{border-radius:999px;padding:10px 16px;border:1px solid var(--line);background:#11151a;color:var(--text)}
.btn.gold{background:var(--altus-gold);color:#000;border-color:transparent}
.btn.ghost{background:transparent}
.link{color:var(--altus-gold);background:transparent;border:none;cursor:pointer}
CSS

# --- Patch server/index.ts (import + install our routes) ---
if [ -f server/index.ts ]; then
  cp server/index.ts server/index.ts.bak

  node <<'NODE'
  const fs = require('fs');
  const path = 'server/index.ts';
  let s = fs.readFileSync(path, 'utf8');

  if (!s.includes('installOwnerRoutes')) {
    s = 'import { installOwnerRoutes } from "./routes/owners";\n'
      + 'import { installPropertyRoutes } from "./routes/properties";\n'
      + 'import { installGeocodeRoutes } from "./routes/geocode";\n'
      + s;
  }
  // naive insert after first "const app = express()"
  if (s.includes('const app = express()') && !s.includes('installGeocodeRoutes(app)')) {
    s = s.replace('const app = express();', (m) => m + '\n  installOwnerRoutes(app);\n  installPropertyRoutes(app);\n  installGeocodeRoutes(app);\n');
  }
  fs.writeFileSync(path, s);
  console.log('Patched server/index.ts');
NODE
else
  echo "WARN: server/index.ts not found; please wire routes manually."
fi

echo "✅ Drop completed. Rebuilding…"
npm run build >/dev/null 2>&1 || true
echo "▶ Done. Restart the server if it doesn't hot reload."

✅ What you just got

/api/owners/search?q=… → live type-ahead (company or first/last)

/api/owners/:id/properties → only this owner’s properties (with units count + coords)

/api/properties/:id + /api/properties/by-doorloop/:dlId → deep-link fallback

/api/admin/geocode/status → coord counts

/api/admin/geocode/backfill → secure batch geocoder that writes lat/lng to properties

The map widget in your dashboard will start showing pins as soon as properties have lat/lng. This drop gives you the safe backfill to populate those.

🔑 Env you should have set (Replit “Secrets”)

ADMIN_SYNC_TOKEN → any strong string you choose

GOOGLE_MAPS_API_KEY → already present (good)

GEOCODER_PROVIDER=google (or omit to default to google)

🧪 Quick tests (no code changes)

Owner search
Open browser devtools → Network. Hit:

/api/owners/search?q=Trust
/api/owners/search?q=Smith


You should see results immediately.

Owner’s properties only

/api/owners/2/properties


Should list only that owner’s assets.

Property deep-link
If /card/property/44 previously failed because 44 was a DoorLoop id, try:

/api/properties/by-doorloop/44


You should now get the property JSON.

Map backfill

Check counts: /api/admin/geocode/status

Run backfill (replace TOKEN):

curl -X POST https://<your-app>/api/admin/geocode/backfill?token=YOUR_ADMIN_SYNC_TOKEN \
  -H "Content-Type: application/json" \
  -d '{}'


Watch it return { ok:true, checked:N, updated:M }.
Re-check status. When with_coords > 0, refresh the dashboard—the map renders.

(You can run backfill multiple times; it only touches rows missing coords. Add { "owner_id": 2 } in the JSON body to geocode one owner's portfolio first.)

Why the map wasn’t showing

Your properties table had 0 rows with lat/lng (you confirmed this in Supabase). The dashboard was fine—it just had nothing to plot. The secure geocoding route writes coordinates back into the DB so the existing component can render immediately.