Replit Drop (copy/paste into the Replit Shell)
set -euo pipefail

echo "▶ Owner Transfer — creating files & routes (safe patch)…"

mkdir -p server/lib server/routes src/features/owners/components src/features/owners/pages src/utils src/styles

# ---------- SERVER: Transfer engine ----------
cat > server/lib/ownerTransfer.ts <<'TS'
import { sbAdmin } from "./supabaseAdmin";

type TransferStatus = 'DRAFT'|'PENDING_ACCOUNTING'|'APPROVED_ACCOUNTING'|'READY_EXECUTION'|'COMPLETE'|'FAILED';

export type InitiatePayload = {
  old_owner_id: number;
  new_owner_id: number;
  property_ids: number[];
  effective_date: string; // "YYYY-MM-DD"
  notes?: string;
  initiated_by?: string; // UUID (optional)
};

const nowIso = () => new Date().toISOString();

async function insertAudit(event_type:string, payload:any, ref_table?:string, ref_id?:number, label?:string) {
  try {
    await sbAdmin.from("audit_events").insert({
      event_type, ref_table, ref_id, payload, label, created_at: new Date().toISOString()
    });
  } catch {}
}

async function safeSingle<T=any>(q:any):Promise<T|null> {
  const { data, error } = await q.single();
  if (error?.code === "PGRST116") return null;
  if (error) throw new Error(error.message);
  return data as T;
}

export async function validatePropsBelongToOwner(property_ids:number[], owner_id:number) {
  if (!property_ids.length) throw new Error("No properties selected.");
  const { data, error } = await sbAdmin
    .from("properties")
    .select("id")
    .eq("owner_id", owner_id)
    .in("id", property_ids);
  if (error) throw new Error(error.message);
  const okIds = new Set((data||[]).map((r:any)=>r.id));
  const bad = property_ids.filter(id=>!okIds.has(id));
  if (bad.length) throw new Error(`Some properties are not owned by owner ${owner_id}: [${bad.join(", ")}]`);
}

export async function snapshotForTransfer(transfer_id:number, property_ids:number[]) {
  // Snapshot properties
  const tables = [
    { name: "properties", key: "id", filter: "id" },
    { name: "units", key: "id", filter: "property_id" },
    { name: "leases", key: "id", filter: "property_id" },
    { name: "tenants", key: "id", filter: "property_id" },
  ];
  for (const t of tables) {
    try {
      const { data } = await sbAdmin.from(t.name).select("*").in(t.filter, property_ids);
      for (const row of (data||[])) {
        await sbAdmin.from("owner_transfer_snapshots").insert({
          transfer_id,
          entity_type: t.name === "properties" ? "property"
                     : t.name === "units" ? "unit"
                     : t.name === "leases" ? "lease"
                     : "tenant",
          entity_id: row[t.key],
          raw_jsonb: row,
          captured_at: nowIso(),
        });
      }
    } catch {}
  }
}

export async function initiateTransfer(p:InitiatePayload) {
  if (p.old_owner_id === p.new_owner_id) throw new Error("New owner must be different.");
  await validatePropsBelongToOwner(p.property_ids, p.old_owner_id);

  const today = new Date(); today.setHours(0,0,0,0);
  const eff = new Date(p.effective_date); eff.setHours(0,0,0,0);

  // business rule: always go through Accounting first
  const status: TransferStatus = 'PENDING_ACCOUNTING';

  const { data, error } = await sbAdmin.from("owner_transfers").insert({
    property_ids: p.property_ids,
    old_owner_id: p.old_owner_id,
    new_owner_id: p.new_owner_id,
    effective_date: p.effective_date,
    status,
    notes: p.notes || null,
    initiated_by: p.initiated_by || null,
    created_at: nowIso(),
  }).select("id").single();

  if (error) throw new Error(error.message);
  const transfer_id = data.id as number;

  await snapshotForTransfer(transfer_id, p.property_ids);
  await insertAudit("OWNER_TRANSFER_INITIATED", { ...p, transfer_id, status, timing: eff.getTime() < today.getTime() ? "retro" : "future" }, "owner_transfers", transfer_id, "OWNER_TRANSFER");

  return { transfer_id, status };
}

export async function approveAccounting(transfer_id:number) {
  await sbAdmin.from("owner_transfers").update({ status: 'APPROVED_ACCOUNTING' }).eq("id", transfer_id);
  await insertAudit("OWNER_TRANSFER_APPROVED_ACCOUNTING", { transfer_id }, "owner_transfers", transfer_id, "OWNER_TRANSFER");
  return { ok: true };
}

export async function authorizeTransfer(transfer_id:number) {
  await sbAdmin.from("owner_transfers").update({ status: 'READY_EXECUTION' }).eq("id", transfer_id);
  await insertAudit("OWNER_TRANSFER_READY_EXECUTION", { transfer_id }, "owner_transfers", transfer_id, "OWNER_TRANSFER");
  return { ok: true };
}

export async function executeTransfer(transfer_id:number) {
  const t = await safeSingle<any>(sbAdmin.from("owner_transfers").select("*").eq("id", transfer_id));
  if (!t) throw new Error("Transfer not found.");
  if (t.status !== 'READY_EXECUTION') throw new Error(`Transfer not ready (status=${t.status}).`);

  // Change ownership on selected properties
  const { error } = await sbAdmin.from("properties")
    .update({ owner_id: t.new_owner_id })
    .in("id", t.property_ids || []);
  if (error) throw new Error(error.message);

  await sbAdmin.from("owner_transfers").update({ status: 'COMPLETE', executed_at: nowIso() }).eq("id", transfer_id);
  await insertAudit("OWNER_TRANSFER_EXECUTED", { transfer_id, property_ids: t.property_ids }, "owner_transfers", transfer_id, "OWNER_TRANSFER");
  return { ok: true };
}

/** tiny scheduler tick: execute any READY_EXECUTION with effective_date <= today */
export async function runDueTransfersTick() {
  const today = new Date(); today.setHours(23,59,59,999);
  const { data, error } = await sbAdmin
    .from("owner_transfers")
    .select("id")
    .lte("effective_date", today.toISOString().slice(0,10))
    .eq("status", "READY_EXECUTION")
    .limit(20);
  if (error) return;

  for (const row of (data || [])) {
    try { await executeTransfer(row.id); } catch {}
  }
}
TS

# ---------- SERVER: Transfer routes ----------
cat > server/routes/ownerTransfer.ts <<'TS'
import type { Express } from "express";
import { initiateTransfer, approveAccounting, authorizeTransfer, executeTransfer } from "../lib/ownerTransfer";
import { sbAdmin } from "../lib/supabaseAdmin";

function isAdmin(req:any) {
  const hdr = String(req.headers["authorization"] || "");
  const token = hdr.startsWith("Bearer ") ? hdr.slice(7) : (req.query.token || "");
  return token && process.env.ADMIN_SYNC_TOKEN && token === process.env.ADMIN_SYNC_TOKEN;
}

export function installOwnerTransferRoutes(app: Express) {
  app.post("/api/owner-transfer/initiate", async (req, res) => {
    try {
      const result = await initiateTransfer(req.body);
      res.json({ ok:true, ...result });
    } catch (e:any) { res.status(400).json({ ok:false, error: e?.message || "failed" }); }
  });

  app.post("/api/owner-transfer/approve-accounting", async (req, res) => {
    try {
      const id = Number(req.body?.transfer_id);
      await approveAccounting(id);
      res.json({ ok:true });
    } catch (e:any) { res.status(400).json({ ok:false, error: e?.message }); }
  });

  app.post("/api/owner-transfer/authorize", async (req, res) => {
    if (!isAdmin(req)) return res.status(401).json({ ok:false, error:"unauthorized" });
    try {
      const id = Number(req.body?.transfer_id);
      await authorizeTransfer(id);
      res.json({ ok:true });
    } catch (e:any) { res.status(400).json({ ok:false, error: e?.message }); }
  });

  app.post("/api/owner-transfer/execute", async (req, res) => {
    if (!isAdmin(req)) return res.status(401).json({ ok:false, error:"unauthorized" });
    try {
      const id = Number(req.body?.transfer_id);
      const out = await executeTransfer(id);
      res.json({ ok:true, ...out });
    } catch (e:any) { res.status(400).json({ ok:false, error: e?.message }); }
  });

  app.get("/api/owner-transfer/:id", async (req, res) => {
    const id = Number(req.params.id);
    const { data, error } = await sbAdmin.from("owner_transfers").select("*").eq("id", id).single();
    if (error) return res.status(404).json({ ok:false, error:error.message });
    res.json({ ok:true, transfer: data });
  });
}
TS

# ---------- SERVER: install the new routes & scheduler ----------
node <<'NODE'
const fs = require('fs');
const p = 'server/index.ts';
if (!fs.existsSync(p)) {
  console.log('WARN: server/index.ts not found; skipped patch.');
  process.exit(0);
}
let s = fs.readFileSync(p,'utf8');
if (!s.includes('installOwnerTransferRoutes')) {
  s = 'import { installOwnerTransferRoutes } from "./routes/ownerTransfer";\n' + s;
}
if (!s.includes('runDueTransfersTick')) {
  s = 'import { runDueTransfersTick } from "./lib/ownerTransfer";\n' + s;
}
if (s.includes('const app = express();') && !s.includes('installOwnerTransferRoutes(app)')) {
  s = s.replace('const app = express();', m => m + '\n  installOwnerTransferRoutes(app);\n');
}
if (!s.includes('setInterval(() => runDueTransfersTick()')) {
  s += '\n// owner transfer tiny scheduler (5 min)\nsetInterval(() => runDueTransfersTick().catch(()=>{}), 5*60*1000);\n';
}
fs.writeFileSync(p, s);
console.log('Patched server/index.ts');
NODE

# ---------- FRONTEND: sleek transfer page (stepper + live search) ----------
cat > src/features/owners/pages/OwnerTransferPage.tsx <<'TSX'
import React, { useEffect, useMemo, useState } from "react";
import { useLocation } from "wouter";

type OwnerLite = { id:number; display_name:string; meta?:string|null };
type PropertyLite = { id:number; name:string; address1?:string|null; city?:string|null; state?:string|null; zip?:string|null };

async function jget<T=any>(u:string) { const r=await fetch(u); if(!r.ok) throw new Error(await r.text()); return r.json() as Promise<T>; }
async function jpost<T=any>(u:string, b:any) { const r=await fetch(u,{method:"POST",headers:{'Content-Type':'application/json'},body:JSON.stringify(b)}); if(!r.ok) throw new Error(await r.text()); return r.json() as Promise<T>; }

export default function OwnerTransferPage(){
  const [, nav] = useLocation();
  const [ownerId, setOwnerId] = useState<number|undefined>(undefined);
  const [ownerProps, setOwnerProps] = useState<PropertyLite[]>([]);
  const [search, setSearch] = useState("");
  const [candidates, setCandidates] = useState<OwnerLite[]>([]);
  const [newOwnerId, setNewOwnerId] = useState<number|undefined>(undefined);
  const [selected, setSelected] = useState<number[]>([]);
  const [effDate, setEffDate] = useState<string>(() => new Date().toISOString().slice(0,10));
  const [notes, setNotes] = useState("");
  const [step, setStep] = useState<1|2|3|4>(1);
  const [busy, setBusy] = useState(false);
  const [msg, setMsg] = useState<string>("");

  // ownerId from ?ownerId=
  useEffect(()=> {
    const url = new URL(window.location.href);
    const id = Number(url.searchParams.get("ownerId") || "0");
    if (id) setOwnerId(id);
  },[]);

  // load properties for current owner
  useEffect(()=> {
    if (!ownerId) return;
    jget<{properties:PropertyLite[]}>(`/api/owners/${ownerId}/properties`)
      .then(({properties})=>{
        setOwnerProps(properties||[]);
        setSelected(properties.map(p=>p.id)); // preselect all (can unselect)
      }).catch(()=>{});
  },[ownerId]);

  // debounce search for new owner
  useEffect(()=> {
    const t = setTimeout(()=>{
      if (!search.trim()) { setCandidates([]); return; }
      jget<{owners:OwnerLite[]}>(`/api/owners/search?q=${encodeURIComponent(search.trim())}`)
        .then(({owners})=>setCandidates(owners||[])).catch(()=>{});
    }, 150);
    return ()=>clearTimeout(t);
  },[search]);

  const canNext1 = !!newOwnerId && selected.length>0 && !!ownerId;
  const humanSummary = useMemo(()=> {
    const count = selected.length;
    const timing = (()=> {
      const today = new Date(); today.setHours(0,0,0,0);
      const eff = new Date(effDate); eff.setHours(0,0,0,0);
      if (eff.getTime() < today.getTime()) return "Retro transfer (past date)";
      if (eff.getTime() > today.getTime()) return "Scheduled transfer (future date)";
      return "Effective today";
    })();
    return `${count} property${count===1?"":"ies"} • ${timing}`;
  },[selected, effDate]);

  function toggle(id:number) {
    setSelected(prev => prev.includes(id) ? prev.filter(x=>x!==id) : [...prev, id]);
  }

  async function onCreate(){
    if (!ownerId || !newOwnerId || !selected.length) return;
    setBusy(true); setMsg("");
    try{
      const out = await jpost("/api/owner-transfer/initiate", {
        old_owner_id: ownerId,
        new_owner_id: newOwnerId,
        property_ids: selected,
        effective_date: effDate,
        notes
      });
      setStep(4);
      setMsg(`Transfer #${out.transfer_id} created • Status: ${out.status}`);
    }catch(e:any){
      setMsg(e?.message || "Failed to create transfer");
    }finally{ setBusy(false); }
  }

  return (
    <div className="p-6 max-w-5xl mx-auto">
      <div className="bg-[var(--panel-elev)] rounded-2xl border border-[var(--line)] p-5 shadow-xl">
        <div className="flex items-center justify-between">
          <h2 className="text-xl font-semibold">Transfer Property Ownership</h2>
          <button className="btn" onClick={()=>nav(`/card/owner/${ownerId||""}`)}>Close</button>
        </div>

        <div className="mt-4 text-[var(--text-dim)]">Step {step} of 3</div>

        {step===1 && (
          <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <div className="lbl">Select new owner</div>
              <input className="input" placeholder="Search company or person…" value={search} onChange={e=>setSearch(e.target.value)} />
              <div className="menu mt-2">
                {candidates.map(o=>(
                  <div key={o.id}
                    className={`menu-item ${o.id===newOwnerId?'active':''}`}
                    onClick={()=>setNewOwnerId(o.id)}>
                    <div className="font-medium">{o.display_name}</div>
                    {o.meta && <div className="text-xs muted">{o.meta}</div>}
                  </div>
                ))}
                {!candidates.length && <div className="menu-item muted">Type to search…</div>}
              </div>
            </div>

            <div>
              <div className="lbl">Selected properties ({selected.length})</div>
              <div className="list tall">
                <div className="row muted">
                  <label><input type="checkbox"
                    checked={selected.length===ownerProps.length && ownerProps.length>0}
                    onChange={e=> setSelected(e.target.checked ? ownerProps.map(p=>p.id) : [])} /> Select all</label>
                </div>
                {ownerProps.map(p=>(
                  <div className="row" key={p.id}>
                    <input type="checkbox" className="mr-2" checked={selected.includes(p.id)} onChange={()=>toggle(p.id)} />
                    <div>
                      <div className="font-medium">{p.name}</div>
                      <div className="text-xs muted">{[p.address1,p.city,p.state,p.zip].filter(Boolean).join(", ")}</div>
                    </div>
                  </div>
                ))}
                {!ownerProps.length && <div className="row muted">No properties for this owner.</div>}
              </div>
            </div>
          </div>
        )}

        {step===2 && (
          <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <div className="lbl">Effective date</div>
              <input className="input" type="date" value={effDate} onChange={e=>setEffDate(e.target.value)} />
              <div className="lbl mt-3">Notes</div>
              <textarea className="input" rows={6} value={notes} onChange={e=>setNotes(e.target.value)} placeholder="Optional notes…" />
            </div>
            <div>
              <div className="lbl">Summary</div>
              <div className="list">
                <div className="row">{humanSummary}</div>
                <div className="row muted">All transfers go through Accounting review, then Admin authorization. Execution runs automatically on/after the effective date.</div>
              </div>
            </div>
          </div>
        )}

        {step===3 && (
          <div className="mt-4">
            <div className="list">
              <div className="row"><span className="font-medium">Ready to create the transfer?</span></div>
              <div className="row muted">We will snapshot properties/units/leases/tenants now. Accounting will receive the record for review.</div>
            </div>
          </div>
        )}

        {step===4 && (
          <div className="mt-4">
            <div className="list">
              <div className="row font-medium">Result</div>
              <div className="row">{msg}</div>
            </div>
          </div>
        )}

        <div className="actions">
          {step>1 && step<4 && <button className="btn ghost" onClick={()=>setStep((s)=> (s-1) as any)}>Back</button>}
          {step===1 && <button disabled={!canNext1} className="btn gold" onClick={()=>setStep(2 as any)}>Next</button>}
          {step===2 && <button className="btn gold" onClick={()=>setStep(3 as any)}>Review</button>}
          {step===3 && <button className="btn gold" disabled={busy} onClick={onCreate}>{busy?'Creating…':'Create Transfer'}</button>}
          {step===4 && <button className="btn" onClick={()=>nav(`/card/owner/${ownerId}`)}>Done</button>}
        </div>
      </div>
    </div>
  );
}
TSX

# tiny css helpers (reuse tokens you already have)
cat > src/styles/owner-transfer.css <<'CSS'
.lbl{font-size:12px;color:var(--text-dim);margin-bottom:6px}
.input{width:100%;background:#101316;border:1px solid var(--line);border-radius:10px;padding:10px 12px;color:var(--text)}
.menu{border:1px solid var(--line);border-radius:10px;background:#0e1114;max-height:240px;overflow:auto}
.menu-item{padding:10px 12px;cursor:pointer}
.menu-item:hover,.menu-item.active{background:#14181d}
.list{border:1px solid var(--line);border-radius:10px;background:#0e1114;max-height:360px;overflow:auto;padding:6px}
.row{display:flex;gap:10px;align-items:flex-start;padding:8px 10px;border-bottom:1px solid rgba(255,255,255,.03)}
.row:last-child{border-bottom:0}
.actions{display:flex;justify-content:flex-end;gap:10px;margin-top:16px}
.btn{border-radius:999px;padding:10px 16px;border:1px solid var(--line);background:#11151a;color:var(--text)}
.btn.gold{background:var(--altus-gold);color:#000;border-color:transparent}
.btn.ghost{background:transparent}
.muted{color:var(--text-dim)}
CSS

# ---------- FRONTEND: wire route into App (Wouter) ----------
node <<'NODE'
const fs = require('fs');
const app = 'src/App.tsx';
if (!fs.existsSync(app)) { console.log('WARN: src/App.tsx not found; skip route patch.'); process.exit(0); }
let s = fs.readFileSync(app,'utf8');
if (!s.includes('OwnerTransferPage')) {
  s = "import OwnerTransferPage from './features/owners/pages/OwnerTransferPage';\n" + s;
}
if (s.includes('<Switch>') && !s.includes('path="/owners/transfer"')) {
  s = s.replace('<Switch>', '<Switch>\n        <Route path="/owners/transfer" component={OwnerTransferPage} />');
} else if (s.includes('</Switch>') && !s.includes('path="/owners/transfer"')) {
  s = s.replace('</Switch>', '        <Route path="/owners/transfer" component={OwnerTransferPage} />\n      </Switch>');
}
fs.writeFileSync(app, s);
console.log('Patched src/App.tsx (added /owners/transfer route).');
NODE

echo "✅ Files created & patched."
echo "▶ Rebuilding (ignore warnings)…"
npm run build >/dev/null 2>&1 || true
echo "Done. Visit /owners/transfer?ownerId=<ID> to use the new flow."

How to use it

Open: /owners/transfer?ownerId=2
(Replace 2 with the current owner you’re viewing. If you want, I can also patch the “Transfer Ownership” button on Owner Card to deep-link here.)

Step 1:

Live-search the new owner (company or person).

Pick one / many / all properties (Select-all toggle included).

Step 2:

Set the effective date (past, today, or future).

Add notes.

Step 3:

Review the summary (“Retro”, “Today”, or “Scheduled”).

Create the transfer.

The backend:

snapshots properties/units/leases/tenants,

sets status PENDING_ACCOUNTING (per your policy),

logs an audit.

Accounting & Admin (unchanged from spec):

POST /api/owner-transfer/approve-accounting with {transfer_id}

Admin (Bearer ADMIN_SYNC_TOKEN) POST /api/owner-transfer/authorize

After authorization, the tiny scheduler executes automatically on/after the effective date (or POST /api/owner-transfer/execute to force it).

Date logic (retro vs scheduled)

Past date → It’s a retro transfer. We still go through Accounting; Admin authorizes; it executes immediately after authorization.

Future date → It’s scheduled. After Accounting + Admin, the scheduler executes when that date arrives (UTC, daily ticks every 5 minutes).

Map fix (coords)

Keep the env you already set:

GOOGLE_MAPS_API_KEY

GEOCODER_PROVIDER=google (default is fine)

ADMIN_SYNC_TOKEN=<your token> (already in your vault)

Then run a backfill (secure):

curl -X POST "https://<your-app>/api/admin/geocode/backfill?token=YOUR_ADMIN_SYNC_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{}'


Recheck /api/admin/geocode/status and refresh the dashboard; the map renders as soon as rows have lat/lng.

Why this is better

Sleek stepper with clear summary and “select all” convenience.

Live search on owners with dual naming (company + human names).

Workflows respected (Accounting → Admin → Execute).

Backdated and future-dated transfers are handled cleanly.

Tiny scheduler avoids manual midnight runs and protects you from “forgot to execute”.