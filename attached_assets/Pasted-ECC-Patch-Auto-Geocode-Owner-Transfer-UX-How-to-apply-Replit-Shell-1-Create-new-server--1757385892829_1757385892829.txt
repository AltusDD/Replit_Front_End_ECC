ECC Patch — Auto-Geocode + Owner Transfer UX

How to apply (Replit Shell):

# 1) Create new server + frontend files and wire intervals
git checkout -b feat/auto-geocode-owner-transfer-ux

# --- SERVER: helpers, routes, ticks ---
mkdir -p server/lib/geocode server/jobs
cat > server/lib/geocode/geocode.ts <<'TS'
import fetch from "node-fetch";
import crypto from "crypto";
import { sbAdmin } from "../supabaseAdmin";
import { recordAudit } from "../audit";
const PROVIDER = process.env.GEOCODER_PROVIDER || "google";
const API_KEY = process.env.GOOGLE_MAPS_API_KEY || "";

function norm(s: string) {
  return s.trim().replace(/\s+/g, " ").toUpperCase();
}
function addrKey(addr: { line1?: string; line2?: string; city?: string; state?: string; postal_code?: string }) {
  const base = [addr.line1, addr.line2, addr.city, addr.state, addr.postal_code].filter(Boolean).map(norm).join(", ");
  return crypto.createHash("sha256").update(base).digest("hex");
}

async function getFromCache(hash: string) {
  const { data, error } = await sbAdmin
    .from("geocode_cache")
    .select("lat,lng,normalized")
    .eq("address_hash", hash)
    .maybeSingle();
  if (error) throw error;
  return data || null;
}
async function putInCache(hash: string, normalized: string, lat: number, lng: number) {
  const { error } = await sbAdmin.from("geocode_cache").upsert({ address_hash: hash, normalized, lat, lng });
  if (error) throw error;
}

async function googleGeocode(q: string): Promise<{ lat: number; lng: number; normalized: string } | null> {
  if (!API_KEY) return null;
  const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(q)}&key=${API_KEY}`;
  const res = await fetch(url);
  if (!res.ok) return null;
  const j = await res.json();
  const hit = j?.results?.[0];
  if (!hit) return null;
  const lat = hit.geometry?.location?.lat;
  const lng = hit.geometry?.location?.lng;
  const normalized = hit.formatted_address || q;
  if (typeof lat !== "number" || typeof lng !== "number") return null;
  return { lat, lng, normalized };
}

// very light 2 rps governor
let last = 0;
async function throttle() {
  const now = Date.now();
  const delta = now - last;
  const minGap = 500; // ms => 2 req/sec
  if (delta < minGap) await new Promise(r => setTimeout(r, minGap - delta));
  last = Date.now();
}

export type Address = { line1?: string; line2?: string; city?: string; state?: string; postal_code?: string };

export async function geocodeAddress(addr: Address): Promise<{ lat: number; lng: number } | null> {
  const parts = [addr.line1, addr.line2, addr.city, addr.state, addr.postal_code].filter(Boolean);
  if (!parts.length) return null;
  const query = parts.join(", ");
  const hash = addrKey(addr);

  // cache
  const cached = await getFromCache(hash);
  if (cached) return { lat: cached.lat, lng: cached.lng };

  await throttle();
  let result: { lat: number; lng: number; normalized: string } | null = null;
  if (PROVIDER === "google") result = await googleGeocode(query);

  if (result) {
    await putInCache(hash, result.normalized, result.lat, result.lng);
    await recordAudit({
      event_type: "GEOCODE_AUTO",
      label: "GEOCODE_AUTO",
      ref_table: "properties",
      payload: { provider: PROVIDER, query, normalized: result.normalized }
    });
    return { lat: result.lat, lng: result.lng };
  }
  return null;
}
TS

cat > server/jobs/autoGeocodeTick.ts <<'TS'
import { sbAdmin } from "../lib/supabaseAdmin";
import { geocodeAddress } from "../lib/geocode/geocode";
import { recordAudit } from "../lib/audit";

const BATCH = parseInt(process.env.GEOCODE_TICK_BATCH || "10", 10);

export async function runAutoGeocodeTick() {
  // grab N properties missing coords with plausible address parts
  const { data: props, error } = await sbAdmin
    .from("properties")
    .select("id,line1,line2,city,state,postal_code,lat,lng")
    .or("lat.is.null,lng.is.null")
    .limit(BATCH);

  if (error || !props?.length) return;

  for (const p of props) {
    try {
      const result = await geocodeAddress({
        line1: p.line1, line2: p.line2, city: p.city, state: p.state, postal_code: p.postal_code
      });
      if (result) {
        const { error: upErr } = await sbAdmin
          .from("properties")
          .update({ lat: result.lat, lng: result.lng })
          .eq("id", p.id);
        if (!upErr) {
          await recordAudit({ event_type: "GEOCODE_AUTO_APPLY", label: "GEOCODE_AUTO", ref_table: "properties", ref_id: p.id, payload: { lat: result.lat, lng: result.lng } });
        }
      }
    } catch { /* swallow batch errors */ }
  }
}
TS

# --- SERVER: audit util (if you don't already have one with this signature) ---
mkdir -p server/lib
cat > server/lib/audit.ts <<'TS'
import { sbAdmin } from "./supabaseAdmin";
type Audit = {
  event_type: string;
  label?: string;
  ref_table?: string;
  ref_id?: number | string | null;
  payload?: any;
};
export async function recordAudit(a: Audit) {
  await sbAdmin.from("audit_events").insert({
    event_type: a.event_type,
    label: a.label || null,
    ref_table: a.ref_table || null,
    ref_id: a.ref_id ?? null,
    payload: a.payload ?? null
  });
}
TS

# --- SERVER: wire geocode into property sync (enqueue while syncing) ---
applypatch <<'PATCH'
*** Begin Patch
*** Update File: server/lib/sync/properties.ts
@@
 import { sbAdmin } from "../../supabaseAdmin";
+import { geocodeAddress } from "../../geocode/geocode";
+import { recordAudit } from "../../audit";
@@
-  // ...existing property upsert logic...
+  // ...existing property upsert logic...
+  // After upsert, if missing coords but has address, attempt geocode (non-blocking best effort)
+  try {
+    const needsCoords = !mapped.lat && !mapped.lng;
+    const hasAddr = !!(mapped.line1 || mapped.city || mapped.postal_code);
+    if (needsCoords && hasAddr) {
+      const geo = await geocodeAddress({
+        line1: mapped.line1, line2: mapped.line2,
+        city: mapped.city, state: mapped.state, postal_code: mapped.postal_code
+      });
+      if (geo) {
+        await sbAdmin.from("properties").update({ lat: geo.lat, lng: geo.lng }).eq("id", upsertedId);
+        await recordAudit({ event_type: "GEOCODE_AUTO_APPLY", label: "GEOCODE_AUTO", ref_table: "properties", ref_id: upsertedId, payload: geo });
+      }
+    }
+  } catch {}
*** End Patch
PATCH

# --- SERVER: add background geocode tick to index.ts (next to runDueTransfersTick) ---
applypatch <<'PATCH'
*** Begin Patch
*** Update File: server/index.ts
@@
 import { runDueTransfersTick } from "./lib/ownerTransfer";
+import { runAutoGeocodeTick } from "./jobs/autoGeocodeTick";
@@
 setInterval(() => runDueTransfersTick(), 5*60*1000);
+if ((process.env.AUTO_SYNC_ENABLED || "true") === "true") {
+  // small, continuous geocode trickle
+  setInterval(() => runAutoGeocodeTick(), 60*1000);
+}
*** End Patch
PATCH

# --- DB: geocode cache table (idempotent) ---
cat > db/migrations/20250908_geocode_cache.sql <<'SQL'
create table if not exists public.geocode_cache (
  address_hash text primary key,
  normalized   text,
  lat          double precision not null,
  lng          double precision not null,
  updated_at   timestamptz default now()
);
create index if not exists geocode_cache_updated_at on public.geocode_cache(updated_at desc);
SQL

# --- FRONTEND: Owner Card → deep link to Transfer ---
# (adjust path if your OwnerCard lives elsewhere)
mkdir -p src/features/owners/components
applypatch <<'PATCH'
*** Begin Patch
*** Update File: src/features/owners/components/OwnerCard.tsx
@@
 import { Link } from "wouter";
@@
-  {/* existing owner summary UI */}
+  {/* existing owner summary UI */}
+  <div className="mt-4 flex gap-2">
+    <Link href={`/owners/transfer?ownerId=${owner.id}`}>
+      <a className="btn btn-primary">Transfer Ownership</a>
+    </Link>
+  </div>
*** End Patch
PATCH

# --- FRONTEND: Transfer Detail admin buttons ---
# Minimal page that reads transfer id and hits APIs; dark-theme buttons
mkdir -p src/features/owners/pages
cat > src/features/owners/pages/OwnerTransferDetailPage.tsx <<'TSX'
import React, { useEffect, useState } from "react";
import { useLocation } from "wouter";

type Transfer = { id: number; status: string; effective_date: string; old_owner_id: number; new_owner_id: number; property_ids: number[] };

async function api(path: string, opts: RequestInit = {}) {
  const headers: any = { "Content-Type": "application/json", ...(opts.headers || {}) };
  // optional admin token pattern (same as AdminSyncPage)
  const token = localStorage.getItem("ADMIN_SYNC_TOKEN");
  if (token && /authorize|execute/.test(path)) headers["Authorization"] = `Bearer ${token}`;
  const res = await fetch(path, { ...opts, headers });
  if (!res.ok) throw new Error(await res.text());
  return res.json().catch(() => ({}));
}

export default function OwnerTransferDetailPage() {
  const [loc] = useLocation();
  const params = new URLSearchParams(loc.split("?")[1] || "");
  const id = params.get("id");
  const [t, setT] = useState<Transfer | null>(null);
  const [busy, setBusy] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  async function load() {
    setErr(null);
    try { const j = await api(`/api/owner-transfer/${id}`); setT(j); } catch (e:any){ setErr(e.message); }
  }
  useEffect(() => { if (id) load(); }, [id]);

  async function doPost(endpoint: string) {
    setBusy(true); setErr(null);
    try { await api(endpoint, { method: "POST", body: JSON.stringify({ transfer_id: Number(id) }) }); await load(); }
    catch (e:any){ setErr(e.message) } finally { setBusy(false); }
  }

  if (!id) return <div className="p-6 text-red-400">Missing transfer id</div>;
  return (
    <div className="p-6 text-neutral-200">
      <div className="card bg-neutral-900 border border-neutral-800">
        <div className="card-header px-4 py-3 border-b border-neutral-800">
          <h2 className="text-lg font-semibold">Owner Transfer: #{id}</h2>
          {err && <div className="mt-2 text-sm text-red-400">{err}</div>}
        </div>
        <div className="card-content p-4 space-y-3">
          {!t ? <div>Loading…</div> : (
            <>
              <div className="grid grid-cols-2 gap-3 text-sm">
                <div><span className="text-neutral-400">Status:</span> {t.status}</div>
                <div><span className="text-neutral-400">Effective:</span> {t.effective_date}</div>
                <div><span className="text-neutral-400">Old Owner:</span> {t.old_owner_id}</div>
                <div><span className="text-neutral-400">New Owner:</span> {t.new_owner_id}</div>
                <div className="col-span-2"><span className="text-neutral-400">Properties:</span> {t.property_ids?.join(", ")}</div>
              </div>
              <div className="pt-3 flex flex-wrap gap-2">
                <button disabled={busy} onClick={() => doPost("/api/owner-transfer/approve-accounting")} className="btn btn-secondary">Approve Accounting</button>
                <button disabled={busy} onClick={() => doPost("/api/owner-transfer/authorize")} className="btn btn-warning">Authorize</button>
                <button disabled={busy} onClick={() => doPost("/api/owner-transfer/execute")} className="btn btn-primary">Execute Now</button>
              </div>
              <p className="text-xs text-neutral-500 pt-2">Note: “Authorize” and “Execute Now” require an admin token. Set <code>ADMIN_SYNC_TOKEN</code> into <code>localStorage</code> if prompted.</p>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
TSX

# --- FRONTEND: route (add detail page + ensure transfer entry exists) ---
applypatch <<'PATCH'
*** Begin Patch
*** Update File: src/routes.tsx
@@
-  { path: "/owners/transfer", component: OwnerTransferPage },
+  { path: "/owners/transfer", component: OwnerTransferPage },
+  { path: "/owners/transfer/detail", component: OwnerTransferDetailPage },
*** End Patch
PATCH

# import for new page in routes (if your routes file lists imports)
applypatch <<'PATCH'
*** Begin Patch
*** Update File: src/routes.tsx
@@
 import OwnerTransferPage from "./features/owners/pages/OwnerTransferPage";
+import OwnerTransferDetailPage from "./features/owners/pages/OwnerTransferDetailPage";
*** End Patch
PATCH

# 2) Run DB migration (if you apply SQL via script, otherwise paste in Supabase)
echo "Remember to apply db/migrations/20250908_geocode_cache.sql in Supabase."

git add -A
git commit -m "Auto-geocode (sync+tick+cache+audits) + OwnerCard deep link + Transfer Detail admin buttons"

✅ What this adds
1) Auto-Geocode

During property sync: if lat/lng are missing and an address exists, we geocode and persist immediately.

Background trickle: a 60-second tick processes up to GEOCODE_TICK_BATCH (default 10) remaining properties.

Rate-limited: ~2 req/sec (500 ms gap).

Caching: new geocode_cache(address_hash, normalized, lat, lng) prevents duplicate API hits.

Audits: writes GEOCODE_AUTO + GEOCODE_AUTO_APPLY.

Env already in your handbook; nothing new required. (Uses GEOCODER_PROVIDER=google + GOOGLE_MAPS_API_KEY.)

2) Owner Card → Transfer Deep Link

Button on Owner Card links to /owners/transfer?ownerId=<id> (your stepper page).

3) Transfer Detail Admin Buttons

New page at /owners/transfer/detail?id=<transferId>.

Buttons: Approve Accounting, Authorize, Execute Now.

Authorize/Execute send Authorization: Bearer {ADMIN_SYNC_TOKEN} if you’ve set it in localStorage.ADMIN_SYNC_TOKEN (same pattern as Admin Sync page).

All buttons keep your dark theme by reusing btn classes (primary / secondary / warning). No new CSS introduced.

🔍 Smoke-test (2 minutes)

SQL: run db/migrations/20250908_geocode_cache.sql in Supabase.

Sync: visit /admin/sync, run incremental for owners + properties.

Map: after ~a minute, coordinates begin filling; reload Dashboard → pins appear.

Owner Card: open any owner → click Transfer Ownership → confirm it lands on the stepper with ownerId populated.

Transfer flow: create a transfer, then open /owners/transfer/detail?id=…:

Click Approve Accounting → status should advance.

Set localStorage.ADMIN_SYNC_TOKEN to your token (DevTools) → Authorize → Execute Now (or let scheduler run due transfers).

Notes & guardrails

The server interval for geocoding is gated behind AUTO_SYNC_ENABLED=true (same on/off switch as your sync).

The geocode call is best-effort and won’t block sync runs.

If you already have an audit.ts helper with a different signature, keep yours; the insert payload here is minimal and won’t conflict.

No new npm deps added; node-fetch is assumed present (if not, npm i node-fetch@2 or adapt to native fetch on your runtime).