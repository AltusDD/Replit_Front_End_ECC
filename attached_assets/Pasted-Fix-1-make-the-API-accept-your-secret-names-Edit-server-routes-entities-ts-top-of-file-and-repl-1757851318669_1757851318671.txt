Fix 1 — make the API accept your secret names

Edit server/routes/entities.ts (top of file) and replace the client init with this:

import { Router } from "express";
import { createClient } from "@supabase/supabase-js";

const r = Router();

const SUPABASE_URL =
  process.env.SUPABASE_URL ??
  process.env.VITE_SUPABASE_URL ?? "";

const SUPABASE_KEY =
  process.env.SUPABASE_SERVICE_ROLE_KEY ??   // <-- your secret name
  process.env.SUPABASE_SERVICE_KEY ??        // common variant
  process.env.SUPABASE_KEY ??                // sometimes used
  process.env.SUPABASE_ANON_KEY ??           // read-only fallback
  process.env.VITE_SUPABASE_ANON_KEY ??      // read-only fallback
  "";

if (!SUPABASE_URL || !SUPABASE_KEY) {
  console.warn(
    "[ECC/API] Missing SUPABASE_URL or key; starting in read-only if anon key present."
  );
}

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY, {
  auth: { persistSession: false },
});


Optional (helps diagnose without leaking values):

console.log("[ECC/API] Supabase envs → url:", !!SUPABASE_URL,
            " serviceRole:", !!process.env.SUPABASE_SERVICE_ROLE_KEY,
            " service:", !!process.env.SUPABASE_SERVICE_KEY,
            " anon:", !!process.env.SUPABASE_ANON_KEY);


Then run: npm run dev.

This should clear the “supabaseKey is required” crash while still preferring your service-role key when present.

Fix 2 — unblock data to cards (quick server tweaks)

Even with the server up, two small API contract issues are why cards look empty:

Wrapper shape — our /api/entities/* returns { ok, item } but the client expects raw JSON.

Filtering — cards need simple ?field=eq.value filters.

Apply these tiny changes to server/routes/entities.ts:

Single by id should return the row directly (not wrapped).

Collection should parse ?field=eq.value (and optional limit).

Pseudo (keep your current router, just adjust outputs):

// GET /api/entities/:table/:id
r.get("/:table/:id", async (req, res) => {
  const { table, id } = req.params;
  const { data, error } = await supabase.from(table).select("*").eq("id", id).single();
  if (error) return res.status(500).json({ error: error.message });
  return res.json(data); // <-- raw object
});

// GET /api/entities/:table?field=eq.value&limit=5
r.get("/:table", async (req, res) => {
  const { table } = req.params;
  const q = supabase.from(table).select("*");
  for (const [k, v] of Object.entries(req.query)) {
    if (k === "limit") continue;
    const [op, val] = String(v).split("=");
    if (op === "eq") q.eq(k, val);
  }
  if (req.query.limit) q.limit(Number(req.query.limit));
  const { data, error } = await q;
  if (error) return res.status(500).json({ error: error.message });
  return res.json(data); // <-- raw array
});


With that in place you can immediately verify:

GET /api/entities/properties/42 → object (no {item} wrapper)

GET /api/entities/leases?property_id=eq.42&limit=5 → array

…and the card hooks that fall back to /api/entities/* will hydrate instead of rendering dashes.

Why portfolio tables already worked

Those pages are hitting different data paths (your Azure Functions or a resolver that already handled the shapes), so they weren’t impacted by the /api/entities contract mismatch. The cards, however, try RPC first, then fall back to /api/entities — where they were tripping over the wrapper + missing filter support.

Short next steps (after the server boots)

Start: npm run dev.

Hit the two test URLs above to confirm shapes.

Open:

/card/property/42

/card/unit/45

/card/lease/1

/card/tenant/1

/card/owner/1

If any relation still appears empty, I’ll hand you the minimal /api/rpc/get_*_card endpoints next so each card loads in a single call (and we can remove the extra fetches).