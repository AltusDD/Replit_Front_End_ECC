What to do next (surgical + deterministic)
1) Keep StrictMode behavior sane (dev = quiet, prod = strict)

In src/main.tsx set a mode switch so local dev doesn’t double-mount, but prod remains strict:

// src/main.tsx
import React from "react";
const Mode: React.ComponentType<any> =
  import.meta.env.DEV ? React.Fragment : React.StrictMode;

root.render(
  <Mode>
    <EccErrorBoundary>
      {/* ...existing providers/router/app... */}
    </EccErrorBoundary>
  </Mode>
);

2) Make React Query globally ignore benign cancels

In your QueryClient bootstrap (where you create the client), add:

// src/lib/queryClient.ts (or wherever you instantiate QueryClient)
import { QueryClient } from "@tanstack/react-query";
import { isAbortError } from "@/lib/http";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30_000,
      gcTime: 5 * 60_000,
      retry: 1,
      // don’t treat aborted fetches as “errors”
      throwOnError: (err) => !isAbortError(err),
    },
  },
});


(Then ensure queryClient is the one used in main.tsx.)

3) Ensure all fetches use the cancel-safe helper

You already patched card resolvers. Do a quick repo pass for stragglers:

src/**/*.(ts|tsx) – replace any direct fetch(/api/...` with:

import { fetchJSON } from "@/lib/http";
// …then
queryFn: ({ signal }) => fetchJSON(url, { signal })


Common spots: portfolio tables, dashboards, finance/legal/files tabs.

4) Keep Vite happy for Replit

Make sure the host allowlist fix is committed (it often reverts in forks):

// vite.config.ts / .js
export default defineConfig({
  server: {
    host: true,
    port: 5173,
    allowedHosts: true // or the specific worf subdomain if you prefer
  },
  // …existing config…
});

5) Smoke-test the 5 cards (fast)

/portfolio/properties → table renders

/card/property/52 (or any valid) → KPIs show; no contract errors

/card/unit/<id> → hero loads (no “Missing required field: unit”)

/card/lease/<id> → hero loads

/card/tenant/<id> and /card/owner/<id> → hero loads

If you get a real contract error (not an AbortError), it’ll render in the boundary with the exact missing field. That’s expected and useful.

Copy-paste prompt for Replit (do this verbatim)

Task: ECC Post-Boot Hardening & Noise Cleanup

In src/main.tsx, set Mode = import.meta.env.DEV ? React.Fragment : React.StrictMode and wrap the app with <Mode> (leave everything else as is).

In our QueryClient bootstrap, add throwOnError: (err) => !isAbortError(err) under defaultOptions.queries, and export that client for use in main.tsx.

Grep the repo for any remaining direct fetch("/api/ calls in src/. For each:

import { fetchJSON } from @/lib/http

change queryFn: () => fetch(url) to queryFn: ({signal}) => fetchJSON(url, {signal})

Confirm vite.config has server.allowedHosts: true, server.host: true, server.port: 5173. Save.

Run app. Visit:

/portfolio/properties

/card/property/52

/card/unit/45

/card/lease/21

/card/tenant/3 and /card/owner/11
Report any contract violation messages exactly as shown (don’t mask).

Do not re-enable dev StrictMode yet. We’ll toggle it back once the console shows zero non-contract errors.