set -e
mkdir -p src/components src/styles src/utils src/pages/portfolio/{properties,units,leases,tenants,owners}

############################################
# utils: format helpers (money, percent, date)
############################################
cat > src/utils/format.ts <<'TS'
export const money = (v: any) => {
  if (typeof v === "number") return v.toLocaleString(undefined, { style: "currency", currency: "USD" });
  if (typeof v === "string" && v.trim() !== "" && !isNaN(Number(v))) {
    return Number(v).toLocaleString(undefined, { style: "currency", currency: "USD" });
  }
  return "—";
};
export const percent = (v: any, digits = 1) => {
  const n = typeof v === "number" ? v : Number(v);
  return isFinite(n) ? `${n.toFixed(digits)}%` : "—";
};
export const shortDate = (v: any) => {
  if (!v) return "—";
  const d = new Date(v);
  return isNaN(+d) ? "—" : d.toISOString().slice(0,10);
};
export const boolText = (v: any) => (v ? "true" : "false");
TS

############################################
# utils: dict helpers + csv exporter
############################################
cat > src/utils/dict.ts <<'TS'
export function indexBy<T extends Record<string, any>>(rows: T[], key: keyof T) {
  const m = new Map<any, T>();
  for (const r of rows || []) m.set(r?.[key], r);
  return m;
}
export function groupBy<T extends Record<string, any>>(rows: T[], key: keyof T) {
  const m = new Map<any, T[]>();
  for (const r of rows || []) {
    const k = r?.[key];
    if (!m.has(k)) m.set(k, []);
    m.get(k)!.push(r);
  }
  return m;
}
TS

cat > src/utils/csv.ts <<'TS'
export function toCSV<T extends Record<string, any>>(rows: T[], columns: { key: string; header: string }[]) {
  const header = columns.map(c => safe(c.header)).join(",");
  const body = rows.map(r => columns.map(c => safe(r?.[c.key])).join(",")).join("\n");
  return header + "\n" + body;
}
function safe(v: any) {
  if (v == null) return "";
  const s = String(v).replace(/"/g, '""');
  return /[",\n]/.test(s) ? `"${s}"` : s;
}
export function downloadCSV(filename: string, csv: string) {
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click();
  a.remove(); URL.revokeObjectURL(url);
}
TS

############################################
# components: KPI Bar (Genesis-style compact tiles)
############################################
cat > src/components/KPIBar.tsx <<'TSX'
import React from "react";
import "@/styles/table.css";

export type KPI = { label: string; value: React.ReactNode; sub?: string; tone?: "ok"|"warn"|"bad"|"muted" };
export default function KPIBar({ items }: { items: KPI[] }) {
  return (
    <div className="kpi-bar">
      {items.map((k, i) => (
        <div key={i} className={`kpi ${k.tone ?? ""}`}>
          <div className="kpi-value">{k.value}</div>
          <div className="kpi-label">{k.label}{k.sub ? <span className="kpi-sub"> · {k.sub}</span> : null}</div>
        </div>
      ))}
    </div>
  );
}
TSX

############################################
# components: DataTable v2 (sort, search, paging, export, toolbarRight, maxRows cap)
############################################
cat > src/components/DataTable.tsx <<'TSX'
import React, { useMemo, useState } from "react";
import "@/styles/table.css";
import { toCSV, downloadCSV } from "@/utils/csv";

type Align = "left" | "right" | "center";
export type Col<T> = {
  key: keyof T & string;
  header: string;
  align?: Align;
  width?: number | string;
  render?: (row: T) => React.ReactNode;
};

export function DataTable<T extends Record<string, any>>({
  title,
  columns,
  rows,
  loading,
  error,
  emptyText = "No data",
  searchKeys,
  defaultPageSize = 50,
  pageSizeOptions = [25,50,100,200],
  rowKey,
  toolbarRight,
  enableExport = true,
  csvFileName = "export.csv",
  maxRows = 5000, // hard cap to keep UI snappy
}: {
  title?: string;
  columns: Col<T>[];
  rows: T[];
  loading?: boolean;
  error?: string | null;
  emptyText?: string;
  searchKeys?: (keyof T & string)[];
  defaultPageSize?: number;
  pageSizeOptions?: number[];
  rowKey?: (row: T, index: number) => React.Key;
  toolbarRight?: React.ReactNode;
  enableExport?: boolean;
  csvFileName?: string;
  maxRows?: number;
}) {
  const [query, setQuery] = useState("");
  const [sortKey, setSortKey] = useState<string | null>(null);
  const [sortDir, setSortDir] = useState<"asc" | "desc">("asc");
  const [page, setPage] = useState(0);
  const [pageSize, setPageSize] = useState(defaultPageSize);

  const keys = searchKeys || (columns.map(c => c.key) as (keyof T & string)[]);
  const capped = useMemo(() => rows.slice(0, maxRows), [rows, maxRows]);

  const filtered = useMemo(() => {
    if (!query.trim()) return capped;
    const q = query.toLowerCase();
    return capped.filter(r => keys.some(k => (r?.[k] ?? "").toString().toLowerCase().includes(q)));
  }, [capped, query, keys]);

  const sorted = useMemo(() => {
    if (!sortKey) return filtered;
    const copy = filtered.slice();
    copy.sort((a, b) => {
      const av = a?.[sortKey as keyof T]; const bv = b?.[sortKey as keyof T];
      const an = typeof av === "number" ? av : Number(av);
      const bn = typeof bv === "number" ? bv : Number(bv);
      if (isFinite(an) && isFinite(bn)) return sortDir === "asc" ? an - bn : bn - an;
      const as = (av ?? "").toString().toLowerCase();
      const bs = (bv ?? "").toString().toLowerCase();
      return sortDir === "asc" ? (as > bs ? 1 : as < bs ? -1 : 0) : (as < bs ? 1 : as > bs ? -1 : 0);
    });
    return copy;
  }, [filtered, sortKey, sortDir]);

  const pages = Math.max(1, Math.ceil(sorted.length / pageSize));
  const current = sorted.slice(page * pageSize, page * pageSize + pageSize);

  function onSort(k: string) {
    setPage(0);
    if (sortKey !== k) { setSortKey(k); setSortDir("asc"); }
    else { setSortDir(sortDir === "asc" ? "desc" : "asc"); }
  }
  function doExport() { downloadCSV(csvFileName, toCSV(sorted, columns.map(c => ({ key: c.key, header: c.header })))); }

  return (
    <div className="table-card">
      <div className="table-toolbar">
        <div className="table-title">
          {title ?? "Table"}
          <span className="muted"> {loading ? "Loading…" : `(${sorted.length})`}</span>
        </div>
        <div className="table-tools">
          {toolbarRight}
          <input className="table-search" placeholder="Search…" value={query}
            onChange={(e)=>{ setQuery(e.target.value); setPage(0); }} />
          <select className="table-select" value={pageSize} onChange={(e)=>{ setPageSize(Number(e.target.value)); setPage(0); }}>
            {pageSizeOptions.map(n => <option key={n} value={n}>{n}/page</option>)}
          </select>
          {enableExport && <button className="btn" onClick={doExport}>Export CSV</button>}
        </div>
      </div>

      {error && <div className="table-error">Error: {error}</div>}

      <div className="table-wrap">
        <table className="ecc-table">
          <thead>
            <tr>
              {columns.map((c) => (
                <th key={c.key} style={{ width: c.width, textAlign: c.align ?? "left" }}
                    onClick={() => onSort(c.key)} className={sortKey === c.key ? `sorted ${sortDir}` : undefined} role="button">
                  {c.header}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {loading && current.length === 0 && (
              <tr><td colSpan={columns.length} className="empty">Loading…</td></tr>
            )}
            {!loading && current.length === 0 && (
              <tr><td colSpan={columns.length} className="empty">{emptyText}</td></tr>
            )}
            {current.map((r, i) => (
              <tr key={rowKey ? rowKey(r, i) : i}>
                {columns.map((c) => (
                  <td key={c.key} style={{ textAlign: c.align ?? "left" }}>
                    {c.render ? c.render(r) : display(r[c.key])}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {pages > 1 && (
        <div className="table-pager">
          <button disabled={page === 0} onClick={() => setPage(0)}>&laquo;</button>
          <button disabled={page === 0} onClick={() => setPage(p => Math.max(0, p-1))}>&lsaquo;</button>
          <span>Page {page+1} / {pages}</span>
          <button disabled={page >= pages-1} onClick={() => setPage(p => Math.min(pages-1, p+1))}>&rsaquo;</button>
          <button disabled={page >= pages-1} onClick={() => setPage(pages-1)}>&raquo;</button>
        </div>
      )}
    </div>
  );
}
function display(v: any) {
  if (v == null || v === "") return "—";
  if (Array.isArray(v)) return v.join(", ");
  return String(v);
}
TSX

############################################
# styles: tokens, toolbar controls, KPI cards
############################################
cat > src/styles/table.css <<'CSS'
:root{
  --ink-1: var(--surface-1, #111214);
  --ink-2: var(--surface-2, #15161a);
  --ink-3: var(--surface-3, #1b1d22);
  --text-1: var(--fg-strong, #ffffff);
  --text-2: var(--fg-muted, #c7c9d1);
  --gold: var(--brand-gold, #f7c948);
  --ok: var(--accent-okay, #3fb950);
  --warn: var(--accent-warn, #f7c948);
  --bad: var(--accent-bad, #ff6a69);
}

.table-card { background: var(--ink-1); border: 1px solid var(--ink-3); border-radius: 14px; overflow: hidden; }
.table-toolbar { display:flex; align-items:center; justify-content:space-between; gap:8px;
  padding:12px 14px; border-bottom:1px solid var(--ink-3); background: var(--ink-2); flex-wrap:wrap; }
.table-title { color: var(--text-1); font-weight:700; letter-spacing:.2px; }
.table-title .muted { color: var(--text-2); font-weight:400; margin-left:6px; }
.table-tools { display:flex; gap:8px; align-items:center; margin-left:auto; flex-wrap:wrap; }
.table-search, .table-select, .btn, .flt-input, .flt-select, .flt-check {
  background: var(--ink-1); color: var(--text-1); border:1px solid var(--ink-3);
  border-radius:10px; padding:8px 10px;
}
.table-select { min-width: 110px; }
.btn { cursor:pointer; }
.table-error { color: var(--bad); padding:10px 14px; }
.table-wrap { max-width: 100%; overflow:auto; }
.ecc-table { width:100%; border-collapse:separate; border-spacing:0; color: var(--text-1); font-size:14px; }
.ecc-table thead th { position: sticky; top: 0; z-index: 1; background: var(--ink-2); color: var(--text-2);
  text-transform: uppercase; letter-spacing:.04em; font-weight:600; padding:10px 12px; border-bottom:1px solid var(--ink-3); white-space:nowrap; user-select:none; }
.ecc-table thead th.sorted.asc::after { content:" ▲"; color: var(--gold); }
.ecc-table thead th.sorted.desc::after { content:" ▼"; color: var(--gold); }
.ecc-table tbody td { padding:12px; border-bottom:1px solid var(--ink-3); }
.ecc-table tbody tr:nth-child(2n) { background: color-mix(in oklab, var(--ink-2) 90%, black); }
.ecc-table tbody tr:hover { background: color-mix(in oklab, var(--ink-2) 85%, var(--gold)); }
.ecc-table td.empty { text-align:center; color: var(--text-2); padding: 32px 12px; }
.table-pager { display:flex; align-items:center; gap:12px; padding:10px 14px; color: var(--text-2); }
.table-pager button { background: var(--ink-2); color: var(--text-1); border:1px solid var(--ink-3); border-radius:10px; padding:6px 10px; }
.badge { font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid var(--ink-3); background: var(--ink-2); color: var(--text-2); }
.badge.ok { color:#fff; background: color-mix(in oklab, var(--ok) 70%, black); }
.badge.warn { color:#000; background: var(--warn); }
.badge.bad { color:#fff; background: color-mix(in oklab, var(--bad) 70%, black); }
.mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
.right { text-align:right; }

.kpi-bar { display:grid; grid-template-columns: repeat(auto-fit,minmax(180px,1fr)); gap:10px; margin: 8px 0 12px; }
.kpi { background: var(--ink-2); border:1px solid var(--ink-3); border-radius:12px; padding:10px 12px; }
.kpi-value { color: var(--text-1); font-size:20px; font-weight:700; }
.kpi-label { color: var(--text-2); font-size:12px; text-transform:uppercase; letter-spacing:.04em; }
.kpi-sub { color: var(--text-2); font-weight:400; }
.kpi.ok .kpi-value { color: color-mix(in oklab, var(--ok) 80%, white); }
.kpi.warn .kpi-value { color: var(--warn); }
.kpi.bad .kpi-value { color: color-mix(in oklab, var(--bad) 80%, white); }
CSS

############################################
# columns (just keys/headers – unchanged)
############################################
cat > src/pages/portfolio/columns.ts <<'TS'
export const PROPERTY_COLUMNS = [
  { key: "name", header: "Property" },
  { key: "type", header: "Type" },
  { key: "class", header: "Class" },
  { key: "state", header: "State" },
  { key: "city", header: "City" },
  { key: "unit_count", header: "Units" },
  { key: "occupancy", header: "Occ%" },
  { key: "active", header: "Active" },
];
export const UNIT_COLUMNS = [
  { key: "property", header: "Property" },
  { key: "unit_number", header: "Unit" },
  { key: "beds", header: "Bd" },
  { key: "baths", header: "Ba" },
  { key: "sq_ft", header: "SqFt" },
  { key: "status", header: "Status" },
  { key: "market_rent", header: "Market Rent" },
];
export const LEASE_COLUMNS = [
  { key: "tenant_names", header: "Tenant(s)" },
  { key: "property", header: "Property" },
  { key: "rent", header: "Rent" },
  { key: "start", header: "Start" },
  { key: "end", header: "End" },
  { key: "status", header: "Status" },
];
export const TENANT_COLUMNS = [
  { key: "name", header: "Name" },
  { key: "property", header: "Property" },
  { key: "unit", header: "Unit" },
  { key: "email", header: "Email" },
  { key: "phone", header: "Phone" },
  { key: "status", header: "Status" },
  { key: "balance", header: "Balance" },
];
export const OWNER_COLUMNS = [
  { key: "name", header: "Owner" },
  { key: "email", header: "Email" },
  { key: "phone", header: "Phone" },
  { key: "property_count", header: "Props" },
  { key: "active", header: "Active" },
];
TS

############################################
# PROPERTIES — filters + KPIs + better occupancy
############################################
cat > src/pages/portfolio/properties/index.tsx <<'TSX'
import React, { useMemo, useState } from "react";
import { DataTable, Col } from "@/components/DataTable";
import KPIBar from "@/components/KPIBar";
import { PROPERTY_COLUMNS } from "../columns";
import { useCollection } from "@/features/data/useCollection";
import { groupBy } from "@/utils/dict";
import { percent } from "@/utils/format";

type Row = {
  id: any; doorloop_id?: any;
  name: string; type: string; class: string; state: string; city: string;
  unit_count: number; occupancy?: number; active: any;
};

export default function PropertiesPage() {
  const props = useCollection<any>("properties");
  const units = useCollection<any>("units");
  const leases = useCollection<any>("leases");

  const [stateF, setStateF] = useState<string>("ALL");
  const [activeF, setActiveF] = useState<"ALL"|"true"|"false">("ALL");

  const rawRows = useMemo<Row[]>(() => {
    const byPropUnits = groupBy(units.data, "property_id");
    const activeByUnit = new Set(
      (leases.data || []).filter(l => String(l?.status || "").toLowerCase() === "active").map(l => l.unit_id)
    );
    return (props.data || []).map((p: any) => {
      const u = byPropUnits.get(p.id) || [];
      const unit_count = p.unit_count ?? u.length ?? 0;
      const occUnitsStatus = u.filter((x:any) => String(x?.status||"").toLowerCase() === "occupied").length;
      const occUnitsLease = u.filter((x:any)=> activeByUnit.has(x.id)).length;
      const occUnits = Math.max(occUnitsStatus, occUnitsLease);
      const occPct = p.occupancy ?? p.occupancy_rate ?? (unit_count ? (occUnits / unit_count) * 100 : undefined);
      return {
        id: p.id ?? p.doorloop_id,
        doorloop_id: p.doorloop_id,
        name: p.name ?? "",
        type: p.type ?? p.category ?? "",
        class: p.class ?? p.asset_class ?? p.property_class ?? "",
        state: p.address_state ?? p.state ?? "",
        city: p.address_city ?? p.city ?? "",
        unit_count,
        occupancy: typeof occPct === "number" ? occPct : undefined,
        active: p.active ?? p.isActive ?? false,
      };
    });
  }, [props.data, units.data, leases.data]);

  const filtered = useMemo(() => {
    return rawRows.filter(r => {
      if (stateF !== "ALL" && r.state !== stateF) return false;
      if (activeF !== "ALL" && String(!!r.active) !== activeF) return false;
      return true;
    });
  }, [rawRows, stateF, activeF]);

  // KPIs
  const totals = useMemo(() => {
    const totalProps = filtered.length;
    const totalUnits = filtered.reduce((a,r)=> a + (r.unit_count || 0), 0);
    const occWeighted = filtered.reduce((a,r)=> a + ((r.occupancy ?? 0) * (r.unit_count || 0)), 0);
    const occ = totalUnits ? occWeighted / totalUnits : 0;
    const activeProps = filtered.filter(r => r.active).length;
    return { totalProps, totalUnits, occ, activeProps };
  }, [filtered]);

  const cols: Col<Row>[] = [
    { key: "name", header: "Property" },
    { key: "type", header: "Type" },
    { key: "class", header: "Class" },
    { key: "state", header: "State" },
    { key: "city", header: "City" },
    { key: "unit_count", header: "Units", align: "right", render: (r) => <span className="mono">{r.unit_count ?? "—"}</span> },
    { key: "occupancy", header: "Occ%", align: "right", render: (r) => <span className="mono">{r.occupancy == null ? "—" : percent(r.occupancy)}</span> },
    { key: "active", header: "Active", render: (r) => <span className={`badge ${r.active ? "ok" : "bad"}`}>{String(r.active)}</span> },
  ];

  const states = Array.from(new Set((rawRows || []).map(r => r.state).filter(Boolean))).sort();

  const filtersRight = (
    <>
      <select className="flt-select" value={stateF} onChange={(e)=>{ setStateF(e.target.value); }}>
        <option value="ALL">All States</option>
        {states.map(s => <option key={s} value={s}>{s}</option>)}
      </select>
      <select className="flt-select" value={activeF} onChange={(e)=>{ setActiveF(e.target.value as any); }}>
        <option value="ALL">All Status</option>
        <option value="true">Active</option>
        <option value="false">Inactive</option>
      </select>
    </>
  );

  return (
    <>
      <KPIBar items={[
        { label: "Properties", value: totals.totalProps },
        { label: "Units", value: totals.totalUnits },
        { label: "Occupancy", value: percent(totals.occ), tone: totals.occ >= 90 ? "ok" : totals.occ >= 80 ? "warn" : "bad" },
        { label: "Active Props", value: totals.activeProps },
      ]} />
      <DataTable
        title="Properties"
        columns={cols}
        rows={filtered}
        loading={props.loading}
        error={props.error ?? undefined}
        searchKeys={PROPERTY_COLUMNS.map(c => c.key as keyof Row & string)}
        defaultPageSize={50}
        pageSizeOptions={[25,50,100,200]}
        toolbarRight={filtersRight}
        csvFileName="properties.csv"
        rowKey={(r)=>r.id}
        emptyText="No properties"
      />
    </>
  );
}
TSX

############################################
# UNITS — filters + KPIs
############################################
cat > src/pages/portfolio/units/index.tsx <<'TSX'
import React, { useMemo, useState } from "react";
import { DataTable, Col } from "@/components/DataTable";
import KPIBar from "@/components/KPIBar";
import { UNIT_COLUMNS } from "../columns";
import { useCollection } from "@/features/data/useCollection";
import { indexBy } from "@/utils/dict";
import { money } from "@/utils/format";

type Row = {
  id:any; doorloop_id?:any; property:string; unit_number:string;
  beds:number|''; baths:number|''; sq_ft:number|''; status:string; market_rent:number|undefined;
};

export default function UnitsPage() {
  const units = useCollection<any>("units");
  const props = useCollection<any>("properties");

  const [statusF, setStatusF] = useState<"ALL"|"Occupied"|"Vacant"|"Other">("ALL");
  const [minBeds, setMinBeds] = useState<number|''>('');
  const [minBaths, setMinBaths] = useState<number|''>('');

  const rawRows = useMemo<Row[]>(() => {
    const pById = indexBy(props.data, "id");
    return (units.data || []).map((u: any) => {
      const rent = typeof u.rent_cents === "number" ? u.rent_cents/100 : (u.market_rent ?? u.rent ?? u.rent_amount);
      const status = u.status ?? (u.id && u.property_id ? "" : "");
      return {
        id: u.id ?? u.doorloop_id,
        doorloop_id: u.doorloop_id,
        property: u.property ?? u.property_name ?? pById.get(u.property_id)?.name ?? "",
        unit_number: u.unit_number ?? u.number ?? u.name ?? "",
        beds: u.beds ?? u.bedrooms ?? '',
        baths: u.baths ?? u.bathrooms ?? '',
        sq_ft: u.sq_ft ?? u.sqft ?? '',
        status: status,
        market_rent: typeof rent === "number" ? rent : undefined,
      };
    });
  }, [units.data, props.data]);

  const filtered = useMemo(() => {
    return rawRows.filter(r => {
      if (statusF !== "ALL") {
        const s = (r.status || "").toLowerCase();
        const bucket = s === "occupied" ? "Occupied" : s === "vacant" ? "Vacant" : "Other";
        if (bucket !== statusF) return false;
      }
      if (minBeds !== '' && (Number(r.beds) < Number(minBeds))) return false;
      if (minBaths !== '' && (Number(r.baths) < Number(minBaths))) return false;
      return true;
    });
  }, [rawRows, statusF, minBeds, minBaths]);

  const totals = useMemo(() => {
    const total = filtered.length;
    const occ = filtered.filter(r => String(r.status).toLowerCase()==="occupied").length;
    const vac = filtered.filter(r => String(r.status).toLowerCase()==="vacant").length;
    const avgRent = (() => {
      const rents = filtered.map(r => r.market_rent).filter((x):x is number => typeof x === "number");
      if (!rents.length) return undefined;
      return rents.reduce((a,b)=>a+b,0)/rents.length;
    })();
    return { total, occ, vac, avgRent };
  }, [filtered]);

  const cols: Col<Row>[] = [
    { key: "property", header: "Property" },
    { key: "unit_number", header: "Unit" },
    { key: "beds", header: "Bd", align: "right" },
    { key: "baths", header: "Ba", align: "right" },
    { key: "sq_ft", header: "SqFt", align: "right" },
    { key: "status", header: "Status", render: (r) => <span className={`badge ${String(r.status).toLowerCase()==="occupied"?"ok":String(r.status).toLowerCase()==="vacant"?"warn":""}`}>{r.status || "—"}</span> },
    { key: "market_rent", header: "Market Rent", align: "right", render: (r)=> <span className="mono">{money(r.market_rent)}</span> },
  ];

  const filtersRight = (
    <>
      <select className="flt-select" value={statusF} onChange={(e)=>setStatusF(e.target.value as any)}>
        <option>ALL</option><option>Occupied</option><option>Vacant</option><option>Other</option>
      </select>
      <input className="flt-input" type="number" min="0" placeholder="Min Bd" value={minBeds as any}
        onChange={(e)=>setMinBeds(e.target.value===""? '' : Number(e.target.value))} style={{ width:90 }} />
      <input className="flt-input" type="number" min="0" placeholder="Min Ba" value={minBaths as any}
        onChange={(e)=>setMinBaths(e.target.value===""? '' : Number(e.target.value))} style={{ width:90 }} />
    </>
  );

  return (
    <>
      <KPIBar items={[
        { label: "Units", value: totals.total },
        { label: "Occupied", value: totals.occ, tone: "ok" },
        { label: "Vacant", value: totals.vac, tone: totals.vac ? "warn" : "ok" },
        { label: "Avg Market Rent", value: money(totals.avgRent ?? "—") },
      ]}/>
      <DataTable
        title="Units"
        columns={cols}
        rows={filtered}
        loading={units.loading}
        error={units.error ?? undefined}
        searchKeys={UNIT_COLUMNS.map(c => c.key as keyof Row & string)}
        defaultPageSize={50}
        pageSizeOptions={[25,50,100,200]}
        toolbarRight={filtersRight}
        csvFileName="units.csv"
        rowKey={(r)=>r.id}
        emptyText="No units"
      />
    </>
  );
}
TSX

############################################
# LEASES — filters + KPIs
############################################
cat > src/pages/portfolio/leases/index.tsx <<'TSX'
import React, { useMemo, useState } from "react";
import { DataTable, Col } from "@/components/DataTable";
import KPIBar from "@/components/KPIBar";
import { LEASE_COLUMNS } from "../columns";
import { useCollection } from "@/features/data/useCollection";
import { indexBy } from "@/utils/dict";
import { money, shortDate } from "@/utils/format";

type Row = { id:any; doorloop_id?:any; tenant_names:string; property:string; rent:number|undefined; start:any; end:any; status:string };

export default function LeasesPage() {
  const leases = useCollection<any>("leases");
  const tenants = useCollection<any>("tenants");
  const props = useCollection<any>("properties");

  const [statusF, setStatusF] = useState<"ALL"|"active"|"ended">("ALL");

  const rawRows = useMemo<Row[]>(() => {
    const tById = indexBy(tenants.data, "id");
    const pById = indexBy(props.data, "id");
    return (leases.data || []).map((l: any) => {
      const names =
        l.tenant_names ||
        tById.get(l.primary_tenant_id)?.display_name ||
        tById.get(l.tenant_id)?.display_name ||
        tById.get(l.primary_tenant_id)?.full_name ||
        tById.get(l.tenant_id)?.full_name || "";
      const rent = typeof l.rent_cents === "number" ? l.rent_cents/100 : (l.rent ?? l.total_recurring_rent);
      return {
        id: l.id ?? l.doorloop_id,
        doorloop_id: l.doorloop_id,
        tenant_names: names,
        property: l.property ?? pById.get(l.property_id)?.name ?? "",
        rent: typeof rent === "number" ? rent : undefined,
        start: l.start ?? l.start_date,
        end: l.end ?? l.end_date,
        status: (l.status ?? "").toLowerCase(),
      };
    });
  }, [leases.data, tenants.data, props.data]);

  const filtered = useMemo(() => {
    return rawRows.filter(r => statusF==="ALL" ? true : r.status === statusF);
  }, [rawRows, statusF]);

  const totals = useMemo(() => {
    const active = filtered.filter(r=>r.status==="active");
    const ended = filtered.filter(r=>r.status==="ended");
    const mrr = active.reduce((a,r)=> a + (r.rent || 0), 0);
    const avgRent = active.length ? mrr / active.length : 0;
    return { count: filtered.length, active: active.length, ended: ended.length, mrr, avgRent };
  }, [filtered]);

  const cols: Col<Row>[] = [
    { key: "tenant_names", header: "Tenant(s)" },
    { key: "property", header: "Property" },
    { key: "rent", header: "Rent", align: "right", render: (r)=> <span className="mono">{money(r.rent)}</span> },
    { key: "start", header: "Start", render: (r)=> shortDate(r.start) },
    { key: "end", header: "End", render: (r)=> shortDate(r.end) },
    { key: "status", header: "Status", render: (r)=> <span className={`badge ${r.status==="active"?"ok":r.status==="ended"?"bad":"warn"}`}>{r.status || "—"}</span> },
  ];

  const filtersRight = (
    <select className="flt-select" value={statusF} onChange={(e)=>setStatusF(e.target.value as any)}>
      <option value="ALL">All</option>
      <option value="active">active</option>
      <option value="ended">ended</option>
    </select>
  );

  return (
    <>
      <KPIBar items={[
        { label: "Leases", value: totals.count },
        { label: "Active", value: totals.active, tone: "ok" },
        { label: "Ended", value: totals.ended, tone: totals.ended ? "warn" : "ok" },
        { label: "MRR", value: money(totals.mrr) },
        { label: "Avg Rent", value: money(totals.avgRent) },
      ]}/>
      <DataTable
        title="Leases"
        columns={cols}
        rows={filtered}
        loading={leases.loading}
        error={leases.error ?? undefined}
        searchKeys={LEASE_COLUMNS.map(c => c.key as keyof Row & string)}
        defaultPageSize={50}
        pageSizeOptions={[25,50,100,200]}
        toolbarRight={filtersRight}
        csvFileName="leases.csv"
        rowKey={(r)=>r.id}
        emptyText="No leases"
      />
    </>
  );
}
TSX

############################################
# TENANTS — filters + KPIs (contactable, status)
############################################
cat > src/pages/portfolio/tenants/index.tsx <<'TSX'
import React, { useMemo, useState } from "react";
import { DataTable, Col } from "@/components/DataTable";
import KPIBar from "@/components/KPIBar";
import { TENANT_COLUMNS } from "../columns";
import { useCollection } from "@/features/data/useCollection";
import { indexBy } from "@/utils/dict";
import { money } from "@/utils/format";

type Row = { id:any; doorloop_id?:any; name:string; property:string; unit:string; email:string; phone:string; status:string; balance:any };

export default function TenantsPage() {
  const tenants = useCollection<any>("tenants");
  const leases = useCollection<any>("leases");
  const units  = useCollection<any>("units");
  const props  = useCollection<any>("properties");

  const [statusF, setStatusF] = useState<"ALL"|"LEASE_TENANT"|"PROSPECT_TENANT">("ALL");
  const [contactableOnly, setContactableOnly] = useState(false);

  const rows = useMemo<Row[]>(() => {
    const uById = indexBy(units.data, "id");
    const pById = indexBy(props.data, "id");
    const latest = new Map<any, any>();
    for (const l of leases.data || []) {
      const tids = [l.primary_tenant_id, l.tenant_id].filter(Boolean);
      for (const tid of tids) {
        const cur = latest.get(tid);
        const score = Date.parse(l.updated_at || l.start_date || "") || 0;
        const curScore = cur ? (Date.parse(cur.updated_at || cur.start_date || "") || 0) : -1;
        if (!cur || score >= curScore) latest.set(tid, l);
      }
    }
    return (tenants.data || []).map((t: any) => {
      const l = latest.get(t.id);
      const u = l ? uById.get(l.unit_id) : undefined;
      const p = u ? pById.get(u.property_id) : (l ? pById.get(l.property_id) : undefined);
      const name =
        t.name || t.display_name || t.full_name || [t.first_name, t.last_name].filter(Boolean).join(" ");
      return {
        id: t.id ?? t.doorloop_id,
        doorloop_id: t.doorloop_id,
        name,
        property: p?.name ?? "",
        unit: u?.unit_number ?? u?.number ?? u?.name ?? "",
        email: t.primary_email ?? t.email ?? "",
        phone: t.primary_phone ?? t.phone ?? "",
        status: (l?.status ?? t.status ?? t.type ?? "").toString(),
        balance: t.balance,
      };
    });
  }, [tenants.data, leases.data, units.data, props.data]);

  const filtered = useMemo(() => {
    return rows.filter(r => {
      if (statusF !== "ALL" && r.status !== statusF) return false;
      if (contactableOnly && !(r.email || r.phone)) return false;
      return true;
    });
  }, [rows, statusF, contactableOnly]);

  const totals = useMemo(() => {
    const count = filtered.length;
    const contactable = filtered.filter(r => r.email || r.phone).length;
    const leaseTenants = filtered.filter(r => r.status === "LEASE_TENANT").length;
    const prospects = filtered.filter(r => r.status === "PROSPECT_TENANT").length;
    return { count, contactable, leaseTenants, prospects };
  }, [filtered]);

  const cols: Col<Row>[] = [
    { key: "name", header: "Name" },
    { key: "property", header: "Property" },
    { key: "unit", header: "Unit" },
    { key: "email", header: "Email" },
    { key: "phone", header: "Phone" },
    { key: "status", header: "Status", render: (r)=> <span className={`badge ${r.status==="LEASE_TENANT"?"ok":""}`}>{r.status || "—"}</span> },
    { key: "balance", header: "Balance", align: "right", render: (r)=> <span className="mono">{money(r.balance)}</span> },
  ];

  const filtersRight = (
    <>
      <select className="flt-select" value={statusF} onChange={(e)=>setStatusF(e.target.value as any)}>
        <option value="ALL">All</option>
        <option value="LEASE_TENANT">LEASE_TENANT</option>
        <option value="PROSPECT_TENANT">PROSPECT_TENANT</option>
      </select>
      <label className="flt-check" style={{ display:"inline-flex", alignItems:"center", gap:6 }}>
        <input type="checkbox" checked={contactableOnly} onChange={(e)=>setContactableOnly(e.target.checked)} />
        Contactable only
      </label>
    </>
  );

  return (
    <>
      <KPIBar items={[
        { label: "Tenants", value: totals.count },
        { label: "Contactable", value: totals.contactable },
        { label: "Lease Tenants", value: totals.leaseTenants, tone: "ok" },
        { label: "Prospects", value: totals.prospects, tone: "warn" },
      ]}/>
      <DataTable
        title="Tenants"
        columns={cols}
        rows={filtered}
        loading={tenants.loading}
        error={tenants.error ?? undefined}
        searchKeys={TENANT_COLUMNS.map(c => c.key as keyof Row & string)}
        defaultPageSize={50}
        pageSizeOptions={[25,50,100,200]}
        toolbarRight={filtersRight}
        csvFileName="tenants.csv"
        rowKey={(r)=>r.id}
        emptyText="No tenants"
      />
    </>
  );
}
TSX

############################################
# OWNERS — derive property_count from properties when possible + KPIs
############################################
cat > src/pages/portfolio/owners/index.tsx <<'TSX'
import React, { useMemo, useState } from "react";
import { DataTable, Col } from "@/components/DataTable";
import KPIBar from "@/components/KPIBar";
import { OWNER_COLUMNS } from "../columns";
import { useCollection } from "@/features/data/useCollection";

type Row = { id:any; doorloop_id?:any; name:string; email:string; phone:string; property_count:number; active:any };

export default function OwnersPage() {
  const owners = useCollection<any>("owners");
  const props  = useCollection<any>("properties");

  const [activeF, setActiveF] = useState<"ALL"|"true"|"false">("ALL");

  const rows = useMemo<Row[]>(() => {
    // Try several probable property owner fields
    function propertyCountForOwner(o:any) {
      const idMatch = (p:any) => p.owner_id===o.id || p.owners?.some?.((oid:any)=>oid===o.id);
      const nameMatch = (p:any) => {
        const s = [p.owner, p.owner_name, p.owner_display_name].filter(Boolean).join(" ").toLowerCase();
        const on = [o.name, o.display_name, o.full_name, `${o.first_name ?? ""} ${o.last_name ?? ""}`].filter(Boolean).join(" ").toLowerCase();
        return s && on && s.includes(on);
      };
      const candidates = (props.data || []).filter((p:any)=> idMatch(p) || nameMatch(p));
      return candidates.length || o.property_count || 0;
    }

    return (owners.data || []).map((o:any) => ({
      id: o.id ?? o.doorloop_id,
      doorloop_id: o.doorloop_id,
      name: o.name ?? o.display_name ?? o.full_name ?? [o.first_name, o.last_name].filter(Boolean).join(" "),
      email: o.primary_email ?? o.email ?? "",
      phone: o.primary_phone ?? o.phone ?? "",
      property_count: propertyCountForOwner(o),
      active: o.active ?? o.isActive ?? false,
    }));
  }, [owners.data, props.data]);

  const filtered = useMemo(() => rows.filter(r => activeF==="ALL" ? true : String(!!r.active)===activeF), [rows, activeF]);

  const totals = useMemo(() => {
    const count = filtered.length;
    const active = filtered.filter(r=>r.active).length;
    const propsSum = filtered.reduce((a,r)=>a+(r.property_count||0), 0);
    return { count, active, propsSum };
  }, [filtered]);

  const cols: Col<Row>[] = [
    { key: "name", header: "Owner" },
    { key: "email", header: "Email" },
    { key: "phone", header: "Phone" },
    { key: "property_count", header: "Props", align: "right", render: (r)=> <span className="mono">{r.property_count ?? 0}</span> },
    { key: "active", header: "Active", render: (r)=> <span className={`badge ${r.active ? "ok":"bad"}`}>{String(r.active)}</span> },
  ];

  const filtersRight = (
    <select className="flt-select" value={activeF} onChange={(e)=>setActiveF(e.target.value as any)}>
      <option value="ALL">All Owners</option>
      <option value="true">Active</option>
      <option value="false">Inactive</option>
    </select>
  );

  return (
    <>
      <KPIBar items={[
        { label: "Owners", value: totals.count },
        { label: "Active", value: totals.active, tone: "ok" },
        { label: "Total Properties", value: totals.propsSum },
      ]}/>
      <DataTable
        title="Owners"
        columns={cols}
        rows={filtered}
        loading={owners.loading}
        error={owners.error ?? undefined}
        searchKeys={OWNER_COLUMNS.map(c => c.key as keyof Row & string)}
        defaultPageSize={50}
        pageSizeOptions={[25,50,100,200]}
        toolbarRight={filtersRight}
        csvFileName="owners.csv"
        rowKey={(r)=>r.id}
        emptyText="No owners"
      />
    </>
  );
}
TSX

echo "✓ Genesis-grade polish shipped: KPIs, filters, CSV export, paging cap, richer data fills."
