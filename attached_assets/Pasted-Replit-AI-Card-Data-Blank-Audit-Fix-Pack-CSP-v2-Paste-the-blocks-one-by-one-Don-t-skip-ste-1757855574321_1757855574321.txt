Replit AI — “Card Data Blank” Audit & Fix Pack (CSP v2)

Paste the blocks one-by-one. Don’t skip steps. After each step, post your proof (curl output + file diffs + screenshots).

0) Lock the contract
Use the CSP v2 contract from the project’s runbook. No scope drift. After each step, show:
1) Terminal curl output (entities + rpc),
2) The exact files you changed,
3) A screenshot of /card/property/{id} and /portfolio/* reflecting live data.

1) Backend sanity — raw entities must return rows
# Replace 42 with a real property id from the table view (e.g., click a row and copy its id)
curl -s http://localhost:8787/api/entities/properties/42 | jq '{id, name, type, class}'
curl -s "http://localhost:8787/api/entities/units?property_id=eq.42"  | jq 'length'
curl -s "http://localhost:8787/api/entities/leases?property_id=eq.42" | jq '[.[]| .status] | unique'


If any of these are empty/404: fix server/routes/entities.ts mount or Supabase client envs and re-run.

2) RPC truth test — DTO must use DB PK joins (not vendor IDs)
curl -s "http://localhost:8787/api/rpc/get_property_card?id=42" | jq '{hasP:(.property!=null), u:(.units|length), l:(.leases|length), owner:(.owner!=null)}'


If u/l are zero but raw entities returned rows in Step 1, your joins are wrong. Replace RPC with the canonical version:

Replace server/routes/rpc.ts get_property_card with this:

// get_property_card
router.get('/get_property_card', async (req, res) => {
  const id = Number(req.query.id);
  if (!id) return res.status(400).json({error:'missing id'});

  const ctl = new AbortController();
  req.on('close', () => ctl.abort());

  const supa = getServerClient(); // from server/db.ts

  // property by PK
  const { data: property, error: pErr } = await supa
    .from('properties').select('*').eq('id', id).single();
  if (pErr || !property) return res.status(404).json({ error: 'not found' });

  // units by property_id (DB PK), not vendor_id
  const { data: units } = await supa
    .from('units').select('*').eq('property_id', id);

  // leases by property_id (DB PK)
  const { data: leases } = await supa
    .from('leases').select('*').eq('property_id', id);

  // owner join by owner_id (DB PK)
  let owner = null;
  if (property.owner_id) {
    const r = await supa.from('owners').select('*').eq('id', property.owner_id).single();
    owner = r.data || null;
  }

  return res.json({ property, units: units||[], leases: leases||[], owner });
});


Do the same PK-based pattern for get_unit_card, get_lease_card, etc. Mount the router at /api/rpc.

3) Normalize lease status (case/values drift = zero KPIs)

Different sources return status as "active", "ACTIVE", "Active", or codes. Standardize server-side so the UI always sees "active".

Add in server/routes/rpc.ts after fetching leases:

function normStatus(s?: string | null) {
  if (!s) return null;
  const k = String(s).toLowerCase().trim();
  if (['active','current','occupied'].includes(k)) return 'active';
  if (['pending','future'].includes(k)) return 'pending';
  if (['ended','terminated','closed','past'].includes(k)) return 'ended';
  return k;
}
leases = (leases || []).map(l => ({ ...l, status: normStatus(l.status) }));

4) Resolver fallback & DTO shape (avoid blank cards)

Replace src/lib/ecc-resolvers.ts card hooks with this resilient pattern:

export function usePropertyCard(id: number) {
  return useQuery({
    queryKey: ['card','property', id],
    queryFn: async () => {
      // RPC first
      const r = await fetch(`/api/rpc/get_property_card?id=${id}`);
      if (r.ok) {
        const dto = await r.json();
        return {
          property: dto.property ?? null,
          units: Array.isArray(dto.units) ? dto.units : [],
          leases: Array.isArray(dto.leases) ? dto.leases : [],
          owner: dto.owner ?? null,
        };
      }
      // Fallback: compose from entities
      const [p, u, l] = await Promise.all([
        fetch(`/api/entities/properties/${id}`).then(x=>x.json()),
        fetch(`/api/entities/units?property_id=eq.${id}`).then(x=>x.json()),
        fetch(`/api/entities/leases?property_id=eq.${id}`).then(x=>x.json()),
      ]);
      return { property: p ?? null, units: u ?? [], leases: l ?? [], owner: null };
    },
  });
}


Why: if RPC is mounted but mis-joining, you still get data on screen while we fix the join.

5) Hero KPIs — compute from arrays (and never show “—” when you have data)

In src/pages/card/property/Hero.tsx:

const unitsCount = data.units.length;
const activeLeases = data.leases.filter(l => (l.status||'').toLowerCase()==='active').length;
const occupancy = unitsCount ? (activeLeases/unitsCount) : 0;
// average rent (fall back to 0 if missing)
const rents = data.leases
  .filter(l => (l.status||'').toLowerCase()==='active')
  .map(l => Number(l.rent_cents||l.rent || 0));
const avgRent = rents.length ? (rents.reduce((a,b)=>a+b,0)/rents.length) : 0;


Render: show 0.0% and $0 instead of blank when arrays exist—blanks signal no data, not zeros.

6) Tables vs cards — make both share the same source of truth

Right now your tables show counts but the card KPIs are zero. Make them both use the same resolver so drift can’t happen.

In Properties/Units pages, swap ad-hoc fetches for a common data client:
Create src/lib/api.ts:

export async function getEntities(table: string, query = '') {
  const r = await fetch(`/api/entities/${table}${query ? '?'+query : ''}`);
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}


Refactor the table data loaders to use getEntities(...). This keeps field names consistent.

7) Supabase envs — prove server-only key usage
Show server/db.ts. Prove we read SUPABASE_URL + (SUPABASE_SERVICE_ROLE_KEY | SUPABASE_SERVICE_KEY | SUPABASE_KEY | SUPABASE_SECRET).
Search the client for any usage of these names or the literal key string – it must be zero.
Restart dev after any secret edits.

8) Final proof (must match the screenshots but with real values)
# Entities & DTO proof
curl -s http://localhost:8787/api/entities/properties/42 | jq .id
curl -s "http://localhost:8787/api/entities/units?property_id=eq.42"  | jq 'length'
curl -s "http://localhost:8787/api/rpc/get_property_card?id=42"      | jq '{u:(.units|length), a:(.leases|map(select(.status=="active"))|length)}'


Then open:

/card/property/42 → KPIs non-zero and Overview/Details populated.

/portfolio/properties and /portfolio/units → still populated (same data client).
Post screenshots.

Likely root causes (based on your screenshots)

Join keys drift: RPC joining on vendor IDs (e.g., DoorLoop) instead of normalized DB PKs → empty arrays in DTO.

Status normalization missing: leases “Active/ACTIVE/current” vs UI filter “active” → KPIs show zero.

Resolver fallback absent: UI trusts RPC only; when RPC mis-joins, the page renders with blanks.

Two data clients: tables use legacy/raw endpoints; cards use RPC → they disagree.

Everything above is already aligned with the CSP v2 Runbook we’re enforcing for this sprint, including DTO shapes, guardrails, and proof flow .