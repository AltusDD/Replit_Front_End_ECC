P1 — RUN + PROVE (no code changes, ops freeze respected)

TITLE: RUN ONLY: start server and prove data on 6 routes

INSTRUCTIONS (verbatim):

Do not edit .replit, package.json, vite.config*, replit.nix, or workflows.

Use the project’s existing method to start the app (whatever currently works without changing ops).

When running, open these routes and post screenshots:

/card/property/42

/card/property/57

/card/unit/45

/card/lease/1

/card/tenant/1

/card/owner/6

For each page, also open DevTools > Network and include the status codes for the entity calls (e.g., /entities/properties/42, /api/entities/properties/42, etc.).

If a route shows placeholders, run these console probes and paste results:

// raw endpoint reachability
Promise.all([
  fetch('/entities/properties/42').then(r=>({url:'/entities/properties/42',status:r.status})).catch(e=>({url:'/entities/properties/42',err:String(e)})),
  fetch('/api/entities/properties/42').then(r=>({url:'/api/entities/properties/42',status:r.status})).catch(e=>({url:'/api/entities/properties/42',err:String(e)})),
  fetch('/entities/units/45').then(r=>({url:'/entities/units/45',status:r.status})),
  fetch('/api/entities/units/45').then(r=>({url:'/api/entities/units/45',status:r.status}))
]).then(console.table);

// quick shape peek if 200
fetch('/entities/properties/42').then(r=>r.ok?r.json():null).then(d=>console.log('prop42', d));
fetch('/api/entities/properties/42').then(r=>r.ok?r.json():null).then(d=>console.log('prop42_api', d));


Acceptance:

App runs without ops edits.

Each of the 6 pages renders.

For at least one property, Title is not “—”, Units and Active Leases counters show numbers.

Network table shows which of /entities/* or /api/entities/* responds 200.

Stop after screenshots/network proof. Do not change ops or structure.

P2 — ECC Fix-Pack v1.1 (Trace + Field Mapping)

TITLE: CODE-ONLY: add tracing + mapping hardening (ops freeze)

SCOPE (allowed files only):

src/lib/ecc-api-client.ts

src/lib/ecc-card-queries.ts

No other files.

GOAL:

Trace every fetch to see exactly which path hits ( /entities/* vs /api/entities/* ), log status/time into window.__ECC_TRACE for us to inspect.

Harden field mapping so commonly named variants render (address, beds/baths, rent, etc.) instead of “—”.

PATCH (apply exactly):

src/lib/ecc-api-client.ts — add tracing wrapper + smarter base-path fallback

// TOP: keep existing imports; then add:
type TraceItem = {
  when: string; label: string; url: string; ms: number; status?: number; ok?: boolean; err?: string;
};
declare global { interface Window { __ECC_TRACE?: TraceItem[] } }

// helper
function trace(t: TraceItem){
  (window.__ECC_TRACE ||= []).push(t);
  // also mirror to console for live debug
  // eslint-disable-next-line no-console
  console.debug('[ECC_TRACE]', t.label, t.url, t.status ?? t.err, `${t.ms}ms`);
}

// Export a single resilient getter used by ecc-card-queries
export async function eccGet<T>(label: string, path: string): Promise<T> {
  const bases = ['', '/api']; // try raw, then /api
  let lastErr: any = null;

  for (const base of bases) {
    const url = `${base}${path}`;
    const t0 = performance.now();
    try {
      const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
      const ms = Math.round(performance.now() - t0);
      if (!res.ok) { trace({ when:new Date().toISOString(), label, url, ms, status: res.status, ok:false }); lastErr = new Error(`HTTP ${res.status}`); continue; }
      const json = await res.json();
      trace({ when:new Date().toISOString(), label, url, ms, status: res.status, ok:true });
      // @ts-expect-error expose for quick console inspection
      window.__ECC_LAST = { label, url, json };
      return json as T;
    } catch (err:any) {
      const ms = Math.round(performance.now() - t0);
      trace({ when:new Date().toISOString(), label, url, ms, err: String(err) });
      lastErr = err;
    }
  }
  throw lastErr ?? new Error('All base paths failed');
}

// Money util (keep if you already added one; otherwise include)
export function money(cents?: number | null): string {
  const n = Number(cents ?? 0);
  if (!Number.isFinite(n) || n === 0) return '—';
  return `$${(n/100).toLocaleString(undefined, { maximumFractionDigits: 0 })}`;
}


src/lib/ecc-card-queries.ts — use eccGet and harden field mapping

import { useQuery } from '@tanstack/react-query';
import { eccGet, money } from './ecc-api-client';

// helpers for tolerant field reads
const pick = <T=any>(obj:any, keys:string[], fallback?:any): T =>
  (keys.find(k => obj?.[k] !== undefined) ? obj[keys.find(k => obj?.[k] !== undefined)!] : fallback);

const addr = (p:any) => {
  const line1 = pick<string>(p, ['street_1','street','address1','address_line_1','addr1'], '');
  const city  = pick<string>(p, ['city','locality'], '');
  const state = pick<string>(p, ['state','region','province'], '');
  const zip   = pick<string>(p, ['zip','postal_code','postcode'], '');
  return [line1, city && ` ${city},`, state, zip].filter(Boolean).join(' ').replace(/\s+,/g, ',');
};

export function usePropertyCard(id: string){
  return useQuery({
    queryKey: ['propertyCard', id],
    queryFn: async () => {
      // base entity
      const property = await eccGet<any>('property', `/entities/properties/${id}`);
      // relations (allow to fail individually)
      const [units, leases] = await Promise.allSettled([
        eccGet<any[]>('unitsByProperty', `/entities/units?doorloop_property_id=eq.${pick(property,['doorloop_id','doorloop_property_id', 'dl_property_id'])}`),
        eccGet<any[]>('leasesByProperty', `/entities/leases?property_id=eq.${pick(property,['id','property_id'])}`),
      ]);

      const unitsArr  = units.status  === 'fulfilled' ? units.value  ?? [] : [];
      const leasesArr = leases.status === 'fulfilled' ? leases.value ?? [] : [];

      // derived
      const title = addr(property) || pick(property, ['name','label'], '—');
      const kpiUnits = unitsArr.length || 0;
      const kpiLeases = leasesArr.filter((l:any)=> String(l?.status||'').toLowerCase()==='active').length || 0;

      // avg rent from active leases (rent_cents or rent)
      const rents = leasesArr
        .map((l:any)=> Number(pick(l,['rent_cents','monthly_rent_cents','rent'], 0)))
        .filter((n)=> Number.isFinite(n) && n>0);
      const avgRentCents = rents.length ? Math.round(rents.reduce((a,b)=>a+b,0)/rents.length) : 0;

      return {
        raw: { property, units: unitsArr, leases: leasesArr },
        ui:  { title, kpiUnits, kpiLeases, avgRent: money(avgRentCents) }
      };
    },
    staleTime: 60_000,
  });
}

export function useUnitCard(id: string){
  return useQuery({
    queryKey: ['unitCard', id],
    queryFn: async () => {
      const unit = await eccGet<any>('unit', `/entities/units/${id}`);
      const property = await eccGet<any>('unitProperty', `/entities/properties?doorloop_id=eq.${pick(unit,['doorloop_property_id','property_doorloop_id','dl_property_id'])}`);
      const leases = await eccGet<any[]>('unitLeases', `/entities/leases?unit_id=eq.${pick(unit,['id','unit_id'])}&status=eq.active`);
      const active = Array.isArray(leases) ? leases[0] ?? null : null;

      const beds = pick<number>(unit, ['bedrooms','beds','bed_count'], null);
      const baths = pick<number>(unit, ['bathrooms','baths','bath_count'], null);

      return {
        raw: { unit, property: Array.isArray(property)? property[0] ?? null : property, activeLease: active },
        ui:  { title: pick(unit,['label','unit_number','name'], 'Unit —'), beds, baths }
      };
    },
    staleTime: 60_000,
  });
}

export function useLeaseCard(id: string){
  return useQuery({
    queryKey: ['leaseCard', id],
    queryFn: async () => {
      const lease = await eccGet<any>('lease', `/entities/leases/${id}`);
      const rentCents = Number(pick(lease,['rent_cents','monthly_rent_cents','rent'], 0));
      const term = [pick(lease,['start','start_date']), '—', pick(lease,['end','end_date'])].map(v=>v??'—').join(' ');
      return { raw: { lease }, ui: { status: pick(lease,['status'],'—'), rent: money(rentCents), term } };
    },
    staleTime: 60_000,
  });
}

export function useTenantCard(id: string){
  return useQuery({
    queryKey: ['tenantCard', id],
    queryFn: async () => {
      const tenant = await eccGet<any>('tenant', `/entities/tenants/${id}`);
      const leases = await eccGet<any[]>('tenantLeases', `/entities/leases?primary_tenant_id=eq.${pick(tenant,['id','tenant_id'])}`);
      return { raw: { tenant, leases }, ui: { name: pick(tenant,['name','full_name','display_name'], '—'), leaseCount: leases?.length ?? 0 } };
    },
    staleTime: 60_000,
  });
}

export function useOwnerCard(id: string){
  return useQuery({
    queryKey: ['ownerCard', id],
    queryFn: async () => {
      const owner = await eccGet<any>('owner', `/entities/owners/${id}`);
      const properties = await eccGet<any[]>('ownerProps', `/entities/properties?owner_id=eq.${pick(owner,['id','owner_id'])}`);
      return { raw: { owner, properties }, ui: { name: pick(owner,['name','display_name'],'—'), propertyCount: properties?.length ?? 0 } };
    },
    staleTime: 60_000,
  });
}


After patch, do not run workflows. Just tell me the patch is applied. I’ll request the P1 screenshots again.

What I’ll check in the browser after P1+P2:

window.__ECC_TRACE shows which base path returns 200s.

Property 42: non-placeholder title; Units/Active Leases counters reflect actual arrays; Avg Rent not “—” if any rents exist.

Unit 45: beds/baths no longer “—” if fields exist under any common variant.

Lease 1: Status/Rent/Term filled via tolerant fields.