REPLIT AGENT PROMPT (copy-paste everything below)

Mission: Implement ECC Portfolio Card Pages for Property/Unit/Lease/Tenant/Owner to “Genesis” standard. Use the uploaded docs as the single source of truth. Do not drift.

Guardrails (No-Drift)

Treat docs/ecc_portfolio_card_standard.md as authoritative requirements and acceptance criteria. Do not invent colors, routes, or tab names; use only theme tokens and classnames we already use in the app. No raw hex.

Do not break or rename existing list pages under /portfolio. Keep their columns, filters, search, and pagination working.

Do not introduce new dependencies beyond swr and dayjs (already present—if missing, add once).

Keep right-rail read-only; all write actions remain in main column.

Tables, DataTable, global layout, and left sidebar must continue to work on all pages after this change.

Every new file must be TypeScript/TSX with strict typing.

Inputs (already uploaded)

docs/ecc_portfolio_card_standard.md (requirements for routing, tabs, hero, KPIs, RBAC, telemetry, tests)

data/ecc_portfolio_card_spec_v3.csv (small spec matrix: per-entity required KPIs, tab presence, field groupings)

High-Level Deliverables

Routes: /card/property/:id, /card/unit/:id, /card/lease/:id, /card/tenant/:id, /card/owner/:id.

Scaffold per entity (files live under src/pages/card/<entity>/):

index.tsx (wrapper), Hero.tsx, Tabs.tsx, Overview.tsx, Details.tsx, Financials.tsx, Legal.tsx, Files.tsx, Linked.tsx, Activity.tsx, RightRail.tsx, api.ts (SWR hooks + DTO types).

DTO hooks: /api/rpc/get_<entity>_card?id=… fetchers via SWR with types. Implement an adapter that builds DTOs from our existing collections (DoorLoop/collection hooks) so real data shows up.

Table → Card linking: On all 5 portfolio list pages, enable row double-click and row click + “Details” action to open the corresponding card route.

Visuals: Hero with avatar/title/badges/KPIs, right rail widgets, sticky tabs, loading skeletons, empty/error states, copy-to-clipboard on IDs, tooltips on KPI labels/deltas.

Tests/Proofs: Add a minimal Playwright happy-path for /card/property/:id (tabs render + right rail present). Provide a README-cards.md with how to navigate and the mapping sources.

Concrete Tasks
0) Repo survey & prep

Print a file tree of src/pages/portfolio and src/features so you understand collection hooks we already have.

Confirm theme tokens file (e.g., src/styles/theme.css or current token map) and reuse those variables only.

1) Routing

Add the five card routes to the app router (no overlay panes; cards are full-page under the existing sidebar layout).

Breadcrumbs: Portfolio › <Plural> › <Entity Name> using the current breadcrumbs component if present (else create a tiny one in components/layout/Breadcrumbs.tsx).

2) Types & SWR data contracts

Create src/pages/card/types.ts with shared base types:

export type Id = string;
export interface Kpi { label: string; value: string | number; deltaPct?: number; }
export interface LinkedSummary { units?: number; leases?: number; tenants?: number; owner?: { id: Id; name: string }; }
export interface BaseCardDTO { id: Id; title: string; badges: string[]; kpis: Kpi[]; linked?: LinkedSummary; insights?: string[]; }


Per-entity DTOs follow the standard (title/address/contact lines, etc.). (Use the “Data Contracts (Typed)” and KPI matrices from the standard.) Parse data/ecc_portfolio_card_spec_v3.csv only at build-time if helpful, else hard-code KPI labels in the adapter for now.

3) API Adapters (no backend change)

In each entity’s api.ts, use existing collection selectors to assemble DTOs:

get_property_card(id): derive title (address line1), city/state, status chips (Active/Vacant/Delinquent/Renewal30/InLegal/OnHold where derivable), KPIs (Occupancy %, Units, Delinquency %, Open WOs, TTM NOI – use 0/“—” if unknown), Linked counts.

Repeat for Unit/Lease/Tenant/Owner with the KPI set listed in the spec doc. When data field doesn’t exist, return a safe placeholder ("—" or 0).

Export hooks like:

import useSWR from 'swr';
const fetcher = (url: string) => fetch(url).then(r => r.json());

export function usePropertyCard(id: string) {
  return useSWR(id ? `/api/rpc/get_property_card?id=${id}` : null, fetcher, { revalidateOnFocus: false });
}


(You may also directly assemble DTOs in the hook from local collections without a network hop if our app is SPA-only; keep the API shape the same.)

4) Components (per entity)

Hero.tsx: left side avatar/icon + title + secondary line (city • state • short id), badges, KPIs (grid), primary actions (role-gated placeholders).

Tabs.tsx: “Overview · Details · Financials · Legal · Files · Linked · Activity” (lazy mount each tab).

RightRail.tsx: read-only widgets → Risk score, last 5 payments (if applicable), legal status quick view, upcoming events, quick files.

Tab files:

Overview: identity block + linked mini-cards + “AI Insights” list + recent activity.

Details: structured field groups (from spec).

Financials: a simple ledger table v1 using existing DataTable; add date/type filters and totals row.

Legal: case table placeholders wired to any legal data if present; otherwise scaffold.

Files: hook into our file provider (DoorLoop/Dropbox wrapper) if available; else scaffold with a read-only list.

Linked: units/leases/tenants/owner lists with counts and click-through chips.

Activity: unified timeline using whatever we have for audit/comms; else show placeholder.

All visuals must use existing theme tokens and our table.css classes.

5) Wire list pages → card routes (double-click + actions)

Extend components/DataTable.tsx with two optional props:

rowHref?: (row:any)=>string;
onRowDoubleClick?: (row:any)=>void;


Implementation: add onDoubleClick to <tr>; if rowHref is provided, also set role="link" + tabIndex={0} and navigate on Enter.

On each portfolio list page, pass rowHref to point at the proper card route using the row id.

Add a trailing “⋯” actions button per row (right aligned) with a menu that includes “Open Card” and existing quick actions.

6) Small polish (Genesis feel)

Increase row vertical padding by ~2–4px in tables; right-align numeric columns (if not already).

Add clear hover state on rows (background: var(--row-hover) from our tokens).

Add copy-to-clipboard icon on ID/address/email fields in cards.

Add KPI tooltips (“definition / last updated / source”).

Loading skeletons for hero + right rail + first tab.

7) Telemetry + RBAC placeholders

Emit basic events: card_loaded {entity,id,tab}, card_tab_changed, card_action_clicked.

Add role checks (if can(action) util exists); otherwise create a stub that always returns true with a // TODO RBAC comment.

8) Tests & proofs

Add tests/card_property.spec.ts (Playwright): navigate to any known property id from the list, assert hero, tabs, right rail present, switch one tab.

Provide README-cards.md summarizing routes, props added to DataTable, and where DTOs are assembled.

Reconciliation Rules

Before changes: run, snapshot routes and list pages.

After changes: ensure all portfolio/* pages still render data; confirm double-click takes you to the card page.

Never remove existing exports; if a name conflict appears, alias instead of renaming.

Done-When Checklist

Five routes load with real data derived from our collections.

On any list page, double-click a row opens the corresponding card.

Right rail is read-only.

No raw hex; only theme tokens.

Playwright spec passes locally.

Provide a short diff summary and screenshots of /card/property/:id (Overview tab) and the right rail.

Commands for you (Agent)

Create the folder/file scaffold exactly as listed.

Implement DTO adapters and SWR hooks.

Update DataTable.tsx to support rowHref and onRowDoubleClick.

Wire list pages to card routes.

Add skeletons, hover states, clipboard, tooltips.

Add Playwright spec + README.

Run lints/build/tests, then report back with:

File tree of src/pages/card

Snippets (or screenshots) of Hero + Tabs + RightRail on /card/property/:id

Confirmation that list → card double-click works.

If any requirement in docs/ecc_portfolio_card_standard.md conflicts with the current codebase, prefer the standard and document the conflict in README-cards.md so we can approve.
Do not refactor unrelated modules.

Notes

KPI labels/sets, tabs, and right-rail rules must match the standard’s matrices and descriptions.

Use placeholders “—” for unknown values; never crash on missing fields.

END PROMPT