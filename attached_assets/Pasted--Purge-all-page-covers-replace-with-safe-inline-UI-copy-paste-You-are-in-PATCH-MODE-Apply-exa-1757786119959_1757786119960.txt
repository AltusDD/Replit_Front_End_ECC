“Purge all page covers & replace with safe inline UI” (copy-paste)

You are in PATCH MODE. Apply exactly these changes. Print diffs for each file you modify. After patching, run npm run guardrail:overlays and npx tsc --noEmit and paste outputs.

1) Delete the crash overlay (no exceptions)

Delete file: src/debug/crash-overlay.ts
This file registers window handlers and draws a full-screen overlay. It must not exist.

2) Replace full-screen modals with inline .ecc-object sections
A) Planner modal (M365)

File: src/features/m365/PlannerModal.tsx
Replace entire component with this:

import React, { useState } from "react";

export default function PlannerModal({
  open,
  onClose,
  entity_type,
  entity_id,
}: {
  open: boolean;
  onClose: () => void;
  entity_type: string;
  entity_id: string | number;
}) {
  const [title, setTitle] = useState("");
  const [notes, setNotes] = useState("");
  const [due, setDue] = useState("");

  if (!open) return null;

  // INLINE, IN-PANEL: never cover the page
  return (
    <section className="ecc-object" role="dialog" aria-modal="false" aria-label="New Planner Task">
      <div className="ecc-header">
        <div className="ecc-title">New Planner Task</div>
        <div className="ecc-actions" style={{ display: "flex", gap: 8 }}>
          <button className="ecc-object" onClick={onClose} style={{ padding: "8px 12px" }}>Close</button>
        </div>
      </div>

      <div style={{ display: "grid", gap: 10 }}>
        <input
          className="ecc-object"
          placeholder="Title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          style={{ padding: "8px 10px" }}
        />
        <textarea
          className="ecc-object"
          placeholder="Notes"
          value={notes}
          onChange={(e) => setNotes(e.target.value)}
          rows={4}
          style={{ padding: "8px 10px" }}
        />
        <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
          <span className="ecc-label">Due</span>
          <input
            type="date"
            className="ecc-object"
            value={due}
            onChange={(e) => setDue(e.target.value)}
            style={{ padding: "6px 8px" }}
          />
        </div>

        <div style={{ display: "flex", justifyContent: "flex-end", gap: 8 }}>
          <button className="ecc-object" onClick={onClose} style={{ padding: "8px 12px" }}>Cancel</button>
          <button
            className="ecc-object"
            style={{ padding: "8px 12px" }}
            onClick={async () => {
              const r = await fetch("/api/m365/planner/tasks", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ title, notes, due_date: due, entity_type, entity_id }),
              });
              if (r.ok) onClose();
              else alert(await r.text());
            }}
          >
            Create
          </button>
        </div>
      </div>
    </section>
  );
}

B) ErrorPane overlay

File: src/features/systems/integrations/components/ErrorPane.tsx
Replace the top-level fixed/backdrop wrapper with inline panel.
Find the block that looks like this:

<div className="fixed inset-0 z-50 overflow-y-auto">
  <div className="fixed inset-0 bg-black bg-opacity-50" onClick={onClose} />
  <div className="fixed right-0 top-0 h-full w-full max-w-2xl ...">
    {/* content */}
  </div>
</div>


Replace with:

{isOpen && (
  <section className="ecc-object" role="region" aria-label="Integration Error Details">
    {/* move existing inner content here without any fixed/backdrop classes */}
  </section>
)}


Keep the inner card content; just remove the fixed/backdrop containers so it renders as an inline .ecc-object.

3) Kill the DataTable drawer overlay

File: src/styles/table.css
Replace the drawer rules with a non-overlay, inline variant:

/* Drawer: INLINE, never full-screen */
.ecc-drawer{
  position: static;           /* was: fixed; inset:0 */
  display: block;
  z-index: auto;
}
.ecc-drawer__backdrop{
  display: none !important;   /* never render a page mask */
}
.ecc-drawer__panel{
  position: relative;
  width: 100%;
  max-width: 100%;
  height: auto;               /* was: 100% */
  background: var(--surface-1);
  border: 1px solid var(--line-1);
  border-radius: 12px;
  overflow: hidden;
}
.ecc-drawer__head{ display:flex; align-items:center; justify-content:space-between;
  padding: 14px; border-bottom:1px solid var(--line-1); }
.ecc-drawer__body{ padding:14px; overflow:auto; max-height: 60vh; }


(No TSX changes needed in DataTable.tsx—the CSS change prevents any viewport cover.)

4) Neutralize any leftover modal CSS

File: src/styles/transfer-modal.css
Replace all contents with SAFE inline styles:

/* INLINE-ONLY modal variants (no viewport cover, no backdrop) */
.modal { position: static; inset: auto; background: transparent; display: block; z-index: auto; }
.modal-card {
  background: var(--panel-elev);
  border: 1px solid var(--line, var(--border));
  border-radius: 10px;
  max-width: 900px;
  padding: 20px;
  box-shadow: none;
}

5) Keep the kill-switch + guardrail you already added

Ensure (only once):

src/styles/no-overlays.css is imported in src/main.tsx.

scripts/guardrail-overlays.mjs exists and npm run guardrail:overlays is wired into predev and prebuild.

6) Verify & report

Run:

npm run guardrail:overlays
npx tsc --noEmit


Open each route and confirm:

/card/property/:id — renders, map shown, no page cover

/card/unit/:id — renders, no map, no page cover

/card/lease/:id — renders, no map, no page cover

/card/tenant/:id — renders, no map, no page cover

/card/owner/:id — renders, no map, no page cover

Paste:

The two command outputs

A 5-line checklist (one per route) confirming “renders ✅ / page cover ❌ / map only on Property ✅”.

Why this fixes the black/blank screens

Crash overlay is the silent “kill switch” that paints a full black layer on error. Deleting it removes that behavior globally.

Drawer/modal/Pane overlays are converted to in-panel .ecc-object sections, so nothing can ever blanket the viewport again.

The guardrail fails builds if any developer (or agent) re-introduces fixed full-screen patterns.

The kill-switch CSS hides any stray injected overlays at runtime (belt-and-suspenders).

If you want, I can follow with a similar “no global redirects returning null” pass (turning those into visible in-panel messages + Wouter <Redirect />)—but the items above are the ones that actually cause full-screen blanking.