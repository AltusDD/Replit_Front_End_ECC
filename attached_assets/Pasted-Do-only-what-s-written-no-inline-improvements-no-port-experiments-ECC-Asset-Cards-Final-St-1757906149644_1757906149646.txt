Do only what‚Äôs written‚Äîno ‚Äúinline improvements,‚Äù no port experiments.

üîß ECC Asset Cards ‚Äî Final Stabilization Plan (No-Drift)
0) Stop the churn

Do not unify ports. Our dev model is Vite 5173 (web) + API 8787 proxied by Vite. We keep it.

Use only: npm run dev (this already runs the guardrail, web, and api concurrently).

1) Restore canonical ports & proxy

A. vite.config.ts/js ‚Äî ensure this proxy block exists:

export default defineConfig({
  server: {
    port: 5173,
    proxy: { "/api": "http://localhost:8787" }  // <‚Äî DO NOT CHANGE
  },
  // ...rest
});


B. server/index.ts ‚Äî ensure the API listens on 8787:

const PORT = Number(process.env.API_PORT ?? 8787);
app.listen(PORT, () => console.log(`[Dev API] Listening on :${PORT}`));


If you changed this earlier (e.g., to 5000), revert to 8787.

C. Clean caches

rm -rf node_modules/.vite .vite dist .cache .parcel-cache 2>/dev/null || true

2) RPC hardening (cards only)

In server/routes/rpc.ts add once (top):

async function fetchOneMulti(sb:any, table:string, id:string|number, alt:string[]) {
  const v = String(id);
  const ors = ["id.eq."+v, ...alt.map(f => `${f}.eq.${v}`)].join(",");
  const { data, error } = await sb.from(table).select("*").or(ors).limit(1).maybeSingle();
  if (error) throw error;
  return data ?? null;
}
const norm = (s:any) => String(s ?? "").toLowerCase();


Property card handler must compute avgRentCents and allow null (no active leases). If your handler doesn‚Äôt match this, replace its body with:

app.get("/api/rpc/get_property_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const property = await fetchOneMulti(supabase, "properties", id, ["doorloop_property_id","doorloop_id"]);
    if (!property) return res.status(404).json({ error: "property not found", id });

    const { data: units = [] }  = await supabase.from("units").select("*").eq("property_id", property.id);
    const { data: leases = [] } = await supabase.from("leases").select("*").eq("property_id", property.id);

    const active = leases.filter((l:any)=> norm(l.status)==="active");
    const unitsCount   = units.length;
    const activeCount  = active.length;
    const occupancyPct = unitsCount ? Math.round((activeCount/unitsCount)*1000)/10 : 0;

    const rents = active.map((l:any)=> Number(l.rent_cents ?? l.rent ?? 0))
                        .filter((n:number)=> Number.isFinite(n) && n>=0);
    const avgRentCents = rents.length ? Math.round(rents.reduce((a,b)=>a+b,0)/rents.length) : null;

    return res.json({
      property: { ...property, ...mapAddress(property) },
      units, leases,
      kpis: { units: unitsCount, activeLeases: activeCount, occupancyPct, avgRentCents }
    });
  } catch (e:any) {
    console.error("[rpc:get_property_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});


Unit card handler (dual-key everything, JSON errors only):

app.get("/api/rpc/get_unit_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const unit = await fetchOneMulti(supabase, "units", id, ["doorloop_unit_id","doorloop_id"]);
    if (!unit) return res.status(404).json({ error: "unit not found", id });

    const property = unit.property_id
      ? await fetchOneMulti(supabase, "properties", unit.property_id, ["doorloop_property_id","doorloop_id"])
      : null;

    const { data: leaseRows } = await supabase
      .from("leases").select("*")
      .or(`unit_id.eq.${unit.id},doorloop_unit_id.eq.${unit.doorloop_unit_id ?? ""}`)
      .limit(1);
    const lease = leaseRows?.[0] ?? null;

    const tenant = lease?.tenant_id
      ? await fetchOneMulti(supabase, "tenants", lease.tenant_id, ["doorloop_tenant_id"])
      : null;

    return res.json({ unit, property: property ? { ...property, ...mapAddress(property)} : null, lease, tenant });
  } catch (e:any) {
    console.error("[rpc:get_unit_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});


Lease card handler (dual-key + relations):

app.get("/api/rpc/get_lease_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const lease = await fetchOneMulti(supabase, "leases", id, ["doorloop_lease_id","doorloop_id"]);
    if (!lease) return res.status(404).json({ error: "lease not found", id });

    const unit = lease.unit_id
      ? await fetchOneMulti(supabase, "units", lease.unit_id, ["doorloop_unit_id","doorloop_id"])
      : null;

    const property = unit?.property_id
      ? await fetchOneMulti(supabase, "properties", unit.property_id, ["doorloop_property_id","doorloop_id"])
      : null;

    const tenant = lease.tenant_id
      ? await fetchOneMulti(supabase, "tenants", lease.tenant_id, ["doorloop_tenant_id"])
      : null;

    return res.json({ lease, unit, property: property ? { ...property, ...mapAddress(property)} : null, tenant });
  } catch (e:any) {
    console.error("[rpc:get_lease_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});


Owner & Tenant ‚Äî wrap in try/catch and use fetchOneMulti as above. (You already did this in prior passes; keep it.)

3) Frontend (1-line safety)

src/pages/card/property/HeroBlock.tsx ‚Äî compute branch must allow no active leases:

- if (!rents.length) throw new Error("[CONTRACT] No active leases to compute avg rent");
- const avgRentCents = Math.round(rents.reduce((a,b)=>a+b,0)/rents.length);
+ const avgRentCents = rents.length ? Math.round(rents.reduce((a,b)=>a+b,0)/rents.length) : null;


Rendering stays: show "‚Äî" when avgRentCents === null. (No ?? 0 or || 0 anywhere.)

4) Schema: apply via Supabase SQL (skip Drizzle)

Open Supabase SQL Editor and run exactly this idempotent patch:

-- PROPERTIES
ALTER TABLE public.properties
  ADD COLUMN IF NOT EXISTS doorloop_id text,
  ADD COLUMN IF NOT EXISTS doorloop_property_id text,
  ADD COLUMN IF NOT EXISTS owner_id bigint;
CREATE INDEX IF NOT EXISTS idx_properties_doorloop_id         ON public.properties(doorloop_id);
CREATE INDEX IF NOT EXISTS idx_properties_doorloop_property_id ON public.properties(doorloop_property_id);
CREATE INDEX IF NOT EXISTS idx_properties_owner_id            ON public.properties(owner_id);
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_properties_owner') THEN
    ALTER TABLE public.properties
      ADD CONSTRAINT fk_properties_owner
      FOREIGN KEY (owner_id) REFERENCES public.owners(id) ON DELETE SET NULL;
  END IF;
END$$;

-- UNITS
ALTER TABLE public.units
  ADD COLUMN IF NOT EXISTS doorloop_id text,
  ADD COLUMN IF NOT EXISTS doorloop_unit_id text;
CREATE INDEX IF NOT EXISTS idx_units_doorloop_id     ON public.units(doorloop_id);
CREATE INDEX IF NOT EXISTS idx_units_doorloop_unit_id ON public.units(doorloop_unit_id);

-- LEASES
ALTER TABLE public.leases
  ADD COLUMN IF NOT EXISTS doorloop_id text,
  ADD COLUMN IF NOT EXISTS doorloop_lease_id text,
  ADD COLUMN IF NOT EXISTS tenant_id  bigint,
  ADD COLUMN IF NOT EXISTS unit_id    bigint,
  ADD COLUMN IF NOT EXISTS property_id bigint;
CREATE INDEX IF NOT EXISTS idx_leases_doorloop_id      ON public.leases(doorloop_id);
CREATE INDEX IF NOT EXISTS idx_leases_doorloop_lease_id ON public.leases(doorloop_lease_id);
CREATE INDEX IF NOT EXISTS idx_leases_tenant_id        ON public.leases(tenant_id);
CREATE INDEX IF NOT EXISTS idx_leases_unit_id          ON public.leases(unit_id);
CREATE INDEX IF NOT EXISTS idx_leases_property_id      ON public.leases(property_id);

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_leases_tenant') THEN
    ALTER TABLE public.leases
      ADD CONSTRAINT fk_leases_tenant
      FOREIGN KEY (tenant_id) REFERENCES public.tenants(id) ON DELETE SET NULL;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_leases_unit') THEN
    ALTER TABLE public.leases
      ADD CONSTRAINT fk_leases_unit
      FOREIGN KEY (unit_id) REFERENCES public.units(id) ON DELETE SET NULL;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_leases_property') THEN
    ALTER TABLE public.leases
      ADD CONSTRAINT fk_leases_property
      FOREIGN KEY (property_id) REFERENCES public.properties(id) ON DELETE SET NULL;
  END IF;
END$$;

-- TENANTS
ALTER TABLE public.tenants
  ADD COLUMN IF NOT EXISTS doorloop_tenant_id text;
CREATE INDEX IF NOT EXISTS idx_tenants_doorloop_tenant_id ON public.tenants(doorloop_tenant_id);

-- OWNERS
ALTER TABLE public.owners
  ADD COLUMN IF NOT EXISTS doorloop_owner_id text;
CREATE INDEX IF NOT EXISTS idx_owners_doorloop_owner_id ON public.owners(doorloop_owner_id);


This does not drop anything and is safe on existing data. It only adds the keys our RPCs use for dual-key lookups.

5) Start & prove
npm run dev   # guardrail PASS first, then WEB+API

# Prove the API is live on 8787:
curl -s "http://localhost:8787/api/rpc/get_property_card?id=59" | jq '.kpis'

# Unit
curl -s "http://localhost:8787/api/rpc/get_unit_card?id=45"  | jq '{unit:.unit?.id, lease:.lease?.id}'

# Lease
curl -s "http://localhost:8787/api/rpc/get_lease_card?id=21" | jq '{lease:.lease?.id, unit:.unit?.id, tenant:.tenant?.id}'

# Owner
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=11" | jq '{owner:.owner?.id, kpis:.kpis}'

# Tenant
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=1" | jq '{tenant:.tenant?.id, active:.activeLease!=null}'


Open the same routes in the browser:

/card/property/59 (Avg Rent shows ‚Äú‚Äî‚Äù when no active leases)

/card/unit/45

/card/lease/21

/card/owner/11

/card/tenant/1

6) What not to do

Don‚Äôt ‚Äúunify ports.‚Äù Keep Vite 5173 + API 8787 with proxy.

Don‚Äôt add Drizzle right now. Supabase SQL patch above is all we need.

Don‚Äôt reintroduce masking (?? 0, || '‚Äî'). Guardrail will fail dev if that happens.

Outcome you should see

No more kpis.avgRentCents contract errors.

Unit/Lease cards resolve via id or DoorLoop ids once keys exist (Schema step 4).

All five RPCs return JSON with robust error handling.

Frontend stays fail-fast; it renders data when it exists and shows explicit errors when a record truly doesn‚Äôt.

When those curls show the keys, the cards will render. If one of the curls returns an error payload, paste that one JSON and I‚Äôll give you a one-file micro-patch.