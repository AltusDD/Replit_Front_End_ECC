MODE: MERGE/UPDATE (NON-DESTRUCTIVE) — DO NOT REPLACE APP OR TOUCH NAV/THEME

You are in “surgical merge” mode. Incorporate the Owner Transfer improvements into the current repo without breaking existing pages, routes, styles, or navigation. No mock data. Keep all existing behavior unless explicitly instructed below.

Guardrails (must follow)

❌ Do not edit or move the nav pane, main.tsx, app shell, or global styles.

❌ Do not change any dashboard code in this task.

✅ Use live Supabase + DoorLoop only.

✅ All work behind a clean service + API; UI integration is additive and optional.

✅ If a table doesn’t exist, skip that snapshot slice (no crashes).

0) Prep

Install server deps (idempotent):

npm i -E exceljs zod @supabase/supabase-js


Env (server only) — ensure the following exist (create placeholders if missing; do not commit secrets):

SUPABASE_URL

SUPABASE_SERVICE_ROLE_KEY

DOORLOOP_BASE_URL

DOORLOOP_API_KEY

OWNER_TRANSFER_REPORT_DEST=dropbox (or local)

DROPBOX_ACCESS_TOKEN (required if dropbox)

Schema check only (do not reapply migrations): verify the three tables exist with the exact column names:

public.owner_transfers (has status enum, created_at, etc.)

public.owner_transfer_snapshots (has raw_jsonb jsonb)

public.audit_events (has event_type text not null, created_at, payload jsonb, and no user_id/timestamp columns)

If any are missing, stop and print what’s missing; otherwise proceed.

1) Add/Update server libs (new files only, do not modify existing common libs)

Create these files (merge if they already exist; keep exports stable):

server/lib/supabaseAdmin.ts

import { createClient } from "@supabase/supabase-js";
const url = process.env.SUPABASE_URL!;
const key = process.env.SUPABASE_SERVICE_ROLE_KEY!;
export const supabaseAdmin = createClient(url, key, { auth: { persistSession: false, autoRefreshToken: false } });


server/lib/audit.ts

import { supabaseAdmin } from "./supabaseAdmin";
type Json = Record<string, any>;

export async function auditEvent(opts: {
  event_type: string;
  ref_table?: string | null;
  ref_id?: number | null;
  payload?: Json | null;
  actor_id?: string | null;
  tag?: string | null;
}) {
  const { event_type, ref_table = null, ref_id = null, payload = null, actor_id = null, tag = null } = opts;
  if (!event_type) throw new Error("auditEvent: event_type required");
  const { error } = await supabaseAdmin.from("audit_events").insert({ event_type, ref_table, ref_id, payload, actor_id, tag });
  if (error) console.error("auditEvent insert failed:", error);
}


server/lib/dropbox.ts

const UP = "https://content.dropboxapi.com/2/files/upload";
const SHARE = "https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings";

export async function uploadBufferToDropbox(params: { path: string; buffer: Buffer; mode?: "add"|"overwrite" }) {
  const token = process.env.DROPBOX_ACCESS_TOKEN;
  if (!token) throw new Error("DROPBOX_ACCESS_TOKEN not set");
  const arg = { path: params.path, mode: params.mode ?? "overwrite", mute: false, strict_conflict: false };

  const res = await fetch(UP, {
    method: "POST",
    headers: { "Authorization": `Bearer ${token}`, "Content-Type": "application/octet-stream", "Dropbox-API-Arg": JSON.stringify(arg) },
    body: params.buffer,
  });
  if (!res.ok) throw new Error(`Dropbox upload failed: ${res.status} ${await res.text().catch(()=> "")}`);

  const meta = await res.json();
  const share = await fetch(SHARE, {
    method: "POST",
    headers: { "Authorization": `Bearer ${token}`, "Content-Type": "application/json" },
    body: JSON.stringify({ path: meta.path_lower }),
  });

  let url: string | undefined;
  if (share.ok) {
    const s = await share.json();
    url = s?.url?.replace(/\?dl=0$/, "?dl=1");
  }
  return { path: params.path, url };
}

2) Owner Transfer service (new, safe to merge)

server/services/ownerTransferService.ts

Must be idempotent and tolerant of missing optional tables.

Do not throw on 42P01 (undefined_table) — treat as “slice unavailable”.

import { z } from "zod";
import ExcelJS from "exceljs";
import { supabaseAdmin } from "../lib/supabaseAdmin";
import { auditEvent } from "../lib/audit";
import { uploadBufferToDropbox } from "../lib/dropbox";

const InitiateSchema = z.object({
  propertyIds: z.array(z.number().int()).min(1),
  newOwnerId: z.number().int(),
  effectiveDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  notes: z.string().optional(),
  initiatedBy: z.string().uuid().optional(),
});
export type InitiateInput = z.infer<typeof InitiateSchema>;

// Helpers — skip missing tables
async function safeSelect<T=any>(table: string, col: string, values: readonly any[]) {
  try {
    const q = supabaseAdmin.from(table).select("*").in(col, values);
    // @ts-ignore
    const { data, error } = await q;
    if (error) {
      if ((error as any)?.code === "42P01") return []; // table missing
      throw error;
    }
    return data ?? [];
  } catch (e:any) {
    if (String(e?.message || "").includes("relation") && String(e?.message || "").includes("does not exist")) return [];
    throw e;
  }
}

export async function initiateTransfer(input: InitiateInput) {
  const parsed = InitiateSchema.parse(input);

  // Create transfer record (sets status = PENDING_ACCOUNTING)
  const { data, error } = await supabaseAdmin
    .from("owner_transfers")
    .insert({
      property_ids: parsed.propertyIds,
      old_owner_id: null,
      new_owner_id: parsed.newOwnerId,
      effective_date: parsed.effectiveDate,
      status: "PENDING_ACCOUNTING",
      notes: parsed.notes ?? null,
      initiated_by: parsed.initiatedBy ?? null,
    })
    .select("id")
    .single();
  if (error) throw error;
  const transferId = data.id as number;

  await auditEvent({ event_type: "OWNER_TRANSFER_INIT", ref_table: "owner_transfers", ref_id: transferId, payload: { input: parsed } });

  // infer old_owner_id from first property
  const first = await supabaseAdmin.from("properties").select("owner_id").eq("id", parsed.propertyIds[0]).single();
  if (!first.error && first.data) await supabaseAdmin.from("owner_transfers").update({ old_owner_id: first.data.owner_id }).eq("id", transferId);

  // Snapshots (skip slices that 404)
  const properties = await safeSelect("properties", "id", parsed.propertyIds);
  const units = await safeSelect("units", "property_id", parsed.propertyIds);
  const leases = await safeSelect("leases", "property_id", parsed.propertyIds);

  const tenantIds = Array.from(new Set(leases.map((l:any)=> l.primary_tenant_id).filter(Boolean)));
  const tenants = tenantIds.length ? await safeSelect("tenants", "id", tenantIds) : [];

  const leaseIds = Array.from(new Set(leases.map((l:any)=> l.id)));
  const lease_payments = leaseIds.length ? await safeSelect("lease_payments", "lease_id", leaseIds) : [];
  const lease_charges  = leaseIds.length ? await safeSelect("lease_charges", "lease_id", leaseIds)  : [];
  const lease_credits  = leaseIds.length ? await safeSelect("lease_credits", "lease_id", leaseIds)  : [];

  const work_orders    = await safeSelect("work_orders", "property_id", parsed.propertyIds);
  const communications = await safeSelect("communications", "property_id", parsed.propertyIds);
  const files          = await safeSelect("files", "property_id", parsed.propertyIds);
  const notes          = await safeSelect("notes", "property_id", parsed.propertyIds);

  const bundle = { properties, units, leases, tenants, lease_payments, lease_charges, lease_credits, work_orders, communications, files, notes };

  const rows:any[] = [];
  const push = (et:string, arr:any[], idKey="id") => arr.forEach(r => rows.push({ transfer_id: transferId, entity_type: et, entity_id: r?.[idKey] ?? 0, raw_jsonb: r }));
  Object.entries(bundle).forEach(([k,v]) => push(k.replace(/s$/,''), v as any[])); // ok to singularize-ish

  for (let i=0;i<rows.length;i+=500) {
    const slice = rows.slice(i, i+500);
    const { error: e } = await supabaseAdmin.from("owner_transfer_snapshots").insert(slice);
    if (e) throw e;
  }

  await auditEvent({
    event_type: "OWNER_TRANSFER_SNAPSHOT_DONE",
    ref_table: "owner_transfers",
    ref_id: transferId,
    payload: Object.fromEntries(Object.entries(bundle).map(([k,v])=>[k, (v as any[])?.length || 0])),
  });

  // Build report now to unblock accounting
  const rep = await generateAccountingReport(transferId);
  return { transferId, reportUrl: rep.reportUrl ?? null };
}

export async function generateAccountingReport(transferId: number) {
  const t = await supabaseAdmin.from("owner_transfers").select("*").eq("id", transferId).single();
  if (t.error) throw t.error;
  const transfer = t.data;

  const wb = new ExcelJS.Workbook();
  wb.creator = "ECC"; wb.created = new Date();
  const summary = wb.addWorksheet("Summary");
  summary.columns = [
    { header: "Transfer ID", key: "id" },
    { header: "Old Owner ID", key: "old_owner_id" },
    { header: "New Owner ID", key: "new_owner_id" },
    { header: "Effective Date", key: "effective_date" },
    { header: "Status", key: "status" },
  ];
  summary.addRow(transfer);

  // TODO: add Income/Expenses/Pending sheets by querying your accounting tables

  const buffer = Buffer.from(await wb.xlsx.writeBuffer());
  const filename = `owner_transfer_${transferId}.xlsx`;

  let reportUrl: string | undefined;
  if ((process.env.OWNER_TRANSFER_REPORT_DEST || "dropbox") === "dropbox") {
    const up = await uploadBufferToDropbox({ path: `/reports/owner_transfers/${filename}`, buffer });
    reportUrl = up.url;
  }

  await auditEvent({ event_type: "OWNER_TRANSFER_REPORT_BUILT", ref_table: "owner_transfers", ref_id: transferId, payload: { reportUrl: reportUrl || null, filename } });
  return { buffer, filename, reportUrl };
}

export async function markApprovedByAccounting(transferId: number, actorId?: string) {
  const { error } = await supabaseAdmin.from("owner_transfers").update({ status: "APPROVED_ACCOUNTING" }).eq("id", transferId);
  if (error) throw error;
  await auditEvent({ event_type: "OWNER_TRANSFER_APPROVE_ACCOUNTING", ref_table: "owner_transfers", ref_id: transferId, actor_id: actorId ?? null });
}

export async function authorizeExecution(transferId: number, actorId?: string) {
  const { error } = await supabaseAdmin.from("owner_transfers").update({ status: "READY_EXECUTION" }).eq("id", transferId);
  if (error) throw error;
  await auditEvent({ event_type: "OWNER_TRANSFER_AUTHORIZED", ref_table: "owner_transfers", ref_id: transferId, actor_id: actorId ?? null });
}

export async function executeTransfer(transferId: number, opts?: { dryRun?: boolean }) {
  const dryRun = opts?.dryRun !== false;

  const t = await supabaseAdmin.from("owner_transfers").select("*").eq("id", transferId).single();
  if (t.error) throw t.error;
  const transfer = t.data;

  const props = await supabaseAdmin.from("properties").select("id, owner_id").in("id", transfer.property_ids);
  if (props.error) throw props.error;
  const properties = props.data ?? [];

  const summary:any = { propertiesAffected: properties.length, dryRun, doorloopCalls: 0 };

  if (!dryRun) {
    const { error } = await supabaseAdmin.from("properties").update({ owner_id: transfer.new_owner_id }).in("id", transfer.property_ids);
    if (error) throw error;
  }

  if (!dryRun && process.env.DOORLOOP_API_KEY && process.env.DOORLOOP_BASE_URL) {
    const headers = {
      "Authorization": `Bearer ${process.env.DOORLOOP_API_KEY}`,
      "Content-Type": "application/json",
      "Idempotency-Key": `transfer-${transferId}-${transfer.effective_date}`,
    };
    for (const p of properties) {
      const url = `${process.env.DOORLOOP_BASE_URL}/properties/${p.id}`;
      const res = await fetch(url, { method: "PUT", headers, body: JSON.stringify({ ownerId: transfer.new_owner_id }) });
      await auditEvent({ event_type: "OWNER_TRANSFER_WRITEBACK", ref_table: "properties", ref_id: p.id, payload: { status: res.status } });
      summary.doorloopCalls++;
      if (!res.ok) throw new Error(`DoorLoop property update failed: ${res.status} ${await res.text().catch(()=> "")}`);
    }
  }

  if (!dryRun) {
    const { error } = await supabaseAdmin.from("owner_transfers").update({ status: "COMPLETE", executed_at: new Date().toISOString() }).eq("id", transferId);
    if (error) throw error;
    await auditEvent({ event_type: "OWNER_TRANSFER_COMPLETE", ref_table: "owner_transfers", ref_id: transferId, payload: summary });
  }

  return { applied: !dryRun, summary };
}

3) Add routes to existing server (do not break existing app/router)

In server/index.ts, register these routes without changing existing endpoints. If the file exports the app differently, adapt—but keep behavior.

import express from "express";
import {
  initiateTransfer, generateAccountingReport,
  markApprovedByAccounting, authorizeExecution, executeTransfer
} from "./services/ownerTransferService";

const app = (global as any).app || express(); // reuse existing
app.use(express.json());

function isAdmin(req:any){ return Boolean(req?.user?.isAdmin); }

app.post("/api/owner-transfer/initiate", async (req,res)=>{
  try {
    const out = await initiateTransfer(req.body);
    res.status(201).json(out);
  } catch(e:any){ res.status(400).json({ error: e.message }); }
});
app.post("/api/owner-transfer/approve-accounting", async (req,res)=>{
  try { const { transferId } = req.body; await markApprovedByAccounting(transferId, req.user?.id); res.json({ ok:true }); }
  catch(e:any){ res.status(400).json({ error: e.message }); }
});
app.post("/api/owner-transfer/authorize", async (req,res)=>{
  try { if(!isAdmin(req)) return res.status(403).json({ error:"forbidden" });
    const { transferId } = req.body; await authorizeExecution(transferId, req.user?.id); res.json({ ok:true }); }
  catch(e:any){ res.status(400).json({ error: e.message }); }
});
app.post("/api/owner-transfer/execute", async (req,res)=>{
  try { if(!isAdmin(req)) return res.status(403).json({ error:"forbidden" });
    const { transferId, dryRun=true } = req.body; const out = await executeTransfer(transferId, { dryRun }); res.json(out); }
  catch(e:any){ res.status(400).json({ error: e.message }); }
});
app.get("/api/owner-transfer/:id/report", async (req,res)=>{
  try { const id = Number(req.params.id); const { buffer, filename } = await generateAccountingReport(id);
    res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
    res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    res.send(buffer);
  } catch(e:any){ res.status(404).json({ error: e.message }); }
});

export default app;

4) (Optional) Frontend hook + stepper (additive, no nav changes)

Create:

src/features/ownerTransfer/hooks/useOwnerTransfer.ts

import { useCallback } from "react";
type Json = Record<string, any>;
async function postJSON<T>(url:string, body:Json){ const r=await fetch(url,{method:"POST",headers:{ "Content-Type":"application/json"},body:JSON.stringify(body)}); if(!r.ok) throw new Error(await r.text()); return r.json() as Promise<T>; }
export function useOwnerTransfer(){
  const initiate = useCallback((b:{propertyIds:number[];newOwnerId:number;effectiveDate:string;notes?:string;initiatedBy?:string;})=>postJSON<{transferId:number;reportUrl:string|null}>("/api/owner-transfer/initiate",b),[]);
  const approveAccounting=useCallback((transferId:number)=>postJSON<{ok:true}>("/api/owner-transfer/approve-accounting",{transferId}),[]);
  const authorize=useCallback((transferId:number)=>postJSON<{ok:true}>("/api/owner-transfer/authorize",{transferId}),[]);
  const execute=useCallback((transferId:number,dryRun=true)=>postJSON<{applied:boolean;summary:any}>("/api/owner-transfer/execute",{transferId,dryRun}),[]);
  const reportUrl=(id:number)=>`/api/owner-transfer/${id}/report`;
  return { initiate, approveAccounting, authorize, execute, reportUrl };
}


src/features/ownerTransfer/components/TransferStepper.tsx
(Use the component I provided earlier; keep styles; do not bind it to nav. You can mount it from the Owner Hub left-rail action without changing the nav structure.)

5) QA / Acceptance

Run these to verify (print JSON, don’t rely on UI):

# 1) Initiate (should create snapshots + report)
curl -s -X POST /api/owner-transfer/initiate \
 -H 'Content-Type: application/json' \
 -d '{"propertyIds":[160,161],"newOwnerId":421,"effectiveDate":"2025-09-15"}'

# 2) Approve accounting
curl -s -X POST /api/owner-transfer/approve-accounting \
 -H 'Content-Type: application/json' \
 -d '{"transferId": 1}'

# 3) Authorize (admin)
curl -s -X POST /api/owner-transfer/authorize \
 -H 'Content-Type: application/json' \
 -d '{"transferId": 1}'

# 4) Execute dry-run (default true)
curl -s -X POST /api/owner-transfer/execute \
 -H 'Content-Type: application/json' \
 -d '{"transferId": 1, "dryRun": true}'


Pass criteria

owner_transfers row created; status flows PENDING_ACCOUNTING → APPROVED_ACCOUNTING → READY_EXECUTION → (on commit) COMPLETE.

owner_transfer_snapshots has rows for each available slice; missing optional tables do not error.

audit_events contains OWNER_TRANSFER_* entries.

If OWNER_TRANSFER_REPORT_DEST=dropbox and token is valid, response includes reportUrl. Otherwise GET /api/owner-transfer/:id/report downloads the Excel.

No changes to navigation or theme.

Commit message to use:

feat(owner-transfer): non-destructive merge of backend service, routes, audit + dropbox; optional UI hook/stepper; schema-safe snapshots; no nav/theme changes


If anything you need to overwrite conflicts, open a diff and prefer merging without moving existing files.