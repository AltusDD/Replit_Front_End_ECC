PROMPT FOR REPLIT (CHAT MODE)

Task: ECC “Resolver Fix Pack” — restore live data on all asset cards without changing layouts.
Follow exactly. No placeholders, no guesses. Do not add or remove hooks dynamically; only use enabled: flags.

0) Ground rules (do first)

Keep hook order constant. Never wrap hooks in conditionals. Use enabled: !!cond.

Source of truth for reads is our entities API (PostgREST style filters). No /portfolio/* endpoints in card pages.

Return zero or one entity from “single by id” queries (PostgREST returns arrays). Implement a shared first() helper.

Never return null layout. The existing ErrorBoundary stays; cards must always render their sections.

1) Create/replace shared resolvers

File: src/lib/ecc-card-resolvers.ts (create if missing; otherwise fully replace exported hooks below)

import { useQuery } from '@tanstack/react-query';
import { apiGet } from '../lib/ecc-api'; // existing wrapper
type Id = string | number;

function first<T>(x: T[] | T | null | undefined): T | null {
  if (Array.isArray(x)) return x.length ? (x[0] as T) : null;
  return (x ?? null) as T | null;
}

// ---------------- PROPERTY ----------------
export function usePropertyCardData(id: Id) {
  // 1) base property by id
  const propertyQ = useQuery({
    queryKey: ['property', id],
    queryFn: async () => {
      const rows = await apiGet(`/entities/properties?id=eq.${id}`);
      return first(rows);
    },
    staleTime: 60_000,
  });

  // 2) units by doorloop_property_id
  const unitsQ = useQuery({
    queryKey: ['unitsByPropertyDoorloop', propertyQ.data?.doorloop_id ?? null],
    queryFn: async () => {
      const rows = await apiGet(
        `/entities/units?doorloop_property_id=eq.${propertyQ.data!.doorloop_id}`
      );
      return rows ?? [];
    },
    enabled: !!propertyQ.data?.doorloop_id,
    staleTime: 60_000,
  });

  // 3) leases by property_id
  const leasesQ = useQuery({
    queryKey: ['leasesByProperty', propertyQ.data?.id ?? null],
    queryFn: async () => {
      const rows = await apiGet(
        `/entities/leases?property_id=eq.${propertyQ.data!.id}`
      );
      return rows ?? [];
    },
    enabled: !!propertyQ.data?.id,
    staleTime: 60_000,
  });

  // 4) owner (nullable; modeled later)
  const ownerQ = { data: null, isLoading: false, error: null as any };

  const isLoading = propertyQ.isLoading || unitsQ.isLoading || leasesQ.isLoading;
  const error = propertyQ.error ?? unitsQ.error ?? leasesQ.error ?? null;

  return {
    property: propertyQ.data ?? null,
    units: unitsQ.data ?? [],
    leases: leasesQ.data ?? [],
    owner: ownerQ.data,
    isLoading,
    error,
  };
}

// ---------------- UNIT ----------------
export function useUnitCardData(id: Id) {
  const unitQ = useQuery({
    queryKey: ['unit', id],
    queryFn: async () => {
      const rows = await apiGet(`/entities/units?id=eq.${id}`);
      return first(rows);
    },
    staleTime: 60_000,
  });

  const propertyQ = useQuery({
    queryKey: ['propertyByDoorloop', unitQ.data?.doorloop_property_id ?? null],
    queryFn: async () => {
      const rows = await apiGet(
        `/entities/properties?doorloop_id=eq.${unitQ.data!.doorloop_property_id}`
      );
      return first(rows);
    },
    enabled: !!unitQ.data?.doorloop_property_id,
    staleTime: 60_000,
  });

  const leaseQ = useQuery({
    queryKey: ['activeLeaseByUnit', unitQ.data?.id ?? null],
    queryFn: async () => {
      const rows = await apiGet(
        `/entities/leases?unit_id=eq.${unitQ.data!.id}&status=eq.active&limit=1`
      );
      return first(rows);
    },
    enabled: !!unitQ.data?.id,
    staleTime: 30_000,
  });

  const tenantQ = useQuery({
    queryKey: ['primaryTenantByLease', leaseQ.data?.primary_tenant_id ?? null],
    queryFn: async () => {
      const rows = await apiGet(
        `/entities/tenants?id=eq.${leaseQ.data!.primary_tenant_id}`
      );
      return first(rows);
    },
    enabled: !!leaseQ.data?.primary_tenant_id,
    staleTime: 30_000,
  });

  const isLoading =
    unitQ.isLoading || propertyQ.isLoading || leaseQ.isLoading || tenantQ.isLoading;
  const error = unitQ.error ?? propertyQ.error ?? leaseQ.error ?? tenantQ.error ?? null;

  return {
    unit: unitQ.data ?? null,
    property: propertyQ.data ?? null,
    activeLease: leaseQ.data ?? null,
    primaryTenant: tenantQ.data ?? null,
    isLoading,
    error,
  };
}

// ---------------- LEASE ----------------
export function useLeaseCardData(id: Id) {
  const leaseQ = useQuery({
    queryKey: ['lease', id],
    queryFn: async () => {
      const rows = await apiGet(`/entities/leases?id=eq.${id}`);
      return first(rows);
    },
    staleTime: 60_000,
  });

  const propertyQ = useQuery({
    queryKey: ['leaseProperty', leaseQ.data?.property_id ?? null],
    queryFn: async () => {
      const rows = await apiGet(`/entities/properties?id=eq.${leaseQ.data!.property_id}`);
      return first(rows);
    },
    enabled: !!leaseQ.data?.property_id,
  });

  const unitQ = useQuery({
    queryKey: ['leaseUnit', leaseQ.data?.unit_id ?? null],
    queryFn: async () => {
      const rows = await apiGet(`/entities/units?id=eq.${leaseQ.data!.unit_id}`);
      return first(rows);
    },
    enabled: !!leaseQ.data?.unit_id,
  });

  const tenantQ = useQuery({
    queryKey: ['leaseTenant', leaseQ.data?.primary_tenant_id ?? null],
    queryFn: async () => {
      const rows = await apiGet(
        `/entities/tenants?id=eq.${leaseQ.data!.primary_tenant_id}`
      );
      return first(rows);
    },
    enabled: !!leaseQ.data?.primary_tenant_id,
  });

  const isLoading = leaseQ.isLoading || propertyQ.isLoading || unitQ.isLoading || tenantQ.isLoading;
  const error = leaseQ.error ?? propertyQ.error ?? unitQ.error ?? tenantQ.error ?? null;

  return {
    lease: leaseQ.data ?? null,
    property: propertyQ.data ?? null,
    unit: unitQ.data ?? null,
    tenant: tenantQ.data ?? null,
    isLoading,
    error,
  };
}

// ---------------- TENANT ----------------
export function useTenantCardData(id: Id) {
  const tenantQ = useQuery({
    queryKey: ['tenant', id],
    queryFn: async () => {
      const rows = await apiGet(`/entities/tenants?id=eq.${id}`);
      return first(rows);
    },
    staleTime: 60_000,
  });

  const leasesQ = useQuery({
    queryKey: ['leasesByTenant', tenantQ.data?.id ?? null],
    queryFn: async () => {
      const rows = await apiGet(`/entities/leases?primary_tenant_id=eq.${tenantQ.data!.id}`);
      return rows ?? [];
    },
    enabled: !!tenantQ.data?.id,
    staleTime: 60_000,
  });

  const isLoading = tenantQ.isLoading || leasesQ.isLoading;
  const error = tenantQ.error ?? leasesQ.error ?? null;

  return {
    tenant: tenantQ.data ?? null,
    leases: leasesQ.data ?? [],
    isLoading,
    error,
  };
}

// ---------------- OWNER ----------------
export function useOwnerCardData(id: Id) {
  const ownerQ = useQuery({
    queryKey: ['owner', id],
    queryFn: async () => {
      const rows = await apiGet(`/entities/owners?id=eq.${id}`);
      return first(rows);
    },
    staleTime: 60_000,
  });

  const propertiesQ = useQuery({
    queryKey: ['propertiesByOwner', ownerQ.data?.id ?? null],
    queryFn: async () => {
      const rows = await apiGet(`/entities/properties?owner_id=eq.${ownerQ.data!.id}`);
      return rows ?? [];
    },
    enabled: !!ownerQ.data?.id,
    staleTime: 60_000,
  });

  const isLoading = ownerQ.isLoading || propertiesQ.isLoading;
  const error = ownerQ.error ?? propertiesQ.error ?? null;

  return {
    owner: ownerQ.data ?? null,
    properties: propertiesQ.data ?? [],
    isLoading,
    error,
  };
}

2) Wire cards to the new resolvers (import + destructure)

For each page below, replace the resolver import & destructuring to match the new hooks above. Do not change JSX layout.

Property: src/pages/card/property/index.tsx

import { usePropertyCardData } from '../../../lib/ecc-card-resolvers';
// ...
const { property, units, leases, owner, isLoading, error } = usePropertyCardData(id);


Unit: src/pages/card/unit/index.tsx

import { useUnitCardData } from '../../../lib/ecc-card-resolvers';
const { unit, property, activeLease, primaryTenant, isLoading, error } = useUnitCardData(id);


Lease: src/pages/card/lease/index.tsx

import { useLeaseCardData } from '../../../lib/ecc-card-resolvers';
const { lease, property, unit, tenant, isLoading, error } = useLeaseCardData(id);


Tenant: src/pages/card/tenant/index.tsx

import { useTenantCardData } from '../../../lib/ecc-card-resolvers';
const { tenant, leases, isLoading, error } = useTenantCardData(id);


Owner: src/pages/card/owner/index.tsx

import { useOwnerCardData } from '../../../lib/ecc-card-resolvers';
const { owner, properties, isLoading, error } = useOwnerCardData(id);


Keep all hook calls top-level; do not guard with if.

3) Map values into existing sections (no UI rework)

Property: show property.type, property.property_class, property.status, property.doorloop_id, owner?.name ?? '—'.

Relationships: units.length, leases.length (and render unit rows if that UI exists).

Unit: show unit.status, unit.beds, unit.baths, unit.square_feet, unit.market_rent_cents (format).

Lease: status/rent/term from lease.* and links to property/unit/tenant.

Tenant: identity + leases list.

Owner: name + properties.length.

(Use our existing humanize/titleCase/money helpers already in the file set; no new helpers.)

4) Dev console sanity (dev only)

Add this once per page, just under the resolver call, guarded so it compiles out:

if (import.meta.env.DEV) {
  // eslint-disable-next-line no-console
  console.table({ entity: 'PropertyCard', id, hasProperty: !!property, units: units?.length, leases: leases?.length, error: !!error });
}


(Adjust the labels per card.)

5) Verification

Reload the following routes and confirm data appears (no hook-order error, no blank screens):

/card/property/55, /card/unit/45, /card/lease/25, /card/tenant/1, /card/owner/1

In each page, the header KPIs and sections must show real values (not “—”) where data exists.

npm run guardrail:mega and npm run guardrail:overlays must remain green.

npx tsc -p tsconfig.cards.json must be 0 errors.

End of task.

If Replit still returns “—” after this, it means the API really returned empty arrays. In that case, the console tables added in step 4 will confirm which filter is wrong (e.g., doorloop_id vs doorloop_property_id), and we’ll do a tiny follow-up patch to adjust that one column name.