PROMPT FOR REPLIT — “ECC Cards: Deterministic IDs + Final Verification”

You are the Build Agent. Finish Step 5. Do NOT change ports, build scripts, or any files other than the ones below. Stop on the first error and print it.

0) Guardrails

Web on 5173, API on 8787.

Touch only: server/index.ts, server/routes/rpc.ts.

No UI masking changes. No schema changes. Cards only.

1) Add a tiny IDs diagnostic (so we only hit existing rows)

Option A (preferred): If server/routes/rpc.ts already has access to the Supabase client, add this route at the bottom (above export default rpc):

rpc.get("/diag/ids", async (_req, res) => {
  try {
    const take = 5;

    const pick = async (table: string) => {
      const { data, error } = await supabase.from(table).select("id").limit(take);
      if (error) throw error;
      return data?.map((r: any) => r.id) ?? [];
    };

    const [properties, units, leases, owners, tenants] = await Promise.all([
      pick("properties"),
      pick("units"),
      pick("leases"),
      pick("owners"),
      pick("tenants"),
    ]);

    res.json({ properties, units, leases, owners, tenants });
  } catch (e: any) {
    res.status(500).json({ error: String(e?.message || e) });
  }
});


Option B: If Supabase isn’t in rpc.ts, add this read-only diag to server/index.ts where you create the client:

app.get("/api/diag/ids", async (_req, res) => {
  try {
    const take = 5;
    const pick = async (table: string) => {
      const { data, error } = await supabase.from(table).select("id").limit(take);
      if (error) throw error;
      return data?.map((r: any) => r.id) ?? [];
    };
    const [properties, units, leases, owners, tenants] = await Promise.all([
      pick("properties"),
      pick("units"),
      pick("leases"),
      pick("owners"),
      pick("tenants"),
    ]);
    res.json({ properties, units, leases, owners, tenants });
  } catch (e: any) {
    res.status(500).json({ error: String(e?.message || e) });
  }
});


Result: GET /api/rpc/diag/ids (Option A) or GET /api/diag/ids (Option B) returns real IDs to test with in this exact environment—no guessing.

2) Run API alone and confirm
pkill -f "tsx server/index.ts" || true
pkill -f vite || true
rm -rf .vite node_modules/.vite dist .cache .parcel-cache 2>/dev/null || true

npm run dev:api || pnpm run dev:api || npx tsx server/index.ts


Expected console:

[EnvLock] { … }

[Dev API] Listening on :8787

If it crashes, STOP and print the full stack trace.

3) Discover valid IDs for this database

(Use the right path based on where you added the diag route.)

curl -s http://localhost:8787/api/rpc/diag/ids || curl -s http://localhost:8787/api/diag/ids


Note the first ID from each array; we’ll use those for the five RPC checks.

If any array is empty, print which table is empty and STOP (that’s a data seed issue, not a code issue).

4) Final RPC checks (use the discovered IDs)

Replace P, U, L, O, T with existing IDs from the previous step.

curl -s "http://localhost:8787/api/rpc/get_property_card?id=P" | jq '{hasProperty: (.property!=null), kpis: .kpis}'
curl -s "http://localhost:8787/api/rpc/get_unit_card?id=U"      | jq '{hasUnit: (.unit!=null), lease:.lease?.id, tenant:.tenant?.id}'
curl -s "http://localhost:8787/api/rpc/get_lease_card?id=L"     | jq '{hasLease: (.lease!=null), unit:.unit?.id, tenant:.tenant?.id}'
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=O"     | jq '{hasOwner: (.owner!=null), props:(.properties|length)}'
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=T"    | jq '{hasTenant: (.tenant!=null), active:.activeLease!=null}'


Rules:

If any returns {hasX: false}, STOP and print that response—do not “fix” by masking. That means the record truly doesn’t exist or the relationship is missing.

If all are truthy, proceed.

5) Full dev and browser verification
npm run dev


Open these paths (replace with the same IDs you just used):

/card/property/P → KPIs + address visible (no contract error)

/card/unit/U → unit + property + (lease/tenant if present)

/card/lease/L → lease + unit + property + tenant

/card/owner/O → owner + portfolio KPIs

/card/tenant/T → tenant + active lease (if any)

6) Deliverables (print these and you’re done)

Output of /api/diag/env and /api/(rpc/)diag/ids.

The 5 RPC JSON snippets from step 4.

If any hasX:false, print which table is empty/missing the ID so we can seed or map correctly—no code changes for that case.

End of prompt.