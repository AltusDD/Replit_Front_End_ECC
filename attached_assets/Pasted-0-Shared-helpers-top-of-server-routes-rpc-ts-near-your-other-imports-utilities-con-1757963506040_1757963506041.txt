0) Shared helpers (top of server/routes/rpc.ts, near your other imports/utilities)
// ---------- contract-safe helpers ----------
const firstString = (...vals: any[]) =>
  vals.find(v => typeof v === 'string' && v.trim().length > 0) ?? 'UNKNOWN';

const toCents = (v: any) => {
  const n = Number(v);
  return Number.isFinite(n) ? Math.round(n * 100) : null;
};

const normStatus = (s?: string | null) =>
  (s ?? '').toLowerCase().replace(/\s+/g, '_');

// id → row; fallbacks try doorloop keys; throws if not found
async function fetchOneMulti(
  sb: any,
  table: string,
  id: number | string,
  altKeys: string[] = []
) {
  let { data } = await sb.from(table).select('*').eq('id', id).maybeSingle();
  if (!data && altKeys.length) {
    for (const k of altKeys) {
      const { data: alt } = await sb.from(table).select('*').eq(k, String(id)).maybeSingle();
      if (alt) { data = alt; break; }
    }
  }
  if (!data) throw new Error(`[NOT_FOUND] ${table} ${id}`);
  return data;
}

1) Property card — guarantee property.type and KPIs

Replace your existing /get_property_card with:

rpc.get('/get_property_card', async (req, res) => {
  try {
    const id = Number(req.query.id);
    if (!Number.isFinite(id)) throw new Error('[CONTRACT] id must be a number');

    const property = await fetchOneMulti(
      supabase, 'properties', id,
      ['doorloop_id','doorloop_property_id']
    );

    // Contract: property.type MUST be present & non-empty
    const type = firstString(
      property.type,
      property.property_type,
      property.asset_type,
      property.category,
      property.classification,
      property.use_type,
      property.doorloop_property_type
    );

    const { data: units = [] }  = await supabase.from('units').select('*').eq('property_id', property.id);
    const { data: leases = [] } = await supabase.from('leases').select('*').eq('property_id', property.id);

    const active = leases.filter(l => normStatus(l.status) === 'active');
    const occupancyPct = units.length ? Math.round((active.length / units.length) * 1000) / 10 : 0;
    const avgRentCents = active.length
      ? Math.round(active.reduce((s,l) => s + (toCents(l.rent) ?? l.rent_cents ?? 0), 0) / active.length)
      : null;

    res.json({
      property: { ...property, type },
      kpis: { units: units.length, activeLeases: active.length, occupancyPct, avgRentCents }
    });
  } catch (e:any) {
    res.status(400).json({ error: String(e?.message ?? e) });
  }
});

2) Unit card — always return unit (+ relationships & KPIs)

Replace /get_unit_card with:

rpc.get('/get_unit_card', async (req, res) => {
  try {
    const id = Number(req.query.id);
    if (!Number.isFinite(id)) throw new Error('[CONTRACT] id must be a number');

    const unit = await fetchOneMulti(
      supabase, 'units', id,
      ['doorloop_id','doorloop_unit_id']
    );

    // Property relationship
    let property = null as any;
    const propId = unit.property_id ?? unit.propertyId ?? null;
    if (propId) {
      property = await fetchOneMulti(
        supabase, 'properties', propId, ['doorloop_id','doorloop_property_id']
      );
    }

    // Current lease: prefer active by unit_id
    const { data: leases = [] } = await supabase
      .from('leases').select('*').eq('unit_id', unit.id);

    const active = leases.find(l => normStatus(l.status) === 'active') ?? null;

    // KPIs the UI expects in hero
    const kpis = {
      leaseStatus: normStatus(active?.status) || 'vacant',
      rentCents: (toCents(active?.rent) ?? active?.rent_cents ?? toCents(unit.market_rent) ?? toCents(unit.rent) ?? null),
      beds: Number.isFinite(Number(unit.beds)) ? Number(unit.beds) : null,
      baths: Number.isFinite(Number(unit.baths)) ? Number(unit.baths) : null,
      sqft: Number.isFinite(Number(unit.sqft)) ? Number(unit.sqft) : null,
    };

    res.json({ unit, property, lease: active, kpis });
  } catch (e:any) {
    res.status(400).json({ error: String(e?.message ?? e) });
  }
});

3) Lease card — always return lease (+ relationships & KPIs)

Replace /get_lease_card with:

rpc.get('/get_lease_card', async (req, res) => {
  try {
    const id = Number(req.query.id);
    if (!Number.isFinite(id)) throw new Error('[CONTRACT] id must be a number');

    const lease = await fetchOneMulti(
      supabase, 'leases', id,
      ['doorloop_id','doorloop_lease_id']
    );

    const unit = lease.unit_id
      ? await fetchOneMulti(supabase, 'units', lease.unit_id, ['doorloop_id','doorloop_unit_id'])
      : null;

    const propertyId = lease.property_id ?? unit?.property_id ?? null;
    const property = propertyId
      ? await fetchOneMulti(supabase, 'properties', propertyId, ['doorloop_id','doorloop_property_id'])
      : null;

    const tenantId = lease.tenant_id ?? lease.primary_tenant_id ?? null;
    const tenant = tenantId
      ? await fetchOneMulti(supabase, 'tenants', tenantId, ['doorloop_tenant_id','doorloop_id'])
      : null;

    const kpis = {
      status: normStatus(lease.status),
      rentCents: toCents(lease.rent) ?? lease.rent_cents ?? null,
      balanceCents:
        toCents(lease.balance_due) ??
        toCents(lease.totalBalanceDue) ??
        lease.outstanding_balance_cents ??
        null,
    };

    res.json({ lease, unit, property, tenant, kpis });
  } catch (e:any) {
    res.status(400).json({ error: String(e?.message ?? e) });
  }
});

4) Tenant card — always return tenant (+ relationships & KPIs)

Replace /get_tenant_card with:

rpc.get('/get_tenant_card', async (req, res) => {
  try {
    const id = Number(req.query.id);
    if (!Number.isFinite(id)) throw new Error('[CONTRACT] id must be a number');

    const tenant = await fetchOneMulti(
      supabase, 'tenants', id,
      ['doorloop_tenant_id','doorloop_id']
    );

    // Find leases by direct FK or tenants array containment
    let activeLease: any = null;
    {
      const { data: byFk = [] } = await supabase
        .from('leases').select('*').eq('tenant_id', tenant.id);
      const { data: byArray = [] } = await supabase
        .from('leases').select('*').contains('tenants', [String(tenant.id)]);
      const all = [...byFk, ...byArray];
      activeLease = all.find(l => normStatus(l.status) === 'active') ?? null;
    }

    // Resolve property via lease → unit → property if we can
    let property = null as any;
    if (activeLease?.unit_id) {
      const unit = await fetchOneMulti(supabase, 'units', activeLease.unit_id, ['doorloop_id','doorloop_unit_id']);
      if (unit?.property_id) {
        property = await fetchOneMulti(supabase, 'properties', unit.property_id, ['doorloop_id','doorloop_property_id']);
      }
    }

    // KPIs commonly shown on Tenant hero
    const { data: allLeases = [] } = await supabase
      .from('leases').select('*').or(`tenant_id.eq.${tenant.id},tenants.cs.{${tenant.id}}`);
    const activeCount = allLeases.filter(l => normStatus(l.status) === 'active').length;

    const kpis = {
      activeLeases: activeCount,
      currentBalanceCents:
        toCents(activeLease?.balance_due) ??
        toCents(activeLease?.totalBalanceDue) ??
        activeLease?.outstanding_balance_cents ??
        null,
      onTimeRatePct: null,       // unknown from DB; null is acceptable
      openWorkorders: 0,         // unknown here; 0 default (explicit)
    };

    res.json({ tenant, activeLease, property, kpis });
  } catch (e:any) {
    res.status(400).json({ error: String(e?.message ?? e) });
  }
});

5) Owner card — always return owner (+ portfolio KPIs)

Replace /get_owner_card with:

rpc.get('/get_owner_card', async (req, res) => {
  try {
    const id = Number(req.query.id);
    if (!Number.isFinite(id)) throw new Error('[CONTRACT] id must be a number');

    const owner = await fetchOneMulti(
      supabase, 'owners', id,
      ['doorloop_owner_id','doorloop_id']
    );

    // Collect properties by FK if present; optionally fall back to doorloop_owner_id
    let { data: properties = [] } = await supabase
      .from('properties').select('*').eq('owner_id', owner.id);

    if (!properties?.length && owner.doorloop_owner_id) {
      const { data: props2 = [] } = await supabase
        .from('properties').select('*').eq('doorloop_owner_id', String(owner.doorloop_owner_id));
      properties = props2;
    }

    const propIds = properties.map(p => p.id);
    const { data: units = [] }  = propIds.length
      ? await supabase.from('units').select('*').in('property_id', propIds)
      : { data: [] as any[] };
    const { data: leases = [] } = propIds.length
      ? await supabase.from('leases').select('*').in('property_id', propIds)
      : { data: [] as any[] };

    const active = leases.filter(l => normStatus(l.status) === 'active');
    const occupancyPct = units.length ? Math.round((active.length / units.length) * 1000) / 10 : 0;
    const avgRentCents = active.length
      ? Math.round(active.reduce((s,l) => s + (toCents(l.rent) ?? l.rent_cents ?? 0), 0) / active.length)
      : null;

    const kpis = {
      portfolioUnits: units.length,
      activeLeases: active.length,
      occupancyPct,
      avgRentCents
    };

    res.json({ owner, properties, kpis });
  } catch (e:any) {
    res.status(400).json({ error: String(e?.message ?? e) });
  }
});

6) Quick server-side smoke tests (run these in the Replit Shell)
# Property (must include property.type and kpis)
curl -s http://localhost:8787/api/rpc/get_property_card?id=42 \
| node -e "process.stdin.on('data',b=>{const j=JSON.parse(b);console.log({ok:!!j.property, type:j.property?.type, kpis:!!j.kpis})})"

# Unit (must include unit + kpis)
curl -s http://localhost:8787/api/rpc/get_unit_card?id=45 \
| node -e "process.stdin.on('data',b=>{const j=JSON.parse(b);console.log({ok:!!j.unit, kpis:!!j.kpis})})"

# Lease (must include lease + kpis)
curl -s http://localhost:8787/api/rpc/get_lease_card?id=1 \
| node -e "process.stdin.on('data',b=>{const j=JSON.parse(b);console.log({ok:!!j.lease, kpis:!!j.kpis})})"

# Tenant (must include tenant + kpis)
curl -s http://localhost:8787/api/rpc/get_tenant_card?id=3 \
| node -e "process.stdin.on('data',b=>{const j=JSON.parse(b);console.log({ok:!!j.tenant, kpis:!!j.kpis})})"

# Owner (must include owner + kpis)
curl -s http://localhost:8787/api/rpc/get_owner_card?id=11 \
| node -e "process.stdin.on('data',b=>{const j=JSON.parse(b);console.log({ok:!!j.owner, kpis:!!j.kpis})})"


You should see { ok: true, … } for each. If any returns an error JSON, the card will fail with your fail-fast boundary—fix in place before refreshing the UI.

What this delivers

Every RPC returns the exact top-level field the card requires: property, unit, lease, tenant, owner.

KPIs are present for each card so the HeroBlocks render without client calculations.

Dual-key lookups (DB id → DoorLoop keys) ensure we find rows even when FKs are sparse.

No masking: missing rows throw a JSON error (caught by your boundary), not “0s and dashes.”

Apply these patches and refresh the card routes. If a specific ID still fails after this, it’s almost certainly a true data miss (not code) and the JSON error body will say exactly which table/id could not be found.