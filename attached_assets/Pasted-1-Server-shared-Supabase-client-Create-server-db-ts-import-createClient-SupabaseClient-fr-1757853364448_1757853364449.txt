1) Server — shared Supabase client

Create: server/db.ts

import { createClient, SupabaseClient } from '@supabase/supabase-js';

const url =
  process.env.SUPABASE_URL ||
  process.env.SUPABASE_API_URL;

const serviceKey =
  process.env.SUPABASE_SERVICE_ROLE_KEY ||
  process.env.SUPABASE_SERVICE_KEY ||
  process.env.SUPABASE_KEY ||
  process.env.SUPABASE_SECRET;

if (!url) throw new Error('SUPABASE_URL missing');
if (!serviceKey) throw new Error('SUPABASE_SERVICE_ROLE_KEY (or alias) missing');

export const supabase: SupabaseClient = createClient(url, serviceKey, {
  auth: { persistSession: false, autoRefreshToken: false },
  global: { headers: { 'x-ecc-api': 'rpc' } },
});

2) Server — entities (raw JSON + simple filters)

Replace contents: server/routes/entities.ts

import { Router } from 'express';
import { supabase } from '../db';

export const entities = Router();

// GET /api/entities/:table/:id
entities.get('/:table/:id', async (req, res) => {
  const ctrl = new AbortController();
  req.on('close', () => ctrl.abort());

  const { table, id } = req.params;
  const { data, error } = await supabase.from(table).select('*').eq('id', id).single();

  if (error || !data) return res.status(404).json({ error: 'not found', table, id });
  res.json(data); // RAW object (no wrapper)
});

// GET /api/entities/:table?field=eq.<value>
entities.get('/:table', async (req, res) => {
  const ctrl = new AbortController();
  req.on('close', () => ctrl.abort());

  const { table } = req.params;
  let query = supabase.from(table).select('*');

  // very small filter grammar: ?foo=eq.<v>&bar=eq.<v2>
  for (const [k, v] of Object.entries(req.query)) {
    const s = String(v);
    if (s.startsWith('eq.')) query = query.eq(k, s.slice(3));
    // extend here if you need: in.(a,b), like.xyz, etc.
  }

  const { data, error } = await query;
  if (error) return res.status(400).json({ error: error.message });
  res.json(data ?? []); // RAW array
});

3) Server — RPC endpoints (join on DB PKs)

Replace contents: server/routes/rpc.ts

import { Router } from 'express';
import { supabase } from '../db';

export const rpc = Router();

// GET /api/rpc/get_property_card?id=42
rpc.get('/get_property_card', async (req, res) => {
  const ctrl = new AbortController();
  req.on('close', () => ctrl.abort());

  const id = Number(req.query.id);
  if (!Number.isFinite(id)) return res.status(400).json({ error: 'id required' });

  const { data: property, error: pErr } = await supabase
    .from('properties')
    .select('*')
    .eq('id', id)
    .single();

  if (pErr || !property) return res.status(404).json({ error: 'property not found', id });

  const [{ data: units }, { data: leases }] = await Promise.all([
    supabase.from('units').select('*').eq('property_id', property.id),
    supabase.from('leases').select('*').eq('property_id', property.id),
  ]);

  // owner via property.owner_id if present, else via property_owners bridge
  let owner = null as any;
  if (property.owner_id) {
    const { data } = await supabase.from('owners').select('*').eq('id', property.owner_id).single();
    owner = data ?? null;
  } else {
    const { data: link } = await supabase
      .from('property_owners')
      .select('owner_id')
      .eq('property_id', property.id)
      .limit(1)
      .maybeSingle();
    if (link?.owner_id) {
      const { data } = await supabase.from('owners').select('*').eq('id', link.owner_id).single();
      owner = data ?? null;
    }
  }

  res.json({ property, units: units ?? [], leases: leases ?? [], owner });
});

// GET /api/rpc/get_unit_card?id=45
rpc.get('/get_unit_card', async (req, res) => {
  const id = Number(req.query.id);
  if (!Number.isFinite(id)) return res.status(400).json({ error: 'id required' });

  const { data: unit, error: uErr } = await supabase
    .from('units')
    .select('*')
    .eq('id', id)
    .single();
  if (uErr || !unit) return res.status(404).json({ error: 'unit not found', id });

  const [{ data: property }, { data: leases }] = await Promise.all([
    supabase.from('properties').select('*').eq('id', unit.property_id).single(),
    supabase.from('leases').select('*').eq('unit_id', unit.id).order('start_date', { ascending: false }),
  ]);

  const activeLease = (leases ?? []).find(l => l.status === 'active') ?? null;

  let tenant = null as any;
  if (activeLease?.primary_tenant_id) {
    const { data } = await supabase.from('tenants').select('*').eq('id', activeLease.primary_tenant_id).single();
    tenant = data ?? null;
  }

  res.json({ unit, property: property ?? null, lease: activeLease, tenant });
});

// GET /api/rpc/get_lease_card?id=1
rpc.get('/get_lease_card', async (req, res) => {
  const id = Number(req.query.id);
  if (!Number.isFinite(id)) return res.status(400).json({ error: 'id required' });

  const { data: lease, error: lErr } = await supabase.from('leases').select('*').eq('id', id).single();
  if (lErr || !lease) return res.status(404).json({ error: 'lease not found', id });

  const [{ data: unit }, { data: property }, { data: tenant }] = await Promise.all([
    supabase.from('units').select('*').eq('id', lease.unit_id).maybeSingle(),
    supabase.from('properties').select('*').eq('id', lease.property_id).maybeSingle(),
    supabase.from('tenants').select('*').eq('id', lease.primary_tenant_id).maybeSingle(),
  ]);

  res.json({ lease, unit: unit ?? null, property: property ?? null, tenant: tenant ?? null });
});

// GET /api/rpc/get_tenant_card?id=1
rpc.get('/get_tenant_card', async (req, res) => {
  const id = Number(req.query.id);
  if (!Number.isFinite(id)) return res.status(400).json({ error: 'id required' });

  const [{ data: tenant }, { data: leases }] = await Promise.all([
    supabase.from('tenants').select('*').eq('id', id).single(),
    supabase.from('leases').select('*').eq('primary_tenant_id', id),
  ]);
  if (!tenant) return res.status(404).json({ error: 'tenant not found', id });

  const propertyIds = Array.from(new Set((leases ?? []).map(l => l.property_id).filter(Boolean)));
  let properties: any[] = [];
  if (propertyIds.length) {
    const { data } = await supabase.from('properties').select('*').in('id', propertyIds);
    properties = data ?? [];
  }

  res.json({ tenant, leases: leases ?? [], properties });
});

// GET /api/rpc/get_owner_card?id=6
rpc.get('/get_owner_card', async (req, res) => {
  const id = Number(req.query.id);
  if (!Number.isFinite(id)) return res.status(400).json({ error: 'id required' });

  const { data: owner, error: oErr } = await supabase.from('owners').select('*').eq('id', id).single();
  if (oErr || !owner) return res.status(404).json({ error: 'owner not found', id });

  // prefer direct FK owner_id, else via bridge
  let properties: any[] = [];
  const direct = await supabase.from('properties').select('*').eq('owner_id', id);
  if (direct.data?.length) {
    properties = direct.data;
  } else {
    const { data: links } = await supabase.from('property_owners').select('property_id').eq('owner_id', id);
    const pids = Array.from(new Set((links ?? []).map(l => l.property_id)));
    if (pids.length) {
      const { data } = await supabase.from('properties').select('*').in('id', pids);
      properties = data ?? [];
    }
  }

  res.json({ owner, properties });
});


Make sure these routes are mounted (already are in your project):

app.use('/api/entities', entities)
app.use('/api/rpc', rpc)

4) Client — single fetch + card hooks

Replace contents: src/lib/ecc-resolvers.ts

import { useQuery } from '@tanstack/react-query';

const fetchJson = async (url: string, signal?: AbortSignal) => {
  const res = await fetch(url, { signal });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return res.json();
};

// Property card
export function usePropertyCard(id: string | number) {
  return useQuery({
    queryKey: ['card', 'property', String(id)],
    queryFn: async ({ signal }) => {
      try {
        return await fetchJson(`/api/rpc/get_property_card?id=${id}`, signal);
      } catch {
        const property = await fetchJson(`/api/entities/properties/${id}`, signal);
        const [units, leases] = await Promise.all([
          fetchJson(`/api/entities/units?property_id=eq.${id}`, signal),
          fetchJson(`/api/entities/leases?property_id=eq.${id}`, signal),
        ]);
        return { property, units, leases, owner: null };
      }
    },
    staleTime: 60_000,
  });
}

// Unit card
export function useUnitCard(id: string | number) {
  return useQuery({
    queryKey: ['card', 'unit', String(id)],
    queryFn: async ({ signal }) => {
      try {
        return await fetchJson(`/api/rpc/get_unit_card?id=${id}`, signal);
      } catch {
        const unit = await fetchJson(`/api/entities/units/${id}`, signal);
        const [property, leases] = await Promise.all([
          fetchJson(`/api/entities/properties/${unit.property_id}`, signal),
          fetchJson(`/api/entities/leases?unit_id=eq.${id}`, signal),
        ]);
        const active = (leases ?? []).find((l: any) => l.status === 'active') ?? null;
        let tenant = null;
        if (active?.primary_tenant_id) {
          tenant = await fetchJson(`/api/entities/tenants/${active.primary_tenant_id}`, signal).catch(() => null);
        }
        return { unit, property, lease: active, tenant };
      }
    },
    staleTime: 60_000,
  });
}

// Lease card
export function useLeaseCard(id: string | number) {
  return useQuery({
    queryKey: ['card', 'lease', String(id)],
    queryFn: async ({ signal }) => {
      try {
        return await fetchJson(`/api/rpc/get_lease_card?id=${id}`, signal);
      } catch {
        const lease = await fetchJson(`/api/entities/leases/${id}`, signal);
        const [unit, property, tenant] = await Promise.all([
          fetchJson(`/api/entities/units/${lease.unit_id}`, signal).catch(() => null),
          fetchJson(`/api/entities/properties/${lease.property_id}`, signal).catch(() => null),
          fetchJson(`/api/entities/tenants/${lease.primary_tenant_id}`, signal).catch(() => null),
        ]);
        return { lease, unit, property, tenant };
      }
    },
    staleTime: 60_000,
  });
}

// Tenant card
export function useTenantCard(id: string | number) {
  return useQuery({
    queryKey: ['card', 'tenant', String(id)],
    queryFn: async ({ signal }) => {
      try {
        return await fetchJson(`/api/rpc/get_tenant_card?id=${id}`, signal);
      } catch {
        const tenant = await fetchJson(`/api/entities/tenants/${id}`, signal);
        const leases = await fetchJson(`/api/entities/leases?primary_tenant_id=eq.${id}`, signal);
        const pids = Array.from(new Set((leases ?? []).map((l: any) => l.property_id).filter(Boolean)));
        let properties: any[] = [];
        if (pids.length) properties = await fetchJson(`/api/entities/properties?id=in.(${pids.join(',')})`, signal).catch(() => []);
        return { tenant, leases, properties };
      }
    },
    staleTime: 60_000,
  });
}

// Owner card
export function useOwnerCard(id: string | number) {
  return useQuery({
    queryKey: ['card', 'owner', String(id)],
    queryFn: async ({ signal }) => {
      try {
        return await fetchJson(`/api/rpc/get_owner_card?id=${id}`, signal);
      } catch {
        const owner = await fetchJson(`/api/entities/owners/${id}`, signal);
        const properties = await fetchJson(`/api/entities/properties?owner_id=eq.${id}`, signal).catch(() => []);
        return { owner, properties };
      }
    },
    staleTime: 60_000,
  });
}


Ensure every card page imports its hook from @/lib/ecc-resolvers and reads flat fields:

Property card: data?.property, data?.units, data?.leases, data?.owner

Unit card: data?.unit, data?.property, data?.lease, data?.tenant, etc.

5) Client — compute KPIs from arrays

Edit your Property hero component (e.g. src/pages/card/property/Hero.tsx or your shared HeroBlock.tsx) so it computes KPIs:

type Props = {
  property?: any
  units?: any[]
  leases?: any[]
}

export default function PropertyHero({ property, units = [], leases = [] }: Props) {
  const unitsCount = units.length
  const activeLeases = leases.filter(l => String(l?.status).toLowerCase() === 'active').length
  const occupancyPct = unitsCount ? (activeLeases / unitsCount) * 100 : 0

  const activeRents = leases
    .filter(l => String(l?.status).toLowerCase() === 'active')
    .map(l => Number(l?.rent_cents ?? l?.rent ?? 0))
  const avgRentCents = activeRents.length ? Math.round(activeRents.reduce((a, b) => a + b, 0) / activeRents.length) : 0

  return (
    <div className="ecc-object p-4 rounded-xl">
      <div className="text-sm opacity-70">{property?.name ?? `Property #${property?.id ?? '—'}`}</div>
      <div className="mt-3 grid grid-cols-4 gap-4">
        <KPI label="Units" value={unitsCount} />
        <KPI label="Active Leases" value={activeLeases} />
        <KPI label="Occupancy" value={`${occupancyPct.toFixed(1)}%`} />
        <KPI label="Avg Rent" value={money(avgRentCents)} />
      </div>
    </div>
  )
}

// money helper (if you don't have one already)
function money(cents: number) {
  const v = (cents || 0) / 100
  return v.toLocaleString(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 0 })
}

// trivial KPI atom
function KPI({ label, value }: { label: string; value: React.ReactNode }) {
  return (
    <div className="rounded-lg bg-neutral-900/40 p-3">
      <div className="text-xs opacity-60">{label}</div>
      <div className="text-lg font-semibold">{value}</div>
    </div>
  )
}


Pass the arrays in your page:

const { data } = usePropertyCard(id)
<PropertyHero property={data?.property} units={data?.units} leases={data?.leases} />

✅ Quick verification (copy/paste)

Start the app (your usual npm run dev).

Backend smoke tests (terminal):

curl -s http://localhost:8787/api/entities/properties/42 | jq '.id,.doorloop_id'
curl -s "http://localhost:8787/api/entities/units?property_id=eq.42"  | jq 'length'
curl -s "http://localhost:8787/api/entities/leases?property_id=eq.42" | jq 'map(select(.status=="active"))|length'
curl -s "http://localhost:8787/api/rpc/get_property_card?id=42"       | jq '{p:.property.id,u:(.units|length),a:(.leases|map(select(.status=="active"))|length)}'


UI checks (browser):

/card/property/42 now shows non-zero Units & Active Leases; Occupancy reflects the ratio.

Overview panel shows DoorLoop ID, Type/Class, Owner (if present).

/card/unit/45, /card/lease/1, /card/tenant/1, /card/owner/1 populate their relationships.