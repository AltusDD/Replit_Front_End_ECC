TITLE: SYSTEM RESET v3 — Cards Up WITH HARD GATES & PROOFS

You previously claimed “success” without proof. That ends now.
Execute these steps exactly. After each step, stop and post the raw command outputs requested. If a proof fails, fix and re-prove before moving on.

We are fixing two concrete contract errors first:

kpis.units must be a number (0 when empty).

property.type must be a string (default "UNKNOWN" if source missing).

Then we’ll harden the other four cards.

STEP 0 — Boot sanity (fast)

Do:

Keep server.allowedHosts: true in vite.config.ts.

index.html: only <script type="module" src="/src/main.tsx"></script>.

src/components/EccErrorBoundary.tsx: no DOM manipulation; just render the error text.

src/main.tsx: import EccErrorBoundary from "./components/EccErrorBoundary";
Use Fragment (not StrictMode) in dev to reduce HMR noise.

Prove (raw output):

npm run dev
# paste the Vite banner with URLs
# paste the line: [Dev API] Listening on :8787
# confirm: App shell renders; no red overlay / removeChild errors


Stop if not clean.

STEP 1 — Add tiny diag to get valid IDs (temporary)

Do (in server/routes/rpc.ts): add this route once near the top, after router is created.

rpc.get('/diag/ids', async (req, res) => {
  try {
    const d = {} as any;
    const pt = await supabase.from('properties').select('id').limit(1);
    const ut = await supabase.from('units').select('id').limit(1);
    const lt = await supabase.from('leases').select('id').limit(1);
    const ot = await supabase.from('owners').select('id').limit(1);
    const tt = await supabase.from('tenants').select('id').limit(1);
    d.property = pt.data?.[0]?.id ?? null;
    d.unit = ut.data?.[0]?.id ?? null;
    d.lease = lt.data?.[0]?.id ?? null;
    d.owner = ot.data?.[0]?.id ?? null;
    d.tenant = tt.data?.[0]?.id ?? null;
    res.json(d);
  } catch (e:any) { res.status(500).json({ error: e?.message || 'diag error' }); }
});


Prove:

curl -s http://localhost:8787/api/rpc/diag/ids | jq .


(Post the JSON. We will use these IDs in later checks.)

STEP 2 — Property RPC: guarantee contract (fix kpis.units & property.type)

Do (in server/routes/rpc.ts):

Add helpers (top of file if missing):

const pick = (o:any, keys:string[]) =>
  Object.fromEntries(keys.map(k => [k, (o ?? {})[k]]).filter(([,v]) => v !== undefined));

const toCents = (n:any) =>
  (typeof n === 'number' ? Math.round(n*100) : (n == null ? null : Number(n)));

const ok = (res:any, body:any) => res.status(200).json(body);
const fail = (res:any, code:number, msg:string) => res.status(code).json({ error: msg });

async function fetchOneMulti(sb:any, table:string, id:string|number, altCols:string[]) {
  // try by PK
  let r = await sb.from(table).select('*').eq('id', id).limit(1);
  if (r.error) throw r.error;
  if (Array.isArray(r.data) && r.data.length) return r.data[0];
  // fallback by alt keys (e.g., doorloop_id)
  for (const col of altCols) {
    const rr = await sb.from(table).select('*').eq(col, id).limit(1);
    if (rr.error) throw rr.error;
    if (Array.isArray(rr.data) && rr.data.length) return rr.data[0];
  }
  return null;
}


Replace the entire get_property_card handler with this robust version:

rpc.get('/get_property_card', async (req, res) => {
  try {
    const id = String(req.query.id ?? '').trim();
    if (!id) return fail(res, 400, 'missing id');

    const property = await fetchOneMulti(supabase, 'properties', id, ['doorloop_id']);
    if (!property) return fail(res, 404, 'property not found');

    // Fetch relations safely
    const u = await supabase.from('units').select('*').eq('property_id', property.id);
    if (u.error) throw u.error;
    const l = await supabase.from('leases').select('*').eq('property_id', property.id);
    if (l.error) throw l.error;

    const units = Array.isArray(u.data) ? u.data : [];
    const leases = Array.isArray(l.data) ? l.data : [];

    // KPIs with guaranteed numbers
    const totalUnits = Number(units.length) || 0;
    const activeLeases = leases.filter(x => String(x?.status).toUpperCase() === 'ACTIVE').length;
    const occupancyPct = totalUnits > 0 ? Math.round((activeLeases / totalUnits) * 100) : 0;

    const rents = leases
      .map(x => (typeof x?.rent_cents === 'number' ? x.rent_cents : toCents(x?.rent)))
      .filter((v): v is number => typeof v === 'number');
    const avgRentCents = rents.length ? Math.round(rents.reduce((a,b)=>a+b,0) / rents.length) : null;

    // address/coalesce + type default
    const address = {
      line1: property.address1 ?? property.address_line1 ?? property.line1 ?? '',
      city: property.city ?? '',
      state: property.state ?? '',
      zip: property.zip ?? property.zipcode ?? ''
    };
    const type = (property.type ?? 'UNKNOWN') as string;

    return ok(res, {
      property: { ...pick(property, ['id','name','doorloop_id']), type, address },
      kpis: { units: totalUnits, activeLeases, occupancyPct, avgRentCents }
    });
  } catch (e:any) {
    return fail(res, 500, e?.message || 'server error');
  }
});


Prove (using discovered IDs from Step 1):

PID=$(curl -s http://localhost:8787/api/rpc/diag/ids | jq -r '.property')
echo "PID=$PID"
curl -s "http://localhost:8787/api/rpc/get_property_card?id=${PID}" | tee /tmp/prop.json | jq .
echo "ASSERTS:"
jq -e '(.property.type|type=="string") and (.kpis.units|type=="number") and (.kpis.activeLeases|type=="number") and (.kpis.occupancyPct|type=="number") and (has("kpis") and has("property")) and ((.kpis.avgRentCents==null) or (.kpis.avgRentCents|type=="number"))' /tmp/prop.json \
 && echo "PROPERTY_CONTRACT: OK" || echo "PROPERTY_CONTRACT: FAIL"


Do not continue until it prints PROPERTY_CONTRACT: OK.

STEP 3 — Harden the other 4 RPCs (return required root objects; use null/[] not undefined)

Do: update these handlers to always return their root keys with safe defaults:

/get_unit_card → { unit, property: property||null, lease: lease||null }

/get_lease_card → { lease, unit: unit||null, tenant: tenant||null, property: property||null }

/get_owner_card → { owner, properties: properties||[] }

/get_tenant_card → { tenant, leases: leases||[], activeLease: active||null }

Follow the same defensive patterns as property: multi-key lookup, array guards, coalescing defaults.

Prove (raw):

IDS=$(curl -s http://localhost:8787/api/rpc/diag/ids)
UID=$(echo "$IDS" | jq -r '.unit');   echo "UID=$UID"
LID=$(echo "$IDS" | jq -r '.lease');  echo "LID=$LID"
OID=$(echo "$IDS" | jq -r '.owner');  echo "OID=$OID"
TID=$(echo "$IDS" | jq -r '.tenant'); echo "TID=$TID"

echo "== unit =="    && curl -s "http://localhost:8787/api/rpc/get_unit_card?id=${UID}" | tee /tmp/unit.json | jq .
echo "== lease =="   && curl -s "http://localhost:8787/api/rpc/get_lease_card?id=${LID}" | tee /tmp/lease.json | jq .
echo "== owner =="   && curl -s "http://localhost:8787/api/rpc/get_owner_card?id=${OID}" | tee /tmp/owner.json | jq .
echo "== tenant =="  && curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=${TID}" | tee /tmp/tenant.json | jq .

echo "ASSERTS:"
jq -e 'has("unit") and has("property") and has("lease")' /tmp/unit.json && echo UNIT_OK || echo UNIT_FAIL
jq -e 'has("lease") and has("unit") and has("tenant") and has("property")' /tmp/lease.json && echo LEASE_OK || echo LEASE_FAIL
jq -e 'has("owner") and has("properties") and (.properties|type=="array")' /tmp/owner.json && echo OWNER_OK || echo OWNER_FAIL
jq -e 'has("tenant") and has("leases") and (.leases|type=="array") and has("activeLease")' /tmp/tenant.json && echo TENANT_OK || echo TENANT_FAIL


All four must print *_OK. Fix and re-prove if not.

STEP 4 — CardKit alignment (remove legacy “FieldRows”)

Do:

Replace all <FieldRows> with CardKit <FieldGroup> from @/components/cardkit/FieldGroup.

Ensure the 5 Overview tabs import panels from @/components/cardkit/* (CardPanel, FieldGroup, KPI, RightRailPanel).

No imports from any legacy features/ui/FieldGroup or components/Section.

Prove (raw):

grep -R --line-number -E "<FieldRows|from .+FieldRows|components/Section|features/ui/FieldGroup" src || echo "NO_LEGACY: OK"


Must show NO_LEGACY: OK.

STEP 5 — UI smoke (real routes)

Visit in the browser:

/portfolio/properties

/card/property/<PID>

/card/unit/<UID>

/card/lease/<LID>

/card/owner/<OID>

/card/tenant/<TID>

Report:
“All six routes render with no red overlay and no Zod contract violations.”
If any fails, paste the exact message from EccErrorBoundary and the matching RPC JSON you printed in Step 2/3 for that ID.

RULES (non-negotiable)

Post the exact raw outputs I asked for after each step.

If a proof fails, fix and re-prove before moving on.

Do not summarize success without the jq assertions showing OK.

Do not re-introduce any DOM overlays or dev/demo pages into the app entry.

Execute now.