TITLE: Cards Up — Contract Proof Or Fix It (Hard-gated)

Your “everything is working” claim contradicts active contract violations (e.g., property.type missing, kpis.units undefined). Do not summarize. Execute this checklist exactly. After each step, paste the raw outputs requested. If an assertion fails, fix and re-prove before continuing.

STEP 0 — Clean boot (fast recheck)

vite.config.ts: server.allowedHosts = true.

index.html: only <script type="module" src="/src/main.tsx"></script>.

src/components/EccErrorBoundary.tsx: pure React; no DOM ops; shows message + stack.

src/main.tsx: import EccErrorBoundary from "./components/EccErrorBoundary";
Use Fragment (not StrictMode) in dev.

Prove (raw banner lines):

npm run dev
# Paste Vite URLs and: [Dev API] Listening on :8787

STEP 1 — Discover real IDs (no guessing)

Add once in server/routes/rpc.ts (top-level after router):

rpc.get('/diag/ids', async (_req, res) => {
  try {
    const grab = async (t:string) => (await supabase.from(t).select('id').limit(1)).data?.[0]?.id ?? null;
    res.json({
      property: await grab('properties'),
      unit:     await grab('units'),
      lease:    await grab('leases'),
      owner:    await grab('owners'),
      tenant:   await grab('tenants'),
    });
  } catch (e:any){ res.status(500).json({ error: e?.message || 'diag error' });}
});


Prove:

curl -s http://localhost:8787/api/rpc/diag/ids | jq .

STEP 2 — Fix the Property RPC (this is where it’s breaking)
2.1 Add helpers (top of server/routes/rpc.ts if missing)
const pick = (o:any, keys:string[]) => Object.fromEntries(keys.map(k => [k,(o??{})[k]]));
const toCents = (n:any) => (typeof n==='number'?Math.round(n*100):(n==null?null:Number(n)));
const ok   = (res:any, body:any)=>res.status(200).json(body);
const fail = (res:any, code:number, msg:string)=>res.status(code).json({ error: msg });

async function fetchOneMulti(sb:any, table:string, id:string|number, altCols:string[]) {
  let r = await sb.from(table).select('*').eq('id', id).limit(1);
  if (r.error) throw r.error;
  if (r.data?.length) return r.data[0];
  for (const col of altCols) {
    const rr = await sb.from(table).select('*').eq(col, id).limit(1);
    if (rr.error) throw rr.error;
    if (rr.data?.length) return rr.data[0];
  }
  return null;
}

2.2 Replace /get_property_card with a contract-guaranteed version
rpc.get('/get_property_card', async (req, res) => {
  try {
    const id = String(req.query.id ?? '').trim();
    if (!id) return fail(res, 400, 'missing id');

    const property = await fetchOneMulti(supabase, 'properties', id, ['doorloop_id']);
    if (!property) return fail(res, 404, 'property not found');

    const u = await supabase.from('units').select('id').eq('property_id', property.id);
    if (u.error) throw u.error;
    const l = await supabase.from('leases').select('status,rent_cents,rent').eq('property_id', property.id);
    if (l.error) throw l.error;

    const units = Array.isArray(u.data) ? u.data : [];
    const leases = Array.isArray(l.data) ? l.data : [];

    const totalUnits = Number(units.length) || 0;
    const activeLeases = leases.filter(x => String(x?.status).toUpperCase() === 'ACTIVE').length;
    const occupancyPct = totalUnits > 0 ? Math.round((activeLeases/totalUnits)*100) : 0;

    const rents = leases
      .map(x => (typeof x?.rent_cents === 'number' ? x.rent_cents : toCents(x?.rent)))
      .filter((v): v is number => typeof v === 'number');
    const avgRentCents = rents.length ? Math.round(rents.reduce((a,b)=>a+b,0)/rents.length) : null;

    const address = {
      line1: property.address1 ?? property.address_line1 ?? property.line1 ?? '',
      city:  property.city ?? '',
      state: property.state ?? '',
      zip:   property.zip ?? property.zipcode ?? '',
    };
    const type = (property.type ?? 'UNKNOWN') as string;

    return ok(res, {
      property: { ...pick(property, ['id','name','doorloop_id']), type, address },
      kpis: { units: totalUnits, activeLeases, occupancyPct, avgRentCents }
    });
  } catch (e:any) {
    return fail(res, 500, e?.message || 'server error');
  }
});

2.3 Prove the contract with assertions (no summaries)
IDS=$(curl -s http://localhost:8787/api/rpc/diag/ids)
PID=$(echo "$IDS" | jq -r '.property')
echo "PID=$PID"
curl -s "http://localhost:8787/api/rpc/get_property_card?id=${PID}" | tee /tmp/prop.json | jq .
echo "ASSERTS:"
jq -e '
  (.property.type|type=="string")
  and (.kpis.units|type=="number")
  and (.kpis.activeLeases|type=="number")
  and (.kpis.occupancyPct|type=="number")
  and (has("kpis") and has("property"))
  and ((.kpis.avgRentCents==null) or (.kpis.avgRentCents|type=="number"))
' /tmp/prop.json && echo "PROPERTY_CONTRACT: OK" || echo "PROPERTY_CONTRACT: FAIL"


Do not proceed unless it prints PROPERTY_CONTRACT: OK.

STEP 3 — Harden the other 4 RPCs (guarantee root keys)

Update handlers so they always return these shapes (null/[] instead of undefined):

/get_unit_card → { unit, property: property||null, lease: lease||null }

/get_lease_card → { lease, unit: unit||null, tenant: tenant||null, property: property||null }

/get_owner_card → { owner, properties: properties||[] }

/get_tenant_card → { tenant, leases: leases||[], activeLease: active||null }

Prove (raw JSON + assertions):

UID=$(echo "$IDS" | jq -r '.unit');   echo "UID=$UID"
LID=$(echo "$IDS" | jq -r '.lease');  echo "LID=$LID"
OID=$(echo "$IDS" | jq -r '.owner');  echo "OID=$OID"
TID=$(echo "$IDS" | jq -r '.tenant'); echo "TID=$TID"

echo "== unit =="   && curl -s "http://localhost:8787/api/rpc/get_unit_card?id=${UID}"    | tee /tmp/unit.json   | jq .
echo "== lease =="  && curl -s "http://localhost:8787/api/rpc/get_lease_card?id=${LID}"   | tee /tmp/lease.json  | jq .
echo "== owner =="  && curl -s "http://localhost:8787/api/rpc/get_owner_card?id=${OID}"   | tee /tmp/owner.json  | jq .
echo "== tenant ==" && curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=${TID}"  | tee /tmp/tenant.json | jq .

echo "ASSERTS:"
jq -e 'has("unit") and has("property") and has("lease")' /tmp/unit.json   && echo UNIT_OK   || echo UNIT_FAIL
jq -e 'has("lease") and has("unit") and has("tenant") and has("property")' /tmp/lease.json && echo LEASE_OK  || echo LEASE_FAIL
jq -e 'has("owner") and has("properties") and (.properties|type=="array")' /tmp/owner.json && echo OWNER_OK  || echo OWNER_FAIL
jq -e 'has("tenant") and has("leases") and (.leases|type=="array") and has("activeLease")'  /tmp/tenant.json && echo TENANT_OK || echo TENANT_FAIL

STEP 4 — Frontend alignment (kill legacy FieldRows)

Replace all <FieldRows> usage with CardKit <FieldGroup> (@/components/cardkit/FieldGroup).

Ensure Overview tabs import from @/components/cardkit/* only.

Prove (no matches):

grep -R --line-number -E "<FieldRows|from .+FieldRows|components/Section|features/ui/FieldGroup" src || echo "NO_LEGACY: OK"

STEP 5 — UI Smoke (includes dbl-click nav)

Portfolio → verify double-click navigation works. If not, instrument DataTable:

In the handleDbl path, add:

console.log('[DT/DBL]', { href, row });


Ensure rowHref returns /card/<type>/${row.id} using the actual row.id key in the mapped rows.

Manually open these (using IDs from Step 1):

/portfolio/properties
/card/property/<PID>
/card/unit/<UID>
/card/lease/<LID>
/card/owner/<OID>
/card/tenant/<TID>


Report:
“All six routes render without red overlays or Zod contract violations.”
If a card fails, paste:

The exact message from EccErrorBoundary, and

The JSON from the matching RPC call (from Step 2/3) for that ID.

Non-negotiable rules

Paste raw outputs and the jq assertion results (*_OK).

If an assertion prints FAIL, fix and re-prove before moving on.

Don’t claim “working” without the proof blocks above.

Execute now.