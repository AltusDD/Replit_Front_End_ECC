ECC DATA UNBLOCK PACK v1 (Server + Client)

Goal: Cards show real data again (no wrappers, no waterfalls, no blank panels).

Non-negotiables:

Keep constant hook counts.

No overlays. No full-screen modals.

Map only on Property.

Pages never return null.

PATCH S1 — Client: robust JSON + abort-safe fetch

Edit: src/lib/ecc-api-client.ts (or create if missing)

// src/lib/ecc-api-client.ts
export type Json = any;

function unwrap(data: any) {
  if (data && typeof data === "object") {
    if ("item" in data) return (data as any).item;
    if ("items" in data) return (data as any).items;
    if ("data" in data) return (data as any).data;
  }
  return data;
}

/** Abort-safe fetch that tolerates wrapped server payloads */
export async function j(
  input: RequestInfo,
  init?: RequestInit & { signal?: AbortSignal }
): Promise<Json> {
  const res = await fetch(input, { ...init, signal: init?.signal });
  if (!res.ok) {
    const body = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} ${res.statusText} ${body}`.trim());
  }
  const raw = await res.json().catch(() => null);
  return unwrap(raw);
}

/** Helper for Promise.allSettled results */
export function ok<T>(s: PromiseSettledResult<T>, fallback: T): T {
  return s.status === "fulfilled" ? s.value : fallback;
}

/** Money (cents → $X,XXX.xx) */
export function money(cents?: number | null): string {
  const n = Number(cents ?? 0);
  return new Intl.NumberFormat(undefined, { style: "currency", currency: "USD" })
    .format(n / 100);
}


DoD: All hooks can pass signal to j(). Aborted HMR requests no longer error-spam.

PATCH S2 — Server: normalize /api/entities + add simple filters

Edit: server/routes/entities.ts (or equivalent)

// server/routes/entities.ts
import { Router } from "express";
import { createClient } from "@supabase/supabase-js";

const r = Router();
const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_KEY!);

// Util: parse query like ?field=eq.123&status=ilike.%active%&select=id,name
const RESERVED = new Set(["select", "limit", "order", "id"]);

r.get("/:table/:id?", async (req, res) => {
  try {
    const { table, id } = req.params as { table: string; id?: string };
    const q = req.query as Record<string, string | undefined>;
    let sb = supabase.from(table).select(q.select || "*");

    if (id) {
      const { data, error } = await sb.eq("id", id).single();
      if (error) return res.status(404).json({ error: error.message });
      // **Return RAW object (no wrapper)**
      return res.json(data);
    }

    // filters: field=op.value (eq, neq, gt, gte, lt, lte, ilike, like, is, in)
    for (const [key, val] of Object.entries(q)) {
      if (!val || RESERVED.has(key)) continue;
      const [op, ...rest] = val.split(".");
      const v = rest.join(".");
      switch (op) {
        case "eq": sb = sb.eq(key, v); break;
        case "neq": sb = sb.neq(key, v); break;
        case "gt": sb = sb.gt(key, v); break;
        case "gte": sb = sb.gte(key, v); break;
        case "lt": sb = sb.lt(key, v); break;
        case "lte": sb = sb.lte(key, v); break;
        case "ilike": sb = sb.ilike(key, v); break;
        case "like": sb = sb.like(key, v); break;
        case "is": sb = sb.is(key, v); break;
        case "in":
          // in.(a,b,c)
          sb = sb.in(key, v.replace(/^\(|\)$/g, "").split(","));
          break;
        default:
          // default to eq
          sb = sb.eq(key, val);
      }
    }

    if (q.order) {
      // order=field.asc or field.desc
      const [field, dir = "asc"] = q.order.split(".");
      sb = sb.order(field, { ascending: dir.toLowerCase() !== "desc" });
    }
    if (q.limit) sb = sb.limit(Number(q.limit));

    const { data, error } = await sb;
    if (error) return res.status(400).json({ error: error.message });

    // **Return RAW array (no wrapper)**
    return res.json(data);
  } catch (e: any) {
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

export default r;


DoD:

GET /api/entities/properties/42 returns a raw object.

GET /api/entities/leases?property_id=eq.42 returns a raw array.

No { ok: true, item: … } wrappers anywhere.

PATCH S3 — Server: thin RPC endpoints for each card

Add: server/routes/rpc.ts

import { Router } from "express";
import { createClient } from "@supabase/supabase-js";
const r = Router();
const db = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_KEY!);

async function one(table: string, id: string) {
  const { data, error } = await db.from(table).select("*").eq("id", id).single();
  if (error) throw new Error(error.message);
  return data;
}
async function many(table: string, filters: Record<string,string|number>) {
  let q = db.from(table).select("*");
  for (const [k,v] of Object.entries(filters)) q = q.eq(k, v as any);
  const { data, error } = await q;
  if (error) throw new Error(error.message);
  return data;
}

// Property card
r.get("/get_property_card", async (req, res) => {
  try {
    const id = String(req.query.id || "");
    const property = await one("properties", id);
    const [units, leases] = await Promise.all([
      many("units", { doorloop_property_id: property.doorloop_id }),
      many("leases", { property_id: property.id }),
    ]);
    // owner is optional / model-dependent
    const owner = null;
    res.json({ property, units, leases, owner });
  } catch (e:any) { res.status(404).json({ error: e.message }); }
});

// Unit card
r.get("/get_unit_card", async (req, res) => {
  try {
    const id = String(req.query.id || "");
    const unit = await one("units", id);
    const [property, leases] = await Promise.all([
      many("properties", { doorloop_id: unit.doorloop_property_id }).then(a=>a[0]||null),
      many("leases", { unit_id: unit.id }),
    ]);
    const tenant = null;
    res.json({ unit, property, leases, tenant });
  } catch (e:any) { res.status(404).json({ error: e.message }); }
});

// Lease card
r.get("/get_lease_card", async (req, res) => {
  try {
    const id = String(req.query.id || "");
    const lease = await one("leases", id);
    const [property, unit] = await Promise.all([
      many("properties", { id: lease.property_id }).then(a=>a[0]||null),
      many("units", { id: lease.unit_id }).then(a=>a[0]||null),
    ]);
    const tenant = null; // optional: link via lease.primary_tenant_id
    res.json({ lease, property, unit, tenant });
  } catch (e:any) { res.status(404).json({ error: e.message }); }
});

// Tenant card
r.get("/get_tenant_card", async (req, res) => {
  try {
    const id = String(req.query.id || "");
    const tenant = await one("tenants", id);
    const leases = await many("leases", { primary_tenant_id: tenant.id });
    res.json({ tenant, leases, properties: [] });
  } catch (e:any) { res.status(404).json({ error: e.message }); }
});

// Owner card
r.get("/get_owner_card", async (req, res) => {
  try {
    const id = String(req.query.id || "");
    const owner = await one("owners", id);
    const properties = await many("properties", { owner_id: owner.id });
    res.json({ owner, properties, portfolio_stats: {} });
  } catch (e:any) { res.status(404).json({ error: e.message }); }
});

export default r;


Wire it: server/index.ts

import rpc from "./routes/rpc";
import entities from "./routes/entities";
// …
app.use("/api/entities", entities);
app.use("/api/rpc", rpc);


DoD: The following all return 200 with full JSON:

/api/rpc/get_property_card?id=42

/api/rpc/get_unit_card?id=45

/api/rpc/get_lease_card?id=1

/api/rpc/get_tenant_card?id=1

/api/rpc/get_owner_card?id=1

(If some relationships aren’t modeled yet, they can be null/empty, but the endpoint itself must 200.)

PATCH S4 — Hooks: prefer RPC, fallback to entities (abort-safe)

Edit: src/lib/ecc-card-queries.ts

import { useQuery } from "@tanstack/react-query";
import { j, ok } from "./ecc-api-client";

export function usePropertyCard(id: string) {
  return useQuery({
    queryKey: ["card","property", id],
    staleTime: 60_000,
    queryFn: async ({ signal }) => {
      try {
        return await j(`/api/rpc/get_property_card?id=${id}`, { signal });
      } catch {
        const property = await j(`/api/entities/properties/${id}`, { signal });
        const [unitsS, leasesS] = await Promise.allSettled([
          j(`/api/entities/units?doorloop_property_id=eq.${property.doorloop_id}`, { signal }),
          j(`/api/entities/leases?property_id=eq.${property.id}`, { signal }),
        ]);
        return {
          property,
          units: ok(unitsS, []),
          leases: ok(leasesS, []),
          owner: null
        };
      }
    },
  });
}

export function useUnitCard(id: string) {
  return useQuery({
    queryKey: ["card","unit", id],
    staleTime: 60_000,
    queryFn: async ({ signal }) => {
      try {
        return await j(`/api/rpc/get_unit_card?id=${id}`, { signal });
      } catch {
        const unit = await j(`/api/entities/units/${id}`, { signal });
        const [propertyS, leasesS] = await Promise.allSettled([
          j(`/api/entities/properties?doorloop_id=eq.${unit.doorloop_property_id}`, { signal }),
          j(`/api/entities/leases?unit_id=eq.${unit.id}`, { signal }),
        ]);
        return {
          unit,
          property: ok(propertyS, [null])[0] ?? null,
          leases: ok(leasesS, []),
          tenant: null
        };
      }
    },
  });
}

export function useLeaseCard(id: string) {
  return useQuery({
    queryKey: ["card","lease", id],
    staleTime: 60_000,
    queryFn: async ({ signal }) => {
      try {
        return await j(`/api/rpc/get_lease_card?id=${id}`, { signal });
      } catch {
        const lease = await j(`/api/entities/leases/${id}`, { signal });
        const [propertyS, unitS] = await Promise.allSettled([
          j(`/api/entities/properties?id=eq.${lease.property_id}`, { signal }),
          j(`/api/entities/units?id=eq.${lease.unit_id}`, { signal }),
        ]);
        return {
          lease,
          property: ok(propertyS, [null])[0] ?? null,
          unit: ok(unitS, [null])[0] ?? null,
          tenant: null
        };
      }
    },
  });
}

export function useTenantCard(id: string) {
  return useQuery({
    queryKey: ["card","tenant", id],
    staleTime: 60_000,
    queryFn: async ({ signal }) => {
      try {
        return await j(`/api/rpc/get_tenant_card?id=${id}`, { signal });
      } catch {
        const tenant = await j(`/api/entities/tenants/${id}`, { signal });
        const leases = await j(`/api/entities/leases?primary_tenant_id=eq.${tenant.id}`, { signal });
        return { tenant, leases, properties: [] };
      }
    },
  });
}

export function useOwnerCard(id: string) {
  return useQuery({
    queryKey: ["card","owner", id],
    staleTime: 60_000,
    queryFn: async ({ signal }) => {
      try {
        return await j(`/api/rpc/get_owner_card?id=${id}`, { signal });
      } catch {
        const owner = await j(`/api/entities/owners/${id}`, { signal });
        const properties = await j(`/api/entities/properties?owner_id=eq.${owner.id}`, { signal });
        return { owner, properties, portfolio_stats: {} };
      }
    },
  });
}


DoD: Card pages load with real objects again. Partial relation failures no longer blank the page.

QUICK TEST PLAN (paste to Replit when done)

Entities shape

GET /api/entities/properties/42 returns a raw object (no wrapper).

GET /api/entities/leases?property_id=eq.42 returns array.

RPCs live

GET /api/rpc/get_property_card?id=42 returns { property, units[], leases[], owner }.

Repeat for unit(45), lease(1), tenant(1), owner(1).

Pages show data

/card/property/42 → title not placeholder; KPIs numeric; Overview filled.

/card/unit/45 → beds/baths, lease status.

/card/lease/1 → Status, Rent, Term populated.

/card/tenant/1 → Leases list shows entries or “No leases found.”

/card/owner/1 → Portfolio count reflects properties.

No console spam from aborted fetches during HMR.