Card RPC Hotfix (fail-fast compliant)
1) Add a tiny dual-key fetch helper

Edit server/routes/rpc.ts (top-level helpers area):

// generic dual-key fetch (id or DoorLoop id); returns one or null
async function fetchOne(
  sb: any,
  table: string,
  id: string | number,
  doorField: string
) {
  // PostgREST "or" filter; both numeric and string ids are tried
  const v = String(id);
  const { data, error } = await sb
    .from(table)
    .select("*")
    .or(`id.eq.${v},${doorField}.eq.${v}`)
    .limit(1)
    .maybeSingle();

  if (error) throw error;
  return data ?? null;
}


If you already have something like orByPropIdOrDoorLoop, keep it and use that; the point is to use the same dual-key lookup on every card.

2) Property: always return kpis.avgRentCents

In /api/rpc/get_property_card handler (after you load property, units, leases):

// compute active leases + KPIs (consistent field names)
const norm = (s: any) => String(s ?? "").toLowerCase();
const active = (leases || []).filter((l: any) => norm(l.status) === "active");
const unitsCount = Array.isArray(units) ? units.length : 0;
const activeCount = active.length;
const occupancyPct = unitsCount ? Math.round((activeCount / unitsCount) * 1000) / 10 : 0;
// rent in cents, tolerate rent or rent_cents in source rows
const rentNums = active
  .map((l: any) => Number(l.rent_cents ?? l.rent ?? 0))
  .filter((n: number) => Number.isFinite(n) && n >= 0);
const avgRentCents = rentNums.length
  ? Math.round(rentNums.reduce((a: number, b: number) => a + b, 0) / rentNums.length)
  : null;

// respond with normalized address and KPIs including avgRentCents
return res.json({
  property: property ? { ...property, ...mapAddress(property) } : null,
  units: units || [],
  leases: leases || [],
  kpis: {
    units: unitsCount,
    activeLeases: activeCount,
    occupancyPct,
    avgRentCents,                // << required by UI
  },
});


This clears [CONTRACT] Missing required field: kpis.avgRentCents on /card/property/:id.

3) Unit / Lease / Owner: ensure the primary entity is found by either key
3a) /api/rpc/get_unit_card
const id = req.query.id as string;
const unit = await fetchOne(supabase, "units", id, "doorloop_unit_id");
if (!unit) return res.status(404).json({ error: "Unit not found", id });

const property = unit.property_id
  ? await fetchOne(supabase, "properties", unit.property_id, "doorloop_property_id")
  : null;

const lease = await fetchOne(supabase, "leases", unit.id, "doorloop_unit_id"); // or your join logic
const tenant = lease?.tenant_id
  ? await fetchOne(supabase, "tenants", lease.tenant_id, "doorloop_tenant_id")
  : null;

return res.json({
  unit,
  property: property ? { ...property, ...mapAddress(property) } : null,
  lease: lease ?? null,
  tenant: tenant ?? null,
});


Fixes [CONTRACT] Missing required field: unit on /card/unit/:id.

3b) /api/rpc/get_lease_card
const id = req.query.id as string;
const lease = await fetchOne(supabase, "leases", id, "doorloop_lease_id");
if (!lease) return res.status(404).json({ error: "Lease not found", id });

const unit = lease.unit_id
  ? await fetchOne(supabase, "units", lease.unit_id, "doorloop_unit_id")
  : null;
const property = unit?.property_id
  ? await fetchOne(supabase, "properties", unit.property_id, "doorloop_property_id")
  : null;
const tenant = lease.tenant_id
  ? await fetchOne(supabase, "tenants", lease.tenant_id, "doorloop_tenant_id")
  : null;

return res.json({
  lease,
  unit: unit ?? null,
  property: property ? { ...property, ...mapAddress(property) } : null,
  tenant: tenant ?? null,
});


Fixes [CONTRACT] Missing required field: lease on /card/lease/:id.

3c) /api/rpc/get_owner_card
const id = req.query.id as string;
const owner = await fetchOne(supabase, "owners", id, "doorloop_owner_id");
if (!owner) return res.status(404).json({ error: "Owner not found", id });

// your existing joins for properties/units/leases...
// after computing active/units like in the property handler:
return res.json({
  owner,
  properties: (properties || []).map((p: any) => ({ ...p, ...mapAddress(p) })),
  kpis: {
    units: units.length,
    activeLeases: active.length,
    occupancyPct,
    avgRentCents,
  },
});


Fixes [CONTRACT] Missing required field: owner on /card/owner/:id.

Keep your existing join logic—just swap the first fetch to use dual-key and 404 when genuinely missing.

4) Rebuild & proofs (cards only)
npm run dev   # guardrail first, then web+api

# Property (replace 58 with your failing id)
curl -s "http://localhost:8787/api/rpc/get_property_card?id=58" | jq '.kpis'
# → should include: { "units": n, "activeLeases": m, "occupancyPct": x, "avgRentCents": y|null }

# Unit
curl -s "http://localhost:8787/api/rpc/get_unit_card?id=45" | jq '.unit.id'
# Lease
curl -s "http://localhost:8787/api/rpc/get_lease_card?id=21" | jq '.lease.id'
# Owner
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=11" | jq '.owner.id'


Then open:

/card/property/58

/card/unit/45

/card/lease/21

/card/owner/11

You should see heroes render (or an explicit HTTP 404 message if the id truly doesn’t exist).

5) Tables (defer changes; collect facts only)

Per your instruction: no table fixes yet. Have Replit run this quick inventory so we know exactly what’s wrong before touching layout/data.

Create scripts/audit-tables.mjs:

import fs from "fs"; import path from "path"; import glob from "glob";

const files = glob.sync("src/pages/portfolio/**/*.{ts,tsx}", { cwd: process.cwd() });
const report = [];
for (const rel of files) {
  const p = path.join(process.cwd(), rel);
  const s = fs.readFileSync(p, "utf8");
  const hasOverflowX = /overflow-x-(auto|scroll)/.test(s);
  const columns = (s.match(/accessorKey:\s*['"`][^'"`]+['"`]/g) || []).length;
  const masks = (s.match(/\?\?\s*['"]—['"]|\|\|\s*['"]—['"]/g) || []).length;
  report.push({ rel, columns, hasOverflowX, dashMasks: masks });
}
fs.writeFileSync("table_audit.json", JSON.stringify(report, null, 2));
console.log("Wrote table_audit.json with", report.length, "files");


Run:

node scripts/audit-tables.mjs


Download/inspect table_audit.json. We’ll use that to plan precise table fixes (column widths, overflow, and any remaining masking) once cards are green.

Why this fixes the screenshots

Property: adds the one missing KPI (avgRentCents) your hero requires.

Unit/Lease/Owner: the primary entity is now retrieved by id or DoorLoop id, which is the common cause of null main objects. If the record truly doesn’t exist, you’ll get a 404 instead of a misleading DTO that later fails.

No table changes yet—just an audit plan, per your direction.

If any of the four card curls come back without the expected key, paste that JSON and I’ll give you a one-file micro-patch for that endpoint.