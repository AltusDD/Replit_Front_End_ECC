PROMPT FOR REPLIT — “ECC Asset Cards: Final Restore & Enrichment (CSP v2)”

You are the Build Agent. Follow these steps exactly. Do not improvise, do not unify ports, do not touch tables. Stop on the first error and print it.

0) Guardrails / No-Drift

Keep dev model: Vite 5173 (web) + API 8787 (proxy from Vite).

Never reintroduce masking (?? 0, || 0, || '—') anywhere.

Work only in:

server/index.ts, server/routes/rpc.ts

src/pages/card/*/HeroBlock.tsx

src/pages/card/*/*.tsx (for tab content enrichment)

src/components/cardkit/*

Do not alter portfolio tables, dashboards, or build scripts.

1) Ports & Proxy (stabilize)

Open vite.config.*. Ensure:

export default defineConfig({
  server: { port: 5173, proxy: { "/api": "http://localhost:8787" } },
});


Open server/index.ts. Ensure:

const PORT = Number(process.env.API_PORT ?? 8787);
app.listen(PORT, () => console.log(`[Dev API] Listening on :${PORT}`));


Clear vite cache:

rm -rf node_modules/.vite .vite dist .cache .parcel-cache 2>/dev/null || true

2) Schema: add dual-keys + missing FKs in Supabase (idempotent)

Run this SQL as-is in Supabase SQL editor (safe to re-run):

-- PROPERTIES
ALTER TABLE public.properties
  ADD COLUMN IF NOT EXISTS doorloop_id text,
  ADD COLUMN IF NOT EXISTS doorloop_property_id text,
  ADD COLUMN IF NOT EXISTS owner_id bigint;
CREATE INDEX IF NOT EXISTS idx_properties_doorloop_id          ON public.properties(doorloop_id);
CREATE INDEX IF NOT EXISTS idx_properties_doorloop_property_id ON public.properties(doorloop_property_id);
CREATE INDEX IF NOT EXISTS idx_properties_owner_id             ON public.properties(owner_id);
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_properties_owner') THEN
    ALTER TABLE public.properties
      ADD CONSTRAINT fk_properties_owner FOREIGN KEY (owner_id) REFERENCES public.owners(id) ON DELETE SET NULL;
  END IF;
END $$;

-- UNITS
ALTER TABLE public.units
  ADD COLUMN IF NOT EXISTS doorloop_id text,
  ADD COLUMN IF NOT EXISTS doorloop_unit_id text;
CREATE INDEX IF NOT EXISTS idx_units_doorloop_id      ON public.units(doorloop_id);
CREATE INDEX IF NOT EXISTS idx_units_doorloop_unit_id ON public.units(doorloop_unit_id);

-- LEASES
ALTER TABLE public.leases
  ADD COLUMN IF NOT EXISTS doorloop_id text,
  ADD COLUMN IF NOT EXISTS doorloop_lease_id text,
  ADD COLUMN IF NOT EXISTS tenant_id  bigint,
  ADD COLUMN IF NOT EXISTS unit_id    bigint,
  ADD COLUMN IF NOT EXISTS property_id bigint;
CREATE INDEX IF NOT EXISTS idx_leases_doorloop_id       ON public.leases(doorloop_id);
CREATE INDEX IF NOT EXISTS idx_leases_doorloop_lease_id ON public.leases(doorloop_lease_id);
CREATE INDEX IF NOT EXISTS idx_leases_tenant_id         ON public.leases(tenant_id);
CREATE INDEX IF NOT EXISTS idx_leases_unit_id           ON public.leases(unit_id);
CREATE INDEX IF NOT EXISTS idx_leases_property_id       ON public.leases(property_id);
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_leases_tenant') THEN
    ALTER TABLE public.leases
      ADD CONSTRAINT fk_leases_tenant FOREIGN KEY (tenant_id) REFERENCES public.tenants(id) ON DELETE SET NULL;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_leases_unit') THEN
    ALTER TABLE public.leases
      ADD CONSTRAINT fk_leases_unit FOREIGN KEY (unit_id) REFERENCES public.units(id) ON DELETE SET NULL;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_leases_property') THEN
    ALTER TABLE public.leases
      ADD CONSTRAINT fk_leases_property FOREIGN KEY (property_id) REFERENCES public.properties(id) ON DELETE SET NULL;
  END IF;
END $$;

-- TENANTS & OWNERS
ALTER TABLE public.tenants ADD COLUMN IF NOT EXISTS doorloop_tenant_id text;
CREATE INDEX IF NOT EXISTS idx_tenants_doorloop_tenant_id ON public.tenants(doorloop_tenant_id);

ALTER TABLE public.owners ADD COLUMN IF NOT EXISTS doorloop_owner_id text;
CREATE INDEX IF NOT EXISTS idx_owners_doorloop_owner_id ON public.owners(doorloop_owner_id);

3) RPC Endpoints: harden + dual-key lookups

Open server/routes/rpc.ts. Add once at top:

async function fetchOneMulti(sb:any, table:string, id:string|number, alt:string[]) {
  const v = String(id);
  const ors = ["id.eq."+v, ...alt.map(f => `${f}.eq.${v}`)].join(",");
  const { data, error } = await sb.from(table).select("*").or(ors).limit(1).maybeSingle();
  if (error) throw error;
  return data ?? null;
}
const norm = (s:any) => String(s ?? "").toLowerCase();

3A) Property card — allow avgRentCents: null

Replace handler body with:

app.get("/api/rpc/get_property_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const property = await fetchOneMulti(supabase, "properties", id, ["doorloop_property_id","doorloop_id"]);
    if (!property) return res.status(404).json({ error: "property not found", id });

    const { data: units = [] }  = await supabase.from("units").select("*").eq("property_id", property.id);
    const { data: leases = [] } = await supabase.from("leases").select("*").eq("property_id", property.id);

    const active = leases.filter((l:any)=> norm(l.status)==="active");
    const unitsCount   = units.length;
    const activeCount  = active.length;
    const occupancyPct = unitsCount ? Math.round((activeCount/unitsCount)*1000)/10 : 0;

    const rents = active.map((l:any)=> Number(l.rent_cents ?? l.rent ?? 0))
                        .filter((n:number)=> Number.isFinite(n) && n>=0);
    const avgRentCents = rents.length ? Math.round(rents.reduce((a,b)=>a+b,0)/rents.length) : null;

    return res.json({
      property: { ...property, ...mapAddress(property) },
      units, leases,
      kpis: { units: unitsCount, activeLeases: activeCount, occupancyPct, avgRentCents }
    });
  } catch (e:any) {
    console.error("[rpc:get_property_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

3B) Unit card — robust dual-key + JSON errors
app.get("/api/rpc/get_unit_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const unit = await fetchOneMulti(supabase, "units", id, ["doorloop_unit_id","doorloop_id"]);
    if (!unit) return res.status(404).json({ error: "unit not found", id });

    const property = unit.property_id
      ? await fetchOneMulti(supabase, "properties", unit.property_id, ["doorloop_property_id","doorloop_id"])
      : null;

    const { data: leaseRows } = await supabase
      .from("leases").select("*")
      .or(`unit_id.eq.${unit.id},doorloop_unit_id.eq.${unit.doorloop_unit_id ?? ""}`)
      .limit(1);
    const lease = leaseRows?.[0] ?? null;

    const tenant = lease?.tenant_id
      ? await fetchOneMulti(supabase, "tenants", lease.tenant_id, ["doorloop_tenant_id"])
      : null;

    return res.json({ unit, property: property ? { ...property, ...mapAddress(property)} : null, lease, tenant });
  } catch (e:any) {
    console.error("[rpc:get_unit_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

3C) Lease card — robust dual-key + relations
app.get("/api/rpc/get_lease_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const lease = await fetchOneMulti(supabase, "leases", id, ["doorloop_lease_id","doorloop_id"]);
    if (!lease) return res.status(404).json({ error: "lease not found", id });

    const unit = lease.unit_id
      ? await fetchOneMulti(supabase, "units", lease.unit_id, ["doorloop_unit_id","doorloop_id"])
      : null;

    const property = unit?.property_id
      ? await fetchOneMulti(supabase, "properties", unit.property_id, ["doorloop_property_id","doorloop_id"])
      : null;

    const tenant = lease.tenant_id
      ? await fetchOneMulti(supabase, "tenants", lease.tenant_id, ["doorloop_tenant_id"])
      : null;

    return res.json({ lease, unit, property: property ? { ...property, ...mapAddress(property)} : null, tenant });
  } catch (e:any) {
    console.error("[rpc:get_lease_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

3D) Owner & Tenant — wrap with try/catch + use fetchOneMulti

Ensure both have try/catch and use doorloop_owner_id / doorloop_tenant_id as alternates.

Owner must aggregate KPIs like property: avgRentCents may be null.

4) Frontend: fail-fast but allow “no active leases”

src/pages/card/property/HeroBlock.tsx (compute branch only):

- if (!rents.length) throw new Error("[CONTRACT] No active leases to compute avg rent");
- const avgRentCents = Math.round(rents.reduce((a,b)=>a+b,0)/rents.length);
+ const avgRentCents = rents.length ? Math.round(rents.reduce((a,b)=>a+b,0)/rents.length) : null;


Render:

If avgRentCents === null, show "—" (no masking operator; explicit conditional only).

5) Enrich tabs (non-masking, CardKit only)

For each card (src/pages/card/{property|unit|lease|tenant|owner}/), replace placeholder tab bodies with CardKit:

Example (Property → Overview tab):

import { CardPanel } from "@/components/cardkit/CardPanel";
import FieldGroup from "@/components/cardkit/FieldGroup";

<CardPanel title="Overview" testid="panel-overview">
  <FieldGroup
    items={[
      { label: "Address", value: [data?.property?.address_line1, data?.property?.city, data?.property?.state, data?.property?.zip].filter(Boolean).join(", ") || "—" },
      { label: "Units", value: String(requireField(data?.kpis?.units, "kpis.units")) },
      { label: "Active Leases", value: String(requireField(data?.kpis?.activeLeases, "kpis.activeLeases")) },
      { label: "Occupancy", value: `${requireField(data?.kpis?.occupancyPct, "kpis.occupancyPct")}%` },
    ]}
  />
</CardPanel>


Rules:

Use CardPanel + FieldGroup only.

Use requireField on required contract fields; show "—" only when null is valid by contract (e.g., avgRentCents).

Keep existing testids on KPIs.

6) Start & prove (cards only)
npm run dev
# Prove API on 8787:
curl -s "http://localhost:8787/api/rpc/get_property_card?id=52" | jq '.kpis'
curl -s "http://localhost:8787/api/rpc/get_unit_card?id=45"      | jq '{unit:.unit?.id, lease:.lease?.id}'
curl -s "http://localhost:8787/api/rpc/get_lease_card?id=1"      | jq '{lease:.lease?.id, unit:.unit?.id, tenant:.tenant?.id}'
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=11"     | jq '{owner:.owner?.id, kpis:.kpis}'
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=3"     | jq '{tenant:.tenant?.id, active:.activeLease!=null}'


Open:

/card/property/52 → KPIs render; Avg Rent shows "$750" (your screenshot) or "—" if no actives.

/card/unit/45 → no [CONTRACT] Missing required field: unit.

/card/tenant/3 → no [CONTRACT] Missing required field: tenant.

If any curl returns 404 because a record truly doesn’t exist, do not change code—log the id and stop.

7) Acceptance checklist (must ALL be true)

Guardrail PASS.

Property, Unit, Lease, Tenant, Owner cards render heroes with KPIs.

No masking operators reintroduced.

All five RPCs return JSON, never HTML.

Property Avg Rent shows value or “—” (valid null).

Tabs show enriched content via CardKit (Overview/Financials/Legal/Files skeletons) without legacy imports.

End of prompt.