ECC_OwnerTransfer_AutoFix_Prompt.md
Role

You are a senior Replit engineer. Apply a production-grade, idempotent fix for the Owner Transfer feature. Do all work yourself and show verifications. No prose-only answers.

Non-negotiables

ECC repo: Node/Express API + React/TypeScript frontend, dark theme.

No UI framework changes. No drift from ECC handbook.

Changes must be idempotent, self-verifying, and committed on a feature branch.

Respect secrets: use SUPABASE_DB_URL (already stored in Replit Secrets). Never hardcode secrets.

What to build/fix (end-to-end)

DB migration (automatic, safe):

Create tools/ownerTransfer.migrate.ts (TypeScript) that connects via pg using process.env.SUPABASE_DB_URL (SSL required).

Ensure (create if missing) tables:

owner_transfers

id BIGSERIAL PK

source_owner_id BIGINT

target_owner_id BIGINT

effective_date DATE NOT NULL

include JSONB NOT NULL

notes TEXT

status TEXT DEFAULT 'initiated'

created_at TIMESTAMPTZ DEFAULT now()

owner_transfer_audit

id BIGSERIAL PK

transfer_id BIGINT

action TEXT NOT NULL

actor TEXT DEFAULT 'system'

detail JSONB

created_at TIMESTAMPTZ DEFAULT now()

Use CREATE TABLE IF NOT EXISTS and ALTER TABLE ... ADD COLUMN IF NOT EXISTS so earlier partial tables are repaired (fixes the “column does not exist” error).

If table owners exists, add FKs (if not present):
owner_transfers.(source_owner_id|target_owner_id) → owners(id) and owner_transfer_audit.transfer_id → owner_transfers(id).
Guard with checks so it’s safe if owners is absent.

Create helpful indexes if missing:

idx_owner_transfers_source_owner_id(source_owner_id)

idx_owner_transfers_target_owner_id(target_owner_id)

idx_owner_transfer_audit_transfer_id(transfer_id)

Seed (optional & safe):

If owners exists and owner_transfers is empty, insert one transfer using two owner IDs (or same ID twice if only one exists).
Insert one audit row (action='seeded').
Write the new transfer ID to tools/.last_transfer_id.

API route (backend):

Add server/lib/db.ts if missing (pg Pool using SUPABASE_DB_URL, SSL {rejectUnauthorized:false}).

Add server/routes/ownerTransfer.ts with:

GET /api/owner-transfer/:id → returns { transfer, audit } or 404.

POST /api/owner-transfer/:id/audit → inserts an audit row, returns it.

Wire into server/index.ts: app.use('/api', ownerTransferRouter);

Verification + branch discipline:

Create/Update tools/replit_verify_owner_transfer.sh that:

Runs the TS migration (npx tsx tools/ownerTransfer.migrate.ts).

Prints a concise schema summary (SELECT of column names).

Reads tools/.last_transfer_id if present and curls:

GET /api/owner-transfer/$ID and pretty-prints JSON.

Prints whether SUPABASE_DB_URL is present.

Add npm scripts:

{
  "scripts": {
    "db:migrate:ownerTransfer": "tsx tools/ownerTransfer.migrate.ts",
    "verify:ownerTransfer": "bash tools/replit_verify_owner_transfer.sh"
  }
}


Auto-create feature branch feat/owner-transfer-autofix, commit all changes, show git diff --stat.

UI smoke (minimal & visible):

On page /owners/transfer/detail?id=<id> (existing page), render a small visible block at the top:

Title “Owner Transfer”

transfer.id, source_owner_id → target_owner_id, status

Audit list (action, actor, created_at)

If API 404: render “No transfer found for id=<id>”.

Do not introduce new CSS framework; use ECC dark theme primitives.

If your code can’t find the page/component, mount a temporary route GET /owners/transfer/detail?id=<id> that renders a minimal React view so we can see something now. Keep it guarded so it doesn’t clash with existing router.

Exact code/commands you must produce and run

Install runtime bits (if missing)

Add dev dep tsx and dep pg.

Create files listed above with production-grade code.

Run the migration and verification script.

Start the dev server if not already running.

Demonstrate with outputs.

Output format (strict)

Return one fenced Shell block that you actually executed, which performs:

install deps,

run migration,

run verification,

curl the seeded transfer (if any),

print branch & diff.

Then return:

A QA block: the route URL we should open (with the seeded or example ID),

A short note of which checks passed/failed,

Screenshots request: “Screenshot the visible ‘Owner Transfer’ block.”

Implementation notes (use as-is)

Migration SQL (run via pg in the TS script):

BEGIN;
CREATE TABLE IF NOT EXISTS owner_transfers (
  id BIGSERIAL PRIMARY KEY
);
ALTER TABLE owner_transfers
  ADD COLUMN IF NOT EXISTS source_owner_id BIGINT,
  ADD COLUMN IF NOT EXISTS target_owner_id BIGINT,
  ADD COLUMN IF NOT EXISTS effective_date DATE,
  ADD COLUMN IF NOT EXISTS include JSONB,
  ADD COLUMN IF NOT EXISTS notes TEXT,
  ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'initiated',
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT now();
-- make required
ALTER TABLE owner_transfers
  ALTER COLUMN effective_date SET NOT NULL,
  ALTER COLUMN include SET NOT NULL;

CREATE TABLE IF NOT EXISTS owner_transfer_audit (
  id BIGSERIAL PRIMARY KEY
);
ALTER TABLE owner_transfer_audit
  ADD COLUMN IF NOT EXISTS transfer_id BIGINT,
  ADD COLUMN IF NOT EXISTS action TEXT,
  ADD COLUMN IF NOT EXISTS actor TEXT DEFAULT 'system',
  ADD COLUMN IF NOT EXISTS detail JSONB,
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT now();
ALTER TABLE owner_transfer_audit
  ALTER COLUMN action SET NOT NULL;

-- Add FKs only if targets exist and FK not present
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name='owners') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='owner_transfers_source_owner_id_fkey') THEN
      ALTER TABLE owner_transfers
        ADD CONSTRAINT owner_transfers_source_owner_id_fkey
        FOREIGN KEY (source_owner_id) REFERENCES owners(id);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='owner_transfers_target_owner_id_fkey') THEN
      ALTER TABLE owner_transfers
        ADD CONSTRAINT owner_transfers_target_owner_id_fkey
        FOREIGN KEY (target_owner_id) REFERENCES owners(id);
    END IF;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='owner_transfer_audit_transfer_id_fkey') THEN
    ALTER TABLE owner_transfer_audit
      ADD CONSTRAINT owner_transfer_audit_transfer_id_fkey
      FOREIGN KEY (transfer_id) REFERENCES owner_transfers(id);
  END IF;
END$$;

CREATE INDEX IF NOT EXISTS idx_owner_transfers_source_owner_id ON owner_transfers(source_owner_id);
CREATE INDEX IF NOT EXISTS idx_owner_transfers_target_owner_id ON owner_transfers(target_owner_id);
CREATE INDEX IF NOT EXISTS idx_owner_transfer_audit_transfer_id ON owner_transfer_audit(transfer_id);
COMMIT;


Seeding logic (inside the TS script):

If owners exists and owner_transfers empty, insert one row and one audit row, then write the new transfer id to tools/.last_transfer_id. If owners doesn’t exist, skip seeding and say so.

Definition of Done (Agent must satisfy)

tools/ownerTransfer.migrate.ts exists and is committed.

server/lib/db.ts and server/routes/ownerTransfer.ts exist and are wired in server/index.ts.

Migration ran without error; schema verified; optional seed ID recorded.

curl /api/owner-transfer/<id> returns JSON (or 404 with clear message if no seed).

Minimal UI block is visible on /owners/transfer/detail?id=<id> (or temporary page) and uses ECC dark styles.

Feature branch created, diff shown, all changes committed.

Output includes the exact Shell block executed + a QA block.