0) One-time setup

Environment (server-only)

SUPABASE_URL

SUPABASE_SERVICE_ROLE_KEY

DOORLOOP_BASE_URL (e.g. https://api.doorloop.com/v1)

DOORLOOP_API_KEY (server only)

OWNER_TRANSFER_REPORT_DEST=dropbox (or local)

DROPBOX_ACCESS_TOKEN (if using Dropbox upload)

Install (server)

npm i exceljs zod @supabase/supabase-js

1) Server libs
server/lib/supabaseAdmin.ts
import { createClient } from "@supabase/supabase-js";

const url = process.env.SUPABASE_URL!;
const key = process.env.SUPABASE_SERVICE_ROLE_KEY!;

export const supabaseAdmin = createClient(url, key, {
  auth: { persistSession: false, autoRefreshToken: false },
});

server/lib/audit.ts
import { supabaseAdmin } from "./supabaseAdmin";

type AuditPayload = Record<string, any>;

export async function auditEvent(opts: {
  event_type: string;
  ref_table?: string | null;
  ref_id?: number | null;
  payload?: AuditPayload | null;
  actor_id?: string | null;
  tag?: string | null;
}) {
  const { event_type, ref_table = null, ref_id = null, payload = null, actor_id = null, tag = null } = opts;

  // event_type is NOT NULL in DB
  if (!event_type) throw new Error("auditEvent: event_type required");

  const { error } = await supabaseAdmin.from("audit_events").insert({
    event_type,
    ref_table,
    ref_id,
    payload,
    actor_id,
    tag,
  });

  if (error) {
    // Last resort: don’t crash the request path
    console.error("auditEvent insert failed:", error);
  }
}

server/lib/dropbox.ts
/**
 * Minimal Dropbox uploader (no SDK). Server-side only.
 * Requires: DROPBOX_ACCESS_TOKEN
 */
const DROPBOX_API = "https://content.dropboxapi.com/2/files/upload";
const DROPBOX_SHARE = "https://api.dropboxapi.com/2/sharing/create_shared_link_with_settings";

export async function uploadBufferToDropbox(params: {
  path: string;        // e.g. /reports/owner_transfers/123.xlsx
  buffer: Buffer;
  mode?: "add" | "overwrite";
}): Promise<{ path: string; url?: string }> {
  const token = process.env.DROPBOX_ACCESS_TOKEN;
  if (!token) throw new Error("DROPBOX_ACCESS_TOKEN not set");

  const arg = {
    path: params.path,
    mode: params.mode || "overwrite",
    mute: false,
    strict_conflict: false,
  };

  const res = await fetch(DROPBOX_API, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/octet-stream",
      "Dropbox-API-Arg": JSON.stringify(arg),
    },
    body: params.buffer,
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`Dropbox upload failed: ${res.status} ${txt}`);
  }

  // Create a share link
  const share = await fetch(DROPBOX_SHARE, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ path: (await res.json()).path_lower }),
  });

  let url: string | undefined = undefined;
  if (share.ok) {
    const s = await share.json();
    url = s?.url;
    // Convert ?dl=0 to ?dl=1 to force download
    if (url) url = url.replace(/\?dl=0$/, "?dl=1");
  }

  return { path: params.path, url };
}

2) Owner Transfer service (server)
server/services/ownerTransferService.ts
import { z } from "zod";
import ExcelJS from "exceljs";
import { supabaseAdmin } from "../lib/supabaseAdmin";
import { auditEvent } from "../lib/audit";
import { uploadBufferToDropbox } from "../lib/dropbox";

const InitiateSchema = z.object({
  propertyIds: z.array(z.number().int()).min(1),
  newOwnerId: z.number().int(),
  effectiveDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  notes: z.string().optional(),
  initiatedBy: z.string().uuid().optional(),
});

export type InitiateInput = z.infer<typeof InitiateSchema>;

async function fetchEntitySnapshots(propertyIds: number[]) {
  // Adjust table/column names to your schema.
  // Properties
  const props = await supabaseAdmin.from("properties")
    .select("*")
    .in("id", propertyIds);

  if (props.error) throw props.error;

  // Units
  const units = await supabaseAdmin.from("units")
    .select("*")
    .in("property_id", propertyIds);
  if (units.error) throw units.error;

  // Leases
  const leases = await supabaseAdmin.from("leases")
    .select("*")
    .in("property_id", propertyIds);
  if (leases.error) throw leases.error;

  // Tenants (via leases if you have a join table; here we just fetch all tenants referenced by leases)
  const tenantIds = Array.from(new Set((leases.data ?? []).map(l => l.primary_tenant_id).filter(Boolean)));
  const tenants = tenantIds.length
    ? await supabaseAdmin.from("tenants").select("*").in("id", tenantIds)
    : { data: [], error: null };
  if (tenants && "error" in tenants && tenants.error) throw tenants.error;

  // Financials & Ops (adjust to your schemas)
  const leaseIds = Array.from(new Set((leases.data ?? []).map(l => l.id)));
  const payments = leaseIds.length
    ? await supabaseAdmin.from("lease_payments").select("*").in("lease_id", leaseIds)
    : { data: [], error: null };
  if (payments && "error" in payments && payments.error) throw payments.error;

  const charges = leaseIds.length
    ? await supabaseAdmin.from("lease_charges").select("*").in("lease_id", leaseIds)
    : { data: [], error: null };
  if (charges && "error" in charges && charges.error) throw charges.error;

  const credits = leaseIds.length
    ? await supabaseAdmin.from("lease_credits").select("*").in("lease_id", leaseIds)
    : { data: [], error: null };
  if (credits && "error" in credits && credits.error) throw credits.error;

  const workOrders = await supabaseAdmin.from("work_orders").select("*").in("property_id", propertyIds);
  if (workOrders.error) throw workOrders.error;

  const communications = await supabaseAdmin.from("communications").select("*").in("property_id", propertyIds);
  if (communications.error) throw communications.error;

  const files = await supabaseAdmin.from("files").select("*").in("property_id", propertyIds);
  if (files.error) throw files.error;

  const notes = await supabaseAdmin.from("notes").select("*").in("property_id", propertyIds);
  if (notes.error) throw notes.error;

  return {
    properties: props.data ?? [],
    units: units.data ?? [],
    leases: leases.data ?? [],
    tenants: (tenants as any).data ?? [],
    lease_payments: (payments as any).data ?? [],
    lease_charges: (charges as any).data ?? [],
    lease_credits: (credits as any).data ?? [],
    work_orders: workOrders.data ?? [],
    communications: communications.data ?? [],
    files: files.data ?? [],
    notes: notes.data ?? [],
  };
}

export async function initiateTransfer(input: InitiateInput) {
  const parsed = InitiateSchema.parse(input);

  // Create transfer record
  const { data, error } = await supabaseAdmin.from("owner_transfers").insert({
    property_ids: parsed.propertyIds,
    old_owner_id: null, // filled below
    new_owner_id: parsed.newOwnerId,
    effective_date: parsed.effectiveDate,
    status: "PENDING_ACCOUNTING",
    notes: parsed.notes ?? null,
    initiated_by: parsed.initiatedBy ?? null,
  }).select("id").single();

  if (error) throw error;

  const transferId = data.id as number;

  await auditEvent({
    event_type: "OWNER_TRANSFER_INIT",
    ref_table: "owner_transfers",
    ref_id: transferId,
    payload: { input: parsed },
    actor_id: parsed.initiatedBy ?? null,
  });

  // Determine old_owner_id (from the first property)
  const first = await supabaseAdmin.from("properties").select("owner_id").eq("id", parsed.propertyIds[0]).single();
  if (!first.error && first.data) {
    await supabaseAdmin.from("owner_transfers").update({ old_owner_id: first.data.owner_id }).eq("id", transferId);
  }

  // Snapshots
  const snap = await fetchEntitySnapshots(parsed.propertyIds);
  const rows: any[] = [];

  function pushRows(entity_type: string, arr: any[], idKey = "id") {
    for (const r of arr) {
      rows.push({
        transfer_id: transferId,
        entity_type,
        entity_id: r[idKey] ?? 0,
        raw_jsonb: r,
      });
    }
  }

  pushRows("property", snap.properties);
  pushRows("unit", snap.units);
  pushRows("lease", snap.leases);
  pushRows("tenant", snap.tenants);
  pushRows("lease_payment", snap.lease_payments);
  pushRows("lease_charge", snap.lease_charges);
  pushRows("lease_credit", snap.lease_credits);
  pushRows("work_order", snap.work_orders);
  pushRows("communication", snap.communications);
  pushRows("file", snap.files);
  pushRows("note", snap.notes);

  // Chunk insert to avoid timeouts
  const chunkSize = 500;
  for (let i = 0; i < rows.length; i += chunkSize) {
    const slice = rows.slice(i, i + chunkSize);
    const { error: e } = await supabaseAdmin.from("owner_transfer_snapshots").insert(slice);
    if (e) throw e;
  }

  await auditEvent({
    event_type: "OWNER_TRANSFER_SNAPSHOT_DONE",
    ref_table: "owner_transfers",
    ref_id: transferId,
    payload: { counts: Object.fromEntries(Object.entries(snap).map(([k,v]) => [k, (v as any[]).length])) },
  });

  return { transferId };
}

export async function generateAccountingReport(transferId: number) {
  // Fetch transfer
  const t = await supabaseAdmin.from("owner_transfers").select("*").eq("id", transferId).single();
  if (t.error) throw t.error;
  const transfer = t.data;

  // Build Excel
  const wb = new ExcelJS.Workbook();
  wb.creator = "ECC";
  wb.created = new Date();

  const summary = wb.addWorksheet("Summary");
  summary.columns = [
    { header: "Transfer ID", key: "id" },
    { header: "Old Owner ID", key: "old_owner_id" },
    { header: "New Owner ID", key: "new_owner_id" },
    { header: "Effective Date", key: "effective_date" },
    { header: "Status", key: "status" },
  ];
  summary.addRow({
    id: transfer.id,
    old_owner_id: transfer.old_owner_id,
    new_owner_id: transfer.new_owner_id,
    effective_date: transfer.effective_date,
    status: transfer.status,
  });

  // TODO: add Income / Expenses / Pending sheets by querying your accounting tables

  const buffer = await wb.xlsx.writeBuffer();
  const filename = `owner_transfer_${transferId}.xlsx`;

  let reportUrl: string | undefined;
  if ((process.env.OWNER_TRANSFER_REPORT_DEST || "dropbox") === "dropbox") {
    const path = `/reports/owner_transfers/${filename}`;
    const up = await uploadBufferToDropbox({ path, buffer: Buffer.from(buffer) });
    reportUrl = up.url;
  }

  await auditEvent({
    event_type: "OWNER_TRANSFER_REPORT_BUILT",
    ref_table: "owner_transfers",
    ref_id: transferId,
    payload: { reportUrl: reportUrl || null, filename },
  });

  return { buffer: Buffer.from(buffer), filename, reportUrl };
}

export async function markApprovedByAccounting(transferId: number, actorId?: string) {
  const { error } = await supabaseAdmin.from("owner_transfers")
    .update({ status: "APPROVED_ACCOUNTING" })
    .eq("id", transferId);
  if (error) throw error;

  await auditEvent({
    event_type: "OWNER_TRANSFER_APPROVE_ACCOUNTING",
    ref_table: "owner_transfers",
    ref_id: transferId,
    actor_id: actorId ?? null,
  });
}

export async function authorizeExecution(transferId: number, actorId?: string) {
  const { error } = await supabaseAdmin.from("owner_transfers")
    .update({ status: "READY_EXECUTION" })
    .eq("id", transferId);
  if (error) throw error;

  await auditEvent({
    event_type: "OWNER_TRANSFER_AUTHORIZED",
    ref_table: "owner_transfers",
    ref_id: transferId,
    actor_id: actorId ?? null,
  });
}

export async function executeTransfer(transferId: number, opts?: { dryRun?: boolean }) {
  const dryRun = opts?.dryRun !== false; // default true

  // Fetch transfer
  const t = await supabaseAdmin.from("owner_transfers").select("*").eq("id", transferId).single();
  if (t.error) throw t.error;
  const transfer = t.data;

  // Fetch properties to move
  const p = await supabaseAdmin.from("properties").select("id, owner_id").in("id", transfer.property_ids);
  if (p.error) throw p.error;
  const properties = p.data ?? [];

  // Prepare write-backs (DB first, then DoorLoop if enabled)
  const summary: any = { propertiesAffected: properties.length, dryRun, doorloopCalls: 0 };

  // ECC DB updates (preview if dryRun)
  if (!dryRun) {
    const { error } = await supabaseAdmin.from("properties")
      .update({ owner_id: transfer.new_owner_id })
      .in("id", transfer.property_ids);
    if (error) throw error;
  }

  // DoorLoop write-back
  if (!dryRun && process.env.DOORLOOP_API_KEY && process.env.DOORLOOP_BASE_URL) {
    const headers = {
      "Authorization": `Bearer ${process.env.DOORLOOP_API_KEY}`,
      "Content-Type": "application/json",
      "Idempotency-Key": `transfer-${transferId}-${transfer.effective_date}`,
    };

    for (const prop of properties) {
      const url = `${process.env.DOORLOOP_BASE_URL}/properties/${prop.id}`;
      const res = await fetch(url, { method: "PUT", headers, body: JSON.stringify({ ownerId: transfer.new_owner_id }) });
      await auditEvent({
        event_type: "OWNER_TRANSFER_WRITEBACK",
        ref_table: "properties",
        ref_id: prop.id,
        payload: { status: res.status },
      });
      summary.doorloopCalls++;
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`DoorLoop property update failed: ${res.status} ${txt}`);
      }
    }
  }

  if (!dryRun) {
    const { error } = await supabaseAdmin.from("owner_transfers")
      .update({ status: "COMPLETE", executed_at: new Date().toISOString() })
      .eq("id", transferId);
    if (error) throw error;

    await auditEvent({
      event_type: "OWNER_TRANSFER_COMPLETE",
      ref_table: "owner_transfers",
      ref_id: transferId,
      payload: summary,
    });
  }

  return { applied: !dryRun, summary };
}

3) Server routes (surgical add)
Edit server/index.ts — add these endpoints
import express from "express";
import {
  initiateTransfer,
  generateAccountingReport,
  markApprovedByAccounting,
  authorizeExecution,
  executeTransfer,
} from "./services/ownerTransferService";

const app = /* your existing app */ (global as any).app || express();
app.use(express.json());

// Helpers to detect admin (adjust to your auth)
function isAdmin(req: any) {
  // Example: req.user?.role === 'admin'
  return Boolean(req?.user?.isAdmin);
}

app.post("/api/owner-transfer/initiate", async (req, res) => {
  try {
    const { transferId } = await initiateTransfer(req.body);
    const report = await generateAccountingReport(transferId);
    res.status(201).json({ transferId, reportUrl: report.reportUrl ?? null });
  } catch (e:any) {
    console.error(e);
    res.status(400).json({ error: e.message || "initiate failed" });
  }
});

app.post("/api/owner-transfer/approve-accounting", async (req, res) => {
  try {
    const { transferId } = req.body as { transferId: number };
    await markApprovedByAccounting(transferId, req.user?.id);
    res.json({ ok: true });
  } catch (e:any) {
    res.status(400).json({ error: e.message });
  }
});

app.post("/api/owner-transfer/authorize", async (req, res) => {
  try {
    if (!isAdmin(req)) return res.status(403).json({ error: "forbidden" });
    const { transferId } = req.body as { transferId: number };
    await authorizeExecution(transferId, req.user?.id);
    res.json({ ok: true });
  } catch (e:any) {
    res.status(400).json({ error: e.message });
  }
});

app.post("/api/owner-transfer/execute", async (req, res) => {
  try {
    if (!isAdmin(req)) return res.status(403).json({ error: "forbidden" });
    const { transferId, dryRun = true } = req.body as { transferId: number; dryRun?: boolean };
    const out = await executeTransfer(transferId, { dryRun });
    res.json(out);
  } catch (e:any) {
    res.status(400).json({ error: e.message });
  }
});

app.get("/api/owner-transfer/:id/report", async (req, res) => {
  try {
    const id = Number(req.params.id);
    const { buffer, filename } = await generateAccountingReport(id);
    res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
    res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    res.send(buffer);
  } catch (e:any) {
    res.status(404).json({ error: e.message || "report not found" });
  }
});

// export app if your runtime needs it
export default app;

4) Frontend hook
src/features/ownerTransfer/hooks/useOwnerTransfer.ts
import { useCallback } from "react";

type Json = Record<string, any>;

async function postJSON<T>(url: string, body: Json): Promise<T> {
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  if (!res.ok) throw new Error(await res.text());
  return res.json() as Promise<T>;
}

export function useOwnerTransfer() {
  const initiate = useCallback((args: {
    propertyIds: number[];
    newOwnerId: number;
    effectiveDate: string; // YYYY-MM-DD
    notes?: string;
    initiatedBy?: string;
  }) => postJSON<{ transferId:number; reportUrl: string | null }>("/api/owner-transfer/initiate", args), []);

  const approveAccounting = useCallback((transferId: number) =>
    postJSON<{ ok:true }>("/api/owner-transfer/approve-accounting", { transferId }), []);

  const authorize = useCallback((transferId: number) =>
    postJSON<{ ok:true }>("/api/owner-transfer/authorize", { transferId }), []);

  const execute = useCallback((transferId: number, dryRun = true) =>
    postJSON<{ applied:boolean; summary:any }>("/api/owner-transfer/execute", { transferId, dryRun }), []);

  const reportUrl = (transferId: number) => `/api/owner-transfer/${transferId}/report`;

  return { initiate, approveAccounting, authorize, execute, reportUrl };
}

5) Frontend stepper (contained)
src/features/ownerTransfer/components/TransferStepper.tsx
import React, { useMemo, useState } from "react";
import { useOwnerTransfer } from "../hooks/useOwnerTransfer";

type Props = {
  ownerId: number;                 // current owner page context
  propertyIds: number[];           // from owner card context
  onClose: () => void;
  canAuthorize?: boolean;          // pass from user role
};

export default function TransferStepper({ ownerId, propertyIds, onClose, canAuthorize }: Props) {
  const [step, setStep] = useState<1|2|3|4>(1);
  const [newOwnerId, setNewOwnerId] = useState<number | null>(null);
  const [effectiveDate, setEffectiveDate] = useState("");
  const [notes, setNotes] = useState("");
  const [transferId, setTransferId] = useState<number | null>(null);
  const [reportUrl, setReportUrl] = useState<string | null>(null);
  const [dryRun, setDryRun] = useState(true);
  const [busy, setBusy] = useState(false);
  const { initiate, approveAccounting, authorize, execute, reportUrl: makeReportUrl } = useOwnerTransfer();

  const canNext1 = useMemo(() => !!newOwnerId && newOwnerId !== ownerId, [newOwnerId, ownerId]);
  const canNext2 = useMemo(() => /^\d{4}-\d{2}-\d{2}$/.test(effectiveDate), [effectiveDate]);

  async function onInit() {
    if (!canNext1 || !canNext2) return;
    setBusy(true);
    try {
      const out = await initiate({
        propertyIds,
        newOwnerId: newOwnerId!,
        effectiveDate,
        notes,
      });
      setTransferId(out.transferId);
      setReportUrl(out.reportUrl ?? makeReportUrl(out.transferId));
      setStep(4);
    } catch (e:any) {
      alert(e.message || "Initiation failed");
    } finally {
      setBusy(false);
    }
  }

  async function onApprove() {
    if (!transferId) return;
    setBusy(true);
    try {
      await approveAccounting(transferId);
      alert("Accounting marked approved.");
    } catch (e:any) {
      alert(e.message || "Approve failed");
    } finally { setBusy(false); }
  }

  async function onAuthorize() {
    if (!transferId) return;
    setBusy(true);
    try {
      await authorize(transferId);
      alert("Authorized for execution.");
    } catch (e:any) {
      alert(e.message || "Authorize failed");
    } finally { setBusy(false); }
  }

  async function onExecute() {
    if (!transferId) return;
    setBusy(true);
    try {
      const out = await execute(transferId, dryRun);
      alert(dryRun ? "Dry-run complete. See audit log." : "Execution complete.");
      if (!dryRun) onClose();
      console.log("Execution summary:", out.summary);
    } catch (e:any) {
      alert(e.message || "Execute failed");
    } finally { setBusy(false); }
  }

  return (
    <div className="ecc-panel p-4 max-w-3xl w-full">
      <div className="flex items-center justify-between mb-3">
        <h3 className="text-lg">Transfer Ownership</h3>
        <button className="ecc-btn" onClick={onClose}>Close</button>
      </div>

      {step === 1 && (
        <div className="space-y-3">
          <div className="small-label">New Owner ID</div>
          <input className="ecc-input w-full" placeholder="e.g. 421" type="number"
                 value={newOwnerId ?? ""} onChange={(e)=>setNewOwnerId(Number(e.target.value)||null)} />
          <div className="text-xs text-[var(--text-dim)]">Must be different from current owner {ownerId}.</div>
          <div className="flex gap-2 mt-3">
            <button className="ecc-btn ecc-btn--secondary" onClick={onClose}>Cancel</button>
            <button className="ecc-btn ecc-btn--primary" disabled={!canNext1} onClick={()=>setStep(2)}>Next</button>
          </div>
        </div>
      )}

      {step === 2 && (
        <div className="space-y-3">
          <div className="small-label">Effective Date (YYYY-MM-DD)</div>
          <input className="ecc-input w-full" placeholder="2025-09-15"
                 value={effectiveDate} onChange={(e)=>setEffectiveDate(e.target.value)} />
          <div className="small-label">Notes (optional)</div>
          <textarea className="ecc-input w-full" rows={3} value={notes} onChange={(e)=>setNotes(e.target.value)} />

          <div className="flex gap-2 mt-3">
            <button className="ecc-btn ecc-btn--secondary" onClick={()=>setStep(1)}>Back</button>
            <button className="ecc-btn ecc-btn--primary" disabled={!canNext2} onClick={()=>setStep(3)}>Next</button>
          </div>
        </div>
      )}

      {step === 3 && (
        <div className="space-y-3">
          <div className="small-label mb-1">Confirm Entities</div>
          <div className="text-sm">Properties selected: <strong>{propertyIds.length}</strong></div>
          <div className="text-xs text-[var(--text-dim)]">A detailed snapshot will be captured automatically.</div>
          <div className="flex gap-2 mt-3">
            <button className="ecc-btn ecc-btn--secondary" onClick={()=>setStep(2)}>Back</button>
            <button className="ecc-btn ecc-btn--primary" disabled={busy} onClick={onInit}>
              {busy ? "Working..." : "Generate Accounting Report"}
            </button>
          </div>
        </div>
      )}

      {step === 4 && (
        <div className="space-y-3">
          <div className="small-label">Accounting Report</div>
          {reportUrl ? (
            <a className="ecc-link" href={reportUrl} target="_blank" rel="noreferrer">Download transfer report</a>
          ) : (
            <div className="text-xs text-[var(--text-dim)]">Report available via server endpoint.</div>
          )}

          <div className="flex gap-2 mt-3">
            <button className="ecc-btn" onClick={onApprove} disabled={busy}>Mark Approved by Accounting</button>
          </div>

          {canAuthorize && (
            <>
              <div className="flex items-center gap-2 mt-2">
                <input id="dryrun" type="checkbox" checked={dryRun} onChange={(e)=>setDryRun(e.target.checked)} />
                <label htmlFor="dryrun" className="text-sm">Dry-run mode</label>
              </div>
              <div className="flex gap-2">
                <button className="ecc-btn" onClick={onAuthorize} disabled={busy}>Authorize Execution</button>
                <button className="ecc-btn ecc-btn--danger" onClick={onExecute} disabled={busy}>
                  {dryRun ? "Execute (Dry Run)" : "Execute (Commit)"}
                </button>
              </div>
            </>
          )}
        </div>
      )}
    </div>
  );
}


Integration note (surgical): On your Owner Hub page (e.g. src/pages/card/owner/[id].tsx), add a “Transfer Ownership” button in the left rail that toggles this stepper. Pass the ownerId, a propertyIds array for that owner, and canAuthorize based on the current user role. Do not change global navigation or styles.

6) Quick cURL tests
# Initiate (generates report)
curl -s -X POST http://localhost:3000/api/owner-transfer/initiate \
  -H "Content-Type: application/json" \
  -d '{"propertyIds":[160,161], "newOwnerId":421, "effectiveDate":"2025-09-15"}'

# Approve accounting
curl -s -X POST http://localhost:3000/api/owner-transfer/approve-accounting \
  -H "Content-Type: application/json" \
  -d '{"transferId": 1}'

# Authorize (admin only)
curl -s -X POST http://localhost:3000/api/owner-transfer/authorize \
  -H "Content-Type: application/json" \
  -d '{"transferId": 1}'

# Execute dry-run (default true)
curl -s -X POST http://localhost:3000/api/owner-transfer/execute \
  -H "Content-Type: application/json" \
  -d '{"transferId": 1, "dryRun": true}'

# Execute commit (admin + DoorLoop creds)
curl -s -X POST http://localhost:3000/api/owner-transfer/execute \
  -H "Content-Type: application/json" \
  -d '{"transferId": 1, "dryRun": false}'

7) README (drop this in README_OWNER_TRANSFER.md)

Feature: Owner Transfer Cutover (DoorLoop ↔ ECC)

Flow: Initiate → Snapshot → Report → Accounting Approval → Admin Authorize → Execute (DB first, then DoorLoop)

Env: SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, DOORLOOP_BASE_URL, DOORLOOP_API_KEY, OWNER_TRANSFER_REPORT_DEST, DROPBOX_ACCESS_TOKEN

Endpoints: /api/owner-transfer/initiate, /approve-accounting, /authorize, /execute, and GET /:id/report

Auditing: every step logs an audit_events row with event_type starting OWNER_TRANSFER_*

Reports: stored in Dropbox (shared link) when OWNER_TRANSFER_REPORT_DEST=dropbox; otherwise available via GET endpoint.