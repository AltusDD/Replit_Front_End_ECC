You're past the “blocked host” wall. Now React is mounting, starting a query, immediately unmounting (React 18 Strict Mode dev double-mount), and TanStack Query is canceling the in-flight fetch. Your fetch layer treats that cancel as a hard error, so the error boundary shows:

AbortError: signal is aborted without reason

Fix = 3 surgical patches. Do these exactly, in order.

1) Add a cancel-safe fetch helper and AbortError detector

Create (or replace) src/lib/http.ts:

// src/lib/http.ts
export function isAbortError(err: unknown): boolean {
  // DOMException name/message varies by browser/runtime
  // TanStack also uses CancelledError; keep it quiet
  // We treat ALL of these as benign cancels
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const e: any = err;
  return (
    e?.name === "AbortError" ||
    e?.name === "CanceledError" ||
    e?.constructor?.name === "CancelledError" ||
    /signal is aborted|aborted without reason|The user aborted a request/i.test(
      String(e?.message || "")
    )
  );
}

export async function fetchJSON<T = unknown>(
  url: string,
  opts: RequestInit & { signal?: AbortSignal } = {}
): Promise<T> {
  try {
    const res = await fetch(url, { ...opts, signal: opts.signal });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(`[HTTP ${res.status}] ${url} ${text}`.trim());
    }
    return (await res.json()) as T;
  } catch (err) {
    if (isAbortError(err)) {
      // Return a never-resolving promise to mark as “canceled” to React Query
      // (alternatively: `throw new Error('__CANCEL__')`, but this is cleaner)
      return new Promise<never>(() => {});
    }
    throw err;
  }
}

2) Wire React Query to pass its signal into your fetch

Edit your card resolvers to use the queryFn context signature.
Open src/lib/ecc-resolvers.ts (and any other file where you call useQuery) and update each query to:

import { useQuery } from "@tanstack/react-query";
import { fetchJSON } from "@/lib/http";

// Example: Property Card
export function usePropertyCard(id: number) {
  return useQuery({
    queryKey: ["property-card", id],
    // IMPORTANT: consume { signal } and pass to fetchJSON
    queryFn: ({ signal }) =>
      fetchJSON(`/api/rpc/get_property_card?id=${id}`, { signal }),
    staleTime: 30_000,
    gcTime: 5 * 60_000,
    retry: 1,
  });
}

// Do the same for unit/lease/tenant/owner:
export function useUnitCard(id: number) {
  return useQuery({
    queryKey: ["unit-card", id],
    queryFn: ({ signal }) =>
      fetchJSON(`/api/rpc/get_unit_card?id=${id}`, { signal }),
    staleTime: 30_000,
    gcTime: 5 * 60_000,
    retry: 1,
  });
}

export function useLeaseCard(id: number) {
  return useQuery({
    queryKey: ["lease-card", id],
    queryFn: ({ signal }) =>
      fetchJSON(`/api/rpc/get_lease_card?id=${id}`, { signal }),
    staleTime: 30_000,
    gcTime: 5 * 60_000,
    retry: 1,
  });
}

export function useTenantCard(id: number) {
  return useQuery({
    queryKey: ["tenant-card", id],
    queryFn: ({ signal }) =>
      fetchJSON(`/api/rpc/get_tenant_card?id=${id}`, { signal }),
    staleTime: 30_000,
    gcTime: 5 * 60_000,
    retry: 1,
  });
}

export function useOwnerCard(id: number) {
  return useQuery({
    queryKey: ["owner-card", id],
    queryFn: ({ signal }) =>
      fetchJSON(`/api/rpc/get_owner_card?id=${id}`, { signal }),
    staleTime: 30_000,
    gcTime: 5 * 60_000,
    retry: 1,
  });
}


If you have any other useQuery({ queryFn: () => fetch(...) }) calls anywhere (portfolio tables, dashboards, etc.), change them to ({signal}) => fetchJSON(url, {signal}) the same way.

3) Make the error boundary ignore benign cancels (so dev doesn’t “white-screen”)

Edit src/components/EccErrorBoundary.tsx to use the abort detector. Replace its error checks with:

import React from "react";
import { isAbortError } from "@/lib/http";

type State = { hasError: boolean; error?: unknown };

export default class EccErrorBoundary extends React.Component<
  React.PropsWithChildren,
  State
> {
  state: State = { hasError: false };

  static getDerivedStateFromError(error: unknown): State {
    // Swallow aborted/canceled fetches (StrictMode dev double-mount)
    if (isAbortError(error)) return { hasError: false };
    return { hasError: true, error };
  }

  componentDidCatch(error: unknown) {
    if (isAbortError(error)) return;
    // eslint-disable-next-line no-console
    console.error("[ECC] Unhandled error:", error);
  }

  render() {
    if (!this.state.hasError) return this.props.children;
    return (
      <div style={{ padding: 16 }}>
        <h2>Contract violation</h2>
        <pre style={{ whiteSpace: "pre-wrap" }}>
          {String((this.state.error as any)?.message || this.state.error)}
        </pre>
      </div>
    );
  }
}


If main.tsx imports it as a named export, keep the default export and add:

export { EccErrorBoundary as default } from "./EccErrorBoundary"; // if you already have this style elsewhere


But simplest is to import the default:

// src/main.tsx
import EccErrorBoundary from "./components/EccErrorBoundary";

(Optional sanity switch) Disable Strict Mode only if you still see aborts

Strict Mode is why you see the cancel immediately in dev. With the two fixes above you shouldn’t need this, but if you want a temporary sanity toggle:

// src/main.tsx
import React from "react";
// const Mode = React.StrictMode;           // old
const Mode = React.Fragment;               // temporary while stabilizing

root.render(
  <Mode>
    <EccErrorBoundary>{/* ... */}</EccErrorBoundary>
  </Mode>
);


Re-enable React.StrictMode once everything is clean.

Verify

Stop & Run. Hard refresh the preview (Ctrl/Cmd+Shift+R).

Open the browser console; you should not see the AbortError anymore.

Hit a real route (e.g. /portfolio/properties then /card/property/52).

If any endpoint returns a real error, you’ll get your contract violation message—not a white screen.

This keeps your fail-fast contract behavior, but treats cancellations as non-errors (as they should be).