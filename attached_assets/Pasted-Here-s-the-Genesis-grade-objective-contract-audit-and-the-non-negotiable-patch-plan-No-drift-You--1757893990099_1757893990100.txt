Here’s the Genesis-grade, objective contract audit and the non-negotiable patch plan. No drift. You’ll get:

exactly what’s present (by layer and by file),

what’s missing, and

a drop-in harness to prove it end-to-end on your side.

I’ve tied each claim to your runbooks/hardening docs so this is traceable.

What’s Present (objective, by layer)
Backend (API)

RPC endpoints for all 5 asset cards are in place and follow the CSP v2 BFF pattern: /api/rpc/get_property_card, /get_unit_card, /get_lease_card, /get_tenant_card, /get_owner_card. They normalize status and compute Property/Owner KPIs (units, activeLeases, occupancy, avgRent), and they include address normalization helpers (city/state/zip/street1) as mandated by CSP v2.

Entities endpoints exist for raw JSON (+ simple filter grammar) and act as the fallback source of truth for resolvers.

Server-side client is centralized (server/db.ts) and reads server-only Supabase keys (aliases accepted) — consistent with the contract that admin secrets never reach the browser.

Frontend (Data layer)

RPC-first resolvers exist for all 5 cards with /entities fallback and Zod DTOs (Property, Unit, Lease, Tenant, Owner) — this is the correct CSP v2 posture.

Verification checklist and smoke tests for both API and UI are already codified in your CSP v2 runbook (ports, curls, and URLs).

UI (Cards & Shell)

All 5 card pages exist and import from the resolvers. The Property card is the most complete (correct ID coercion, test IDs on KPIs, normalized address display). This matches the Runbook’s file map and “What Done Looks Like (Phase 1)”.

Theme & guardrails are installed (Altus UI Theme Foundation v1, Nav Fortress, Husky/ESLint/Prettier), and ECS dark theme (Altus black/gold) is the policy for ECC.

What’s Missing / Failing (hard blockers to 100% compliance)

App not running → no dynamic verification possible right now. Dev should be: Vite on 5173, API on 8787 per CSP v2; the verification script expects that.

Parameter coercion is inconsistent on 4 cards (Unit/Lease/Tenant/Owner): some still pass string IDs into hooks. This violates the DTO contract and causes silent cache misses.

Routing pattern inconsistent: some pages use useParams instead of the established useRoute("/card/{type}/:id") pattern — drift risk and test fragility. (Your Replit playbook explicitly forbids router drift and requires guardrails.)

Test IDs incomplete: Property KPIs instrumented; the other 4 cards lack required data-testid hooks. Your guardrail script exists but does not yet enforce them for all cards. (Hardening kit expects selector/test gates.)

Dictated Fix Plan (do these verbatim)

This is frontend-only and contract-safe. No operational server edits.

A) Start services & smoke the API/UI (must pass before/after)
# 1) Install & dev per runbook
npm install
npm run dev  # Vite:5173 (UI) + API:8787

# 2) Backend smoke (pick a real property id, e.g. 42)
curl -s http://localhost:8787/api/entities/properties/42 | jq '{id,name,owner_id}'
curl -s "http://localhost:8787/api/entities/units?property_id=eq.42" | jq 'length'
curl -s "http://localhost:8787/api/rpc/get_property_card?id=42" | jq '{p:.property.id,u:(.kpis.units),a:(.kpis.activeLeases),o:(.kpis.occupancyPct)}'
# 3) UI routes (open in browser)
# http://localhost:5173/card/property/42  and /portfolio/properties


(These are exactly the CSP v2 verification commands.)

B) Normalize ID coercion + route pattern across all 5 cards

Replace the top of each page to always parse numeric id via useRoute.

src/pages/card/property/index.tsx (golden pattern — already good, keep as is).
Apply the same shape below to the other four pages.

src/pages/card/unit/index.tsx

import { useRoute } from "wouter";
import { ErrorBoundary } from "@/components/ErrorBoundary";
export default function UnitCardPage() {
  const [, params] = useRoute("/card/unit/:id");
  const idNum = Number(params?.id);
  const q = useUnitCard(idNum);
  if (!Number.isFinite(idNum)) return <div data-testid="unit-invalid">Invalid unit id</div>;
  return <ErrorBoundary>{/* existing layout using q.data/q.isLoading */}</ErrorBoundary>;
}


src/pages/card/lease/index.tsx

import { useRoute } from "wouter";
import { ErrorBoundary } from "@/components/ErrorBoundary";
export default function LeaseCardPage() {
  const [, params] = useRoute("/card/lease/:id");
  const idNum = Number(params?.id);
  const q = useLeaseCard(idNum);
  if (!Number.isFinite(idNum)) return <div data-testid="lease-invalid">Invalid lease id</div>;
  return <ErrorBoundary>{/* existing layout */}</ErrorBoundary>;
}


src/pages/card/tenant/index.tsx

import { useRoute } from "wouter";
import { ErrorBoundary } from "@/components/ErrorBoundary";
export default function TenantCardPage() {
  const [, params] = useRoute("/card/tenant/:id");
  const idNum = Number(params?.id);
  const q = useTenantCard(idNum);
  if (!Number.isFinite(idNum)) return <div data-testid="tenant-invalid">Invalid tenant id</div>;
  return <ErrorBoundary>{/* existing layout */}</ErrorBoundary>;
}


src/pages/card/owner/index.tsx

import { useRoute } from "wouter";
import { ErrorBoundary } from "@/components/ErrorBoundary";
export default function OwnerCardPage() {
  const [, params] = useRoute("/card/owner/:id");
  const idNum = Number(params?.id);
  const q = useOwnerCard(idNum);
  if (!Number.isFinite(idNum)) return <div data-testid="owner-invalid">Invalid owner id</div>;
  return <ErrorBoundary>{/* existing layout */}</ErrorBoundary>;
}


Why this is contract-correct: CSP v2 mandates one resolver per card and stable hook counts; passing numbers stabilizes TanStack Query keys and avoids silent cache divergence.

C) Add test IDs to all 5 hero rows (consistent selectors)

Add these to each card hero block (keep your existing UI; just add data-testid):

Property: kpi-units, kpi-active, kpi-occupancy, kpi-avgrent (already present)

Unit: kpi-lease-status, kpi-rent, kpi-bedbath, kpi-sqft

Lease: kpi-lease-status, kpi-rent, kpi-term, kpi-balance

Tenant: kpi-active-leases, kpi-current-balance, kpi-on-time-rate, kpi-open-workorders

Owner: kpi-portfolio-units, kpi-active-leases, kpi-occupancy, kpi-avg-rent

(Your hardening kit and selector adapter expect consistent, testable hooks.)

D) Enforce with Guardrail (extend script you already have)

Append to scripts/guardrail-check.mjs:

// ID coercion pattern (useRoute + Number(...))
const idPatterns = {
  "src/pages/card/property/index.tsx": [/useRoute\\(\"\\/card\\/property\\/:id\"\\)/, /Number\\(params\\?\\.id\\)/],
  "src/pages/card/unit/index.tsx":     [/useRoute\\(\"\\/card\\/unit\\/:id\"\\)/,     /Number\\(params\\?\\.id\\)/],
  "src/pages/card/lease/index.tsx":    [/useRoute\\(\"\\/card\\/lease\\/:id\"\\)/,    /Number\\(params\\?\\.id\\)/],
  "src/pages/card/tenant/index.tsx":   [/useRoute\\(\"\\/card\\/tenant\\/:id\"\\)/,   /Number\\(params\\?\\.id\\)/],
  "src/pages/card/owner/index.tsx":    [/useRoute\\(\"\\/card\\/owner\\/:id\"\\)/,    /Number\\(params\\?\\.id\\)/],
};

for (const [file, pats] of Object.entries(idPatterns)) {
  const p = path.join(ROOT, file);
  if (!fs.existsSync(p)) { console.error('[guardrail] missing', file); failures++; continue; }
  const s = fs.readFileSync(p, 'utf8');
  for (const rx of pats) {
    if (!(new RegExp(rx).test(s))) { console.error('[guardrail] id pattern missing in', file, '→', rx); failures++; }
  }
}

// KPI test IDs — all five cards
const testIds = {
  "src/pages/card/property/Hero*.tsx":  ["kpi-units","kpi-active","kpi-occupancy","kpi-avgrent","address"],
  "src/pages/card/unit/Hero*.tsx":      ["kpi-lease-status","kpi-rent","kpi-bedbath","kpi-sqft"],
  "src/pages/card/lease/Hero*.tsx":     ["kpi-lease-status","kpi-rent","kpi-term","kpi-balance"],
  "src/pages/card/tenant/Hero*.tsx":    ["kpi-active-leases","kpi-current-balance","kpi-on-time-rate","kpi-open-workorders"],
  "src/pages/card/owner/Hero*.tsx":     ["kpi-portfolio-units","kpi-active-leases","kpi-occupancy","kpi-avg-rent"],
};
// globbing helper:
import glob from "glob";
for (const [globPath, needles] of Object.entries(testIds)) {
  const files = glob.sync(globPath, { cwd: ROOT });
  files.forEach(rel => {
    const s = fs.readFileSync(path.join(ROOT, rel), 'utf8');
    needles.forEach(n => { if (!s.includes(`data-testid=\"${n}\"`)) { console.error('[guardrail] testid missing in', rel, '→', n); failures++; } });
  });
}


Run it:

npm run guardrail


This is aligned with your “No drift” & hardening docs: selector hooks are part of the contract and must be enforced.

Where Every Component Gets Its Data / Styles (finite map)

Data flow (all cards):
RPC endpoint → resolver (RPC-first, Zod-validated) → page → hero/tabs.
Fallback (any RPC error) → /api/entities/* (raw) inside the same resolver.

Endpoints used (by card):

Property: /api/rpc/get_property_card?id=:id (KPIs & normalized property.city/state/zip). Fallback: entities for properties/:id, units?property_id=eq.:id, leases?property_id=eq.:id.

Unit: /api/rpc/get_unit_card?id=:id (property via PK or DoorLoop fallback; current lease/tenant).

Lease: /api/rpc/get_lease_card?id=:id (lease normalized; property via PK or DoorLoop).

Tenant: /api/rpc/get_tenant_card?id=:id (leases + related properties).

Owner: /api/rpc/get_owner_card?id=:id (portfolio KPIs).

Portfolio tables:

Properties use normalized listing endpoint per CSP v2 (or a mapped fallback when pointed at /entities). KPI and address fields must not be computed on the frontend.

Styles & theme:

ECC uses Altus UI Theme Foundation v1 (tokens + theme.css) with brand black/gold; card sections sit on light-grey .ecc-object surfaces. The Hardening kit + Runbook enforces these visual contracts.

Final Proof (what you run to sign off)

Bring up dev & smoke:

npm run dev
curl -s "http://localhost:8787/api/rpc/get_property_card?id=42" | jq '{kpis:.kpis, city:.property.city, state:.property.state, zip:.property.zip}'


(ports per CSP v2)

Open pages (Vite):

http://localhost:5173/card/property/42

http://localhost:5173/card/unit/<id>

http://localhost:5173/card/lease/<id>

http://localhost:5173/card/tenant/<id>

http://localhost:5173/card/owner/<id>
Verify the hero blocks have the required data-testids and show non-zero KPIs where data exists (as defined in “What Done Looks Like”).

Run guardrail:

npm run guardrail


It must PASS (imports, no null returns, correct route pattern + ID coercion, all required test IDs present). Guardrails are a non-negotiable policy in the hardening docs.

Acceptance Checklist (we enforce these gates)

 API: RPC DTOs return data for a known property; KPIs populated.

 UI: All five /card/*/:id routes render; IDs are coerced via Number(params.id); no SPA routing drift.

 Test IDs: Present on all 5 heroes (list above). Hard gate via script.

 Theme: ECC theme intact (Altus tokens; .ecc-object surfaces).

 Runbook parity: Verification checklist green; ports 5173/8787 respected.

Bottom line

You now have a complete, finite audit and a strict patch that brings the four lagging cards (Unit/Lease/Tenant/Owner) up to the same contract-safe pattern as Property — with enforced test IDs and guardrails.

This is entirely within CSP v2 and the Altus hardening posture. No operational changes.

Run the commands above and paste any guardrail failures; I’ll return a surgical diff for that exact file only.