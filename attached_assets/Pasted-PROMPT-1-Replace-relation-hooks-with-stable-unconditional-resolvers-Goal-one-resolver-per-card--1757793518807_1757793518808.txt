PROMPT 1 — Replace relation hooks with stable, unconditional resolvers

Goal: one resolver per card, fixed hook order, enabled: gates only (never conditional calls), no loops that create a variable number of hooks.

Do exactly this:

Create/replace src/lib/ecc-card-resolvers.ts with this file:

// src/lib/ecc-card-resolvers.ts
import { useQuery } from '@tanstack/react-query';
import { apiGet } from '../lib/ecc-api';

// ---------- Types (minimal / safe) ----------
export type Id = string | number;

export interface Property { id: Id; doorloop_id?: Id; street_1?: string; city?: string; state?: string; zip?: string; type?: string; class?: string; status?: string; }
export interface Unit { id: Id; doorloop_id?: Id; doorloop_property_id?: Id; unit_number?: string; beds?: number; baths?: number; sqft?: number; rent_cents?: number | null; status?: string; }
export interface Lease { doorloop_id: Id; property_id?: Id; unit_id?: Id; primary_tenant_id?: Id | null; start_date?: string; end_date?: string; rent_cents?: number | null; status?: string; }
export interface Tenant { id: Id; doorloop_id?: Id; display_name?: string; primary_email?: string | null; primary_phone?: string | null; }
export interface Owner { id: Id; doorloop_id?: Id; display_name?: string; }

type Q<T> = { data: T; isLoading: boolean; error: unknown };

// ---------- Property Card ----------
export function usePropertyCardData(id: Id) {
  // 1) Base property
  const propertyQ = useQuery<Property>({
    queryKey: ['property', id],
    queryFn: () => apiGet(`/entities/properties/${id}`),
    staleTime: 60_000,
  });

  // 2) Units for this property (by DoorLoop property id)
  const unitsQ = useQuery<Unit[]>({
    queryKey: ['unitsByPropertyDoorloop', propertyQ.data?.doorloop_id ?? null],
    queryFn: () =>
      apiGet(`/entities/units?doorloop_property_id=eq.${propertyQ.data!.doorloop_id}`),
    enabled: !!propertyQ.data?.doorloop_id,
    staleTime: 60_000,
  });

  // 3) Leases for this property (by property id)
  const leasesQ = useQuery<Lease[]>({
    queryKey: ['leasesByProperty', propertyQ.data?.id ?? null],
    queryFn: () => apiGet(`/entities/leases?property_id=eq.${propertyQ.data!.id}`),
    enabled: !!propertyQ.data?.id,
    staleTime: 60_000,
  });

  // 4) Owner (optional) — set to null if not modeled yet
  const ownerQ: Q<Owner | null> = { data: null as Owner | null, isLoading: false, error: null };

  return {
    property: propertyQ.data,
    units: unitsQ.data ?? [],
    leases: leasesQ.data ?? [],
    owner: ownerQ.data,
    // meta
    isLoading:
      propertyQ.isLoading || unitsQ.isLoading || leasesQ.isLoading || ownerQ.isLoading,
    error: propertyQ.error ?? unitsQ.error ?? leasesQ.error ?? ownerQ.error,
  };
}

// ---------- Unit Card ----------
export function useUnitCardData(id: Id) {
  const unitQ = useQuery<Unit>({
    queryKey: ['unit', id],
    queryFn: () => apiGet(`/entities/units/${id}`),
    staleTime: 60_000,
  });

  const propertyQ = useQuery<Property>({
    queryKey: ['propertyByDoorloop', unitQ.data?.doorloop_property_id ?? null],
    queryFn: () =>
      apiGet(`/entities/properties?doorloop_id=eq.${unitQ.data!.doorloop_property_id}`),
    enabled: !!unitQ.data?.doorloop_property_id,
    select: (rows: Property[]) => rows?.[0] ?? undefined,
    staleTime: 60_000,
  });

  const activeLeaseQ = useQuery<Lease[]>({
    queryKey: ['activeLeaseByUnit', unitQ.data?.id ?? null],
    queryFn: () =>
      apiGet(`/entities/leases?unit_id=eq.${unitQ.data!.id}&status=eq.active&limit=1`),
    enabled: !!unitQ.data?.id,
    staleTime: 30_000,
  });

  const primaryTenantId = activeLeaseQ.data?.[0]?.primary_tenant_id ?? null;
  const tenantQ = useQuery<Tenant>({
    queryKey: ['tenantById', primaryTenantId],
    queryFn: () => apiGet(`/entities/tenants/${primaryTenantId}`),
    enabled: !!primaryTenantId,
    staleTime: 60_000,
  });

  return {
    unit: unitQ.data,
    property: propertyQ.data,
    activeLease: activeLeaseQ.data?.[0] ?? null,
    primaryTenant: tenantQ.data ?? null,
    isLoading:
      unitQ.isLoading || propertyQ.isLoading || activeLeaseQ.isLoading || tenantQ.isLoading,
    error: unitQ.error ?? propertyQ.error ?? activeLeaseQ.error ?? tenantQ.error,
  };
}

// ---------- Lease Card ----------
export function useLeaseCardData(id: Id) {
  const leaseQ = useQuery<Lease>({
    queryKey: ['lease', id],
    queryFn: () => apiGet(`/entities/leases/${id}`),
    staleTime: 30_000,
  });

  const propertyQ = useQuery<Property>({
    queryKey: ['lease.property', leaseQ.data?.property_id ?? null],
    queryFn: () => apiGet(`/entities/properties/${leaseQ.data!.property_id}`),
    enabled: !!leaseQ.data?.property_id,
    staleTime: 60_000,
  });

  const unitQ = useQuery<Unit>({
    queryKey: ['lease.unit', leaseQ.data?.unit_id ?? null],
    queryFn: () => apiGet(`/entities/units/${leaseQ.data!.unit_id}`),
    enabled: !!leaseQ.data?.unit_id,
    staleTime: 60_000,
  });

  const tenantId = leaseQ.data?.primary_tenant_id ?? null;
  const tenantQ = useQuery<Tenant>({
    queryKey: ['lease.tenant', tenantId],
    queryFn: () => apiGet(`/entities/tenants/${tenantId}`),
    enabled: !!tenantId,
    staleTime: 60_000,
  });

  return {
    lease: leaseQ.data,
    property: propertyQ.data,
    unit: unitQ.data,
    tenant: tenantQ.data,
    isLoading:
      leaseQ.isLoading || propertyQ.isLoading || unitQ.isLoading || tenantQ.isLoading,
    error: leaseQ.error ?? propertyQ.error ?? unitQ.error ?? tenantQ.error,
  };
}

// ---------- Tenant Card ----------
export function useTenantCardData(id: Id) {
  const tenantQ = useQuery<Tenant>({
    queryKey: ['tenant', id],
    queryFn: () => apiGet(`/entities/tenants/${id}`),
    staleTime: 60_000,
  });

  const leasesQ = useQuery<Lease[]>({
    queryKey: ['leasesByTenant', tenantQ.data?.id ?? null],
    queryFn: () => apiGet(`/entities/leases?primary_tenant_id=eq.${tenantQ.data!.id}`),
    enabled: !!tenantQ.data?.id,
    staleTime: 30_000,
  });

  return {
    tenant: tenantQ.data,
    leases: leasesQ.data ?? [],
    isLoading: tenantQ.isLoading || leasesQ.isLoading,
    error: tenantQ.error ?? leasesQ.error,
  };
}

// ---------- Owner Card ----------
export function useOwnerCardData(id: Id) {
  const ownerQ = useQuery<Owner>({
    queryKey: ['owner', id],
    queryFn: () => apiGet(`/entities/owners/${id}`),
    staleTime: 60_000,
  });

  // If properties are not directly linkable yet, return empty list safely.
  const propertiesQ = useQuery<Property[]>({
    queryKey: ['owner.properties', ownerQ.data?.id ?? null],
    queryFn: () => apiGet(`/entities/properties?owner_id=eq.${ownerQ.data!.id}`),
    enabled: !!ownerQ.data?.id,
    staleTime: 60_000,
  });

  return {
    owner: ownerQ.data,
    properties: propertiesQ.data ?? [],
    isLoading: ownerQ.isLoading || propertiesQ.isLoading,
    error: ownerQ.error ?? propertiesQ.error,
  };
}


Delete or stop using any of these (if present):
usePropertyRelations, useUnitRelations, useOwnerRelations, or any hook that calls a variable number of useQuery calls or is wrapped in conditionals. Keep the file around if other code imports it, but export nothing from it.

PROMPT 2 — Refactor each card page to use the new resolvers (no conditional hooks)

Goal: every card page calls exactly one resolver hook at the top level; no hook calls inside conditionals, loops, or tab switches.

2A) Property page

File: src/pages/card/property/index.tsx
Make these exact edits:

At the top, replace any prior relation-hook imports with:

import { usePropertyCardData } from '../../../lib/ecc-card-resolvers';


In the component, replace all previous data wiring with:

const { id } = params; // keep your existing param getter
const {
  property,
  units,
  leases,
  owner,
  isLoading,
  error
} = usePropertyCardData(id);


Every place you previously read from rel.data or multiple hooks, read from property, units, leases, owner. Do not create new hooks in render. Use guards only in values, e.g.:

<FieldRows
  fields={[
    { label: 'Type', value: property?.type ?? '—' },
    { label: 'Class', value: property?.class ?? '—' },
    { label: 'Status', value: property?.status ?? '—' },
    { label: 'DoorLoop ID', value: property?.doorloop_id ?? '—' },
    { label: 'Owner', value: owner?.display_name ?? '—' },
  ]}
/>


Keep the map only on the Property card. When passing lat/lng, guard with Number.isFinite(...). If you don’t have coords, pass only the address.

2B) Unit page

File: src/pages/card/unit/index.tsx

import { useUnitCardData } from '../../../lib/ecc-card-resolvers';

const { id } = params;
const { unit, property, activeLease, primaryTenant, isLoading, error } = useUnitCardData(id);


Use those values only—no other data hooks. No map on this page.

2C) Lease page

File: src/pages/card/lease/index.tsx

import { useLeaseCardData } from '../../../lib/ecc-card-resolvers';

const { id } = params;
const { lease, property, unit, tenant, isLoading, error } = useLeaseCardData(id);


No map here.

2D) Tenant page

File: src/pages/card/tenant/index.tsx

import { useTenantCardData } from '../../../lib/ecc-card-resolvers';

const { id } = params;
const { tenant, leases, isLoading, error } = useTenantCardData(id);


No map here.

2E) Owner page

File: src/pages/card/owner/index.tsx

import { useOwnerCardData } from '../../../lib/ecc-card-resolvers';

const { id } = params;
const { owner, properties, isLoading, error } = useOwnerCardData(id);


No map here.

Important: Do not wrap any of these hooks in if (...) { ... }. The resolver returns safe, empty defaults—render placeholders (—) when values are missing.

PROMPT 3 — Purge conditional hooks and dynamic-hook loops

Goal: guarantee stable hook count/order forever.

Search & fix across src/:

Forbid calling useQuery, useEffect, or any hook inside:

if / else, switch, try/catch, or early return branches

.map() loops whose length can vary between renders

Replace patterns:

✅ Good:

const hasProperty = !!property?.id;
const leasesQ = useQuery(..., { enabled: hasProperty });


❌ Bad:

if (property?.id) {
  const leasesQ = useQuery(...); // <-- MOVE out of conditional
}


❌ Bad:

ids.map(id => useQuery(...)); // dynamic number of hooks


Use one query that returns an array instead.

Cards may early-return JSX, but must not early-return before calling the single resolver hook. Keep the resolver at the very top of the component, unconditional.

PROMPT 4 — Endpoint hygiene confirmation

Make sure the resolvers above use only the allowed endpoints and filters:

GET /entities/properties/:id

GET /entities/units?doorloop_property_id=eq.{doorloop_id}

GET /entities/leases?property_id=eq.{id}

GET /entities/leases?unit_id=eq.{id}&status=eq.active&limit=1

GET /entities/tenants/{id}

GET /entities/leases?primary_tenant_id=eq.{id}
(If owner_id is not modeled yet, keep owner: null.)

No /api/portfolio/* calls inside card pages. If you see any, replace with the resolvers.

PROMPT 5 — Quick sanity tests (deterministic)

After changes compile:

Visit these with real ids you know exist:

/card/property/57

/card/unit/45

/card/lease/1

/card/tenant/1

/card/owner/1

Expected:

No “Rendered more hooks…” error anywhere.

Property card shows header, tabs, and the map only on the right rail.

Other cards render content (no map), and show — placeholders where data isn’t wired yet.

Why this fixes your screenshots

The error modals you showed list usePropertyRelations/useOwnerRelations in the stack. Those are almost certainly calling useQuery conditionally based on ID availability or tab state. The new resolvers are unconditional and stable; all variability is handled with enabled: flags and safe defaults, eliminating hook-count changes between renders.

Pages that previously “sometimes landed” were relying on multiple ad-hoc hooks. Moving to one resolver per page makes render paths deterministic and keeps your MEGA LOCKDOWN protections effective.

If you want, after this lands I’ll hand you the next copy-paste patch to fill in the Property → Relationships grid (units + active lease + tenant link) and wire the Financials stub to the three BFF read endpoints you already listed.