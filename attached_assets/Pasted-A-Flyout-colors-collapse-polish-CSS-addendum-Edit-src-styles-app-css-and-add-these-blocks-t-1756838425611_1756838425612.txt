A) Flyout + colors + collapse polish (CSS addendum)

Edit src/styles/app.css and add these blocks (they’re safe to paste anywhere near the other sidebar rules):

/* --- ECC: collapsed flyout fixes (avoid clipping) --- */
.ecc-sidebar.is-collapsed { overflow: visible; }
.ecc-sidebar.is-collapsed .ecc-sidebar__inner { overflow: visible; }
.ecc-flyout { z-index: 1000; } /* ensure on top of content */

/* --- ECC: collapsed item hover + icon contrast --- */
.ecc-sidebar.is-collapsed .ecc-link {
  background: transparent;
  border-color: transparent;
}
.ecc-sidebar.is-collapsed .ecc-link:hover {
  background: rgba(214,179,106,.08);
  border-color: rgba(214,179,106,.22);
}

/* Slightly brighter icon color in the rail so it reads as Altus gold-y */
.ecc-sidebar.is-collapsed .ecc-link .ecc-link__icon { color: var(--ink-2); }
.ecc-sidebar.is-collapsed .ecc-link:hover .ecc-link__icon { color: var(--accent); }


Why: the flyout was being clipped by overflow:auto on the sidebar scroller. Making it overflow:visible in collapsed mode lets the flyout render outside the rail, and boosting z-index prevents it hiding under the main pane. The hover/contrast tweaks make the collapsed rail feel more intentional.

B) Collapse state (ensure main margin updates immediately)

Your Sidebar already toggles the body class; just make sure we set the class on mount too (for first paint). Here’s a tiny, safe upgrade. Replace the useEffect that touches the body class in src/components/Sidebar.tsx with this version:

  useEffect(() => {
    try {
      // apply immediately on mount and whenever it changes
      document.body.classList.toggle("ecc--sidebar-collapsed", collapsed);
      localStorage.setItem(STORAGE_KEY, collapsed ? "1" : "0");
    } catch {}
  }, [collapsed]);


(If your file already looks like this, you’re good.)

C) Treat API 404 as “no rows” (remove scary red error)

Full replacement for src/lib/useApi.ts that keeps your existing behavior but turns a 404 into an empty result instead of an error banner:

// src/lib/useApi.ts
import { useEffect, useMemo, useState } from "react";

export type ApiResult<T> = {
  data: T;
  loading: boolean;
  error: Error | null;
};

function buildQuery(params?: Record<string, any>): string {
  if (!params) return "";
  const usp = new URLSearchParams();
  Object.entries(params).forEach(([k, v]) => {
    if (v === undefined || v === null) return;
    usp.set(k, String(v));
  });
  const qs = usp.toString();
  return qs ? `?${qs}` : "";
}

async function tryFetchJSON(u: string): Promise<{ ok: boolean; status: number; json?: any }> {
  const r = await fetch(u, { headers: { Accept: "application/json" } });
  if (!r.ok) return { ok: false, status: r.status };
  try { return { ok: true, status: r.status, json: await r.json() }; }
  catch { return { ok: true, status: r.status, json: [] }; }
}

function normalizeArray<T = any>(j: any): T[] {
  if (Array.isArray(j)) return j as T[];
  if (Array.isArray(j?.items)) return j.items as T[];
  if (Array.isArray(j?.data)) return j.data as T[];
  if (Array.isArray(j?.results)) return j.results as T[];
  if (j && typeof j === "object") return [j as T];
  return [];
}

/**
 * useCollection — fetches a collection with graceful fallbacks.
 * - tries multiple URL shapes
 * - 404 -> treated as "no results" (empty data, no error)
 */
export function useCollection<T = any>(
  collection: string,
  params?: Record<string, any>
): ApiResult<T[]> {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  const qs = useMemo(() => buildQuery(params), [params]);

  useEffect(() => {
    let off = false;
    const load = async () => {
      setLoading(true);
      setError(null);
      try {
        const urls = [
          `/api/${collection}${qs}`,
          `/api/${collection}/list${qs}`,
          `/api/v1/${collection}${qs}`,
          `/${collection}${qs}`,
        ];

        let lastNon404: { status: number; err: Error } | null = null;
        let rows: T[] | null = null;

        for (const u of urls) {
          const res = await tryFetchJSON(u);
          if (!res.ok) {
            if (res.status === 404) continue; // try next shape
            lastNon404 = { status: res.status, err: new Error(`${res.status} for ${u}`) };
            continue;
          }
          rows = normalizeArray<T>(res.json);
          break;
        }

        if (rows === null) {
          // no endpoint responded OK; treat all-404 as empty, else surface last error
          if (!lastNon404) rows = []; // all were 404
          else throw lastNon404.err;
        }

        if (!off) setData(rows);
      } catch (e: any) {
        if (!off) setError(e instanceof Error ? e : new Error(String(e)));
      } finally {
        if (!off) setLoading(false);
      }
    };
    load();
    return () => { off = true; };
  }, [collection, qs]);

  return { data, loading, error };
}


Now your Portfolio pages render with “Loaded 0 …” instead of a big 404 error bar until the backend endpoints are online.

Quick verify
npm run dev
# then in the app:
# 1) Click the collapse button (bottom-left). Hover a parent item (e.g., Portfolio) → flyout should appear.
# 2) Colors in the collapsed rail should show better contrast & hover gold.
# 3) Visit /portfolio/properties → no red 404; shows empty table + caption.