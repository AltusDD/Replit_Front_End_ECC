ECC Fail-Fast Purge Pack v7 — copy/paste these exactly
0) Execution mode
MODE: Contract Compliance Executor (CSP v2)
Rules:
- Only apply the changes below.
- Backup touched files to *.bak before writing.
- Print unified diffs.
- Run guardrail + proofs at the end.

1) Add a tiny contract enforcer (no more silent fallbacks)

New: src/lib/contract.ts

// Throws on undefined / null; stops UI from masking with 0 / "—"
export function requireField<T>(value: T | null | undefined, path: string): T {
  if (value === null || value === undefined) {
    throw new Error(`[CONTRACT] Missing required field: ${path}`);
  }
  return value;
}
export function requireArray<T>(value: T[] | null | undefined, path: string): T[] {
  if (!Array.isArray(value)) throw new Error(`[CONTRACT] Expected array at: ${path}`);
  return value;
}

2) Make resolvers fail-fast (no silent catch, no masked fallback)

Edit: src/lib/ecc-resolvers.ts (replace card hooks with this pattern)

import { useQuery } from "@tanstack/react-query";
import { PropertyCardDTO, UnitCardDTO, LeaseCardDTO, TenantCardDTO, OwnerCardDTO } from "./dto";

async function j<T>(url: string, signal?: AbortSignal): Promise<T> {
  const r = await fetch(url, { signal });
  if (!r.ok) throw new Error(`[HTTP ${r.status}] ${url}`);
  return r.json();
}

// Fail-fast: parse (not safeParse). Any invalid DTO throws and surfaces to UI.
export function usePropertyCard(id: number) {
  return useQuery({
    queryKey: ["card","property", id],
    queryFn: async ({ signal }) => PropertyCardDTO.parse(await j(`/api/rpc/get_property_card?id=${id}`, signal)),
    staleTime: 0, gcTime: 0, retry: false,
  });
}
export function useUnitCard(id: number) {
  return useQuery({
    queryKey: ["card","unit", id],
    queryFn: async ({ signal }) => UnitCardDTO.parse(await j(`/api/rpc/get_unit_card?id=${id}`, signal)),
    staleTime: 0, gcTime: 0, retry: false,
  });
}
export function useLeaseCard(id: number) {
  return useQuery({
    queryKey: ["card","lease", id],
    queryFn: async ({ signal }) => LeaseCardDTO.parse(await j(`/api/rpc/get_lease_card?id=${id}`, signal)),
    staleTime: 0, gcTime: 0, retry: false,
  });
}
export function useTenantCard(id: number) {
  return useQuery({
    queryKey: ["card","tenant", id],
    queryFn: async ({ signal }) => TenantCardDTO.parse(await j(`/api/rpc/get_tenant_card?id=${id}`, signal)),
    staleTime: 0, gcTime: 0, retry: false,
  });
}
export function useOwnerCard(id: number) {
  return useQuery({
    queryKey: ["card","owner", id],
    queryFn: async ({ signal }) => OwnerCardDTO.parse(await j(`/api/rpc/get_owner_card?id=${id}`, signal)),
    staleTime: 0, gcTime: 0, retry: false,
  });
}


This removes the “try/safeParse + silent fallback to /entities” behavior. If DTOs don’t match, you’ll see an error—by design.

3) Show real errors in the UI (not zeros/dashes)

Edit: src/components/ErrorBoundary.tsx (make it informative)

import { Component, ReactNode } from "react";

export class ErrorBoundary extends Component<{ children: ReactNode }, { hasError: boolean; msg?: string }> {
  constructor(props:any){ super(props); this.state={ hasError:false, msg: undefined }; }
  static getDerivedStateFromError(err: any){ return { hasError:true, msg:String(err?.message||err) }; }
  componentDidCatch(err:any){ console.error("[CardError]", err); }
  render(){
    return this.state.hasError
      ? <div data-testid="contract-error" className="p-3 border border-rose-700 bg-rose-900/30 rounded">
          <div className="font-semibold">Contract violation</div>
          <div className="text-sm opacity-80">{this.state.msg}</div>
        </div>
      : this.props.children;
  }
}

4) Remove masking from all HeroBlocks (example shown; repeat for each card)
4.1 Property

Edit: src/pages/card/property/HeroBlock.tsx

import { useMemo } from "react";
import { KPIRow } from "@/components/cardkit/KPIRow";
import { KPI } from "@/components/cardkit/KPI";
import { KPIBlockSkeleton } from "@/components/Skeletons";
import { requireArray, requireField } from "@/lib/contract";

export default function HeroBlock({ data, isLoading }: { data:any; isLoading?:boolean }) {
  if (isLoading) return <KPIBlockSkeleton />;

  // Required shape
  const property = requireField(data?.property, "property");
  const units    = requireArray(data?.units, "units");
  const leases   = requireArray(data?.leases, "leases");
  const kpis     = data?.kpis; // optional, but if present it must be coherent

  const calc = useMemo(() => {
    if (kpis) {
      // kpis.occupancyPct is a number 0..100
      const u = requireField(kpis.units, "kpis.units");
      const a = requireField(kpis.activeLeases, "kpis.activeLeases");
      const o = requireField(kpis.occupancyPct, "kpis.occupancyPct");
      const avg = requireField(kpis.avgRentCents, "kpis.avgRentCents");
      return { unitsCount: u, active: a, occPct: o, avgRentCents: avg };
    }
    const unitsCount = units.length;
    const active = leases.filter((l:any) => String(l?.status||"").toLowerCase()==="active").length;
    const occPct = unitsCount ? Math.round((active/unitsCount)*1000)/10 : (()=>{ throw new Error("[CONTRACT] Cannot compute occupancy: zero units"); })();
    // Require at least one active lease to compute avg rent
    const rents = leases.filter((l:any)=>String(l?.status||"").toLowerCase()==="active")
                        .map((l:any)=>Number(l?.rent_cents ?? l?.rent));
    if (!rents.length) throw new Error("[CONTRACT] No active leases to compute avg rent");
    const avgRentCents = Math.round(rents.reduce((a,b)=>a+b,0)/rents.length);
    return { unitsCount, active, occPct, avgRentCents };
  }, [kpis, units, leases]);

  const city  = requireField(property.city ?? property.address_city, "property.city");
  const state = requireField(property.state ?? property.address_state, "property.state");
  const zip   = requireField(property.zip   ?? property.address_zip,  "property.zip");

  return (
    <>
      <KPIRow>
        <KPI label="Units"          value={calc.unitsCount}                 testid="kpi-units" />
        <KPI label="Active Leases"  value={calc.active}                     testid="kpi-active" />
        <KPI label="Occupancy"      value={`${calc.occPct.toFixed(1)}%`}    testid="kpi-occupancy" />
        <KPI label="Avg Rent"       value={`$${Math.round(calc.avgRentCents/100)}`} testid="kpi-avgrent" />
      </KPIRow>
      <div className="mt-2 text-sm opacity-80" data-testid="address">
        {city}, {state} {zip}
      </div>
    </>
  );
}

4.2 Unit / Lease / Tenant / Owner

Remove all ?? 0, || 0, || "—" or ?? "—" from their HeroBlocks and Overview components.

Use requireField / requireArray the same way for each KPI input.

If a KPI can’t be computed (e.g., missing lease), throw so the ErrorBoundary shows the contract violation instead of a fake 0.

This stops the “zeros & dashes” screenshots. If data is missing/wrong, you’ll see the error.

5) DTO parity (align names exactly)

Edit: src/lib/dto.ts (ensure these precise keys)

import { z } from "zod";

const Address = z.object({
  city: z.string().nullable().optional(),
  state: z.string().nullable().optional(),
  zip: z.string().nullable().optional(),
  street1: z.string().nullable().optional(), // server maps street_1/address_street1 -> street1
});

const Lease = z.object({
  id: z.number(),
  property_id: z.number().nullable().optional(),
  unit_id: z.number().nullable().optional(),
  tenant_id: z.number().nullable().optional(),
  status: z.string().nullable().optional(),
  rent_cents: z.number().nullable().optional(),
  rent: z.union([z.number(), z.string()]).nullable().optional(),
});

const Unit = z.object({
  id: z.number(),
  property_id: z.number().nullable().optional(),
  doorloop_property_id: z.union([z.number(), z.string()]).nullable().optional(),
}).passthrough();

const Property = z.object({ id: z.number() }).merge(Address).passthrough();
const Tenant = z.object({ id: z.number() }).passthrough();
const Owner  = z.object({ id: z.number() }).passthrough();

export const PropertyCardDTO = z.object({
  property: Property.nullable(),
  units: z.array(Unit),
  leases: z.array(Lease),
  owner: Owner.nullable().optional(),
  kpis: z.object({
    units: z.number(),
    activeLeases: z.number(),
    occupancyPct: z.number(),      // 0..100
    avgRentCents: z.number().nullable(),
  }).optional(),
});

export const UnitCardDTO    = z.object({ unit: Unit.nullable(), property: Property.nullable(), lease: Lease.nullable(), tenant: Tenant.nullable() });
export const LeaseCardDTO   = z.object({ lease: Lease.nullable(), unit: Unit.nullable(), property: Property.nullable(), tenant: Tenant.nullable() });
export const TenantCardDTO  = z.object({ tenant: Tenant.nullable(), leases: z.array(Lease), properties: z.array(Property), activeLease: Lease.nullable().optional() });
export const OwnerCardDTO   = z.object({ owner: Owner.nullable(), properties: z.array(Property), kpis: z.object({ units: z.number(), activeLeases: z.number(), occupancyPct: z.number(), avgRentCents: z.number().nullable() }).optional() });

export type PropertyCardDTO = z.infer<typeof PropertyCardDTO>;
export type UnitCardDTO     = z.infer<typeof UnitCardDTO>;
export type LeaseCardDTO    = z.infer<typeof LeaseCardDTO>;
export type TenantCardDTO   = z.infer<typeof TenantCardDTO>;
export type OwnerCardDTO    = z.infer<typeof OwnerCardDTO>;


This matches the server fields we already standardized (avgRentCents, occupancyPct, street1) and the added activeLease for tenant.

6) Expand guardrail to nuke all legacy + masking patterns

Edit: scripts/guardrail-check.mjs (append)

import fs from "fs"; import path from "path"; import glob from "glob";
let failures = 0;
const ROOT = process.cwd();

function scan(patterns, where, msg) {
  for (const rel of glob.sync(where, { cwd: ROOT })) {
    const s = fs.readFileSync(path.join(ROOT, rel), "utf8");
    for (const rx of patterns) {
      if (rx.test(s)) { console.error(`[guardrail] ${msg}:`, rel, "→", rx); failures++; }
    }
  }
}

// 1) Ban all legacy code paths (alias + relative + directories)
scan([/@\/lib\/ecc-card-queries/, /from ['"]\.{1,2}\/.*ecc-card-queries['"]/], "src/**/*.{ts,tsx,js,jsx}", "legacy resolver import");
scan([/from ['"]@\/lib\/cards\/?/, /from ['"]\.{1,2}\/.*\/lib\/cards\//], "src/**/*.{ts,tsx,js,jsx}", "legacy lib/cards import");
scan([/features\/.*\/components\/HeroBlock/], "src/**/*.{ts,tsx,js,jsx}", "legacy HeroBlock import");
if (fs.existsSync(path.join(ROOT, "src/lib/cards"))) { console.error("[guardrail] forbidden directory present: src/lib/cards"); failures++; }

// 2) Ban masking patterns inside card pages & portfolio columns
const MASK_NUM = [/\?\?\s*0\b/, /\|\|\s*0\b/];
const MASK_TXT = [/\?\?\s*['"]—['"]/, /\|\|\s*['"]—['"]/];
scan([...MASK_NUM, ...MASK_TXT], "src/pages/card/**/*.{ts,tsx}", "masking fallback (??0 ||0 ||'—')");
scan([...MASK_NUM, ...MASK_TXT], "src/pages/portfolio/**/*.{ts,tsx}", "masking fallback (??0 ||0 ||'—')");

// 3) Ban safeNum helper if present
scan([/function\s+safeNum\s*\(|\bsafeNum\s*\(/], "src/**/*.{ts,tsx,js,jsx}", "safeNum masking helper");

// 4) Ensure card pages use wouter useRoute + Number coercion
const idPatterns = {
  "src/pages/card/property/index.tsx":[/useRoute\(\"\/card\/property\/:id\"\)/,/Number\(params\?\.id\)/],
  "src/pages/card/unit/index.tsx":    [/useRoute\(\"\/card\/unit\/:id\"\)/,    /Number\(params\?\.id\)/],
  "src/pages/card/lease/index.tsx":   [/useRoute\(\"\/card\/lease\/:id\"\)/,   /Number\(params\?\.id\)/],
  "src/pages/card/tenant/index.tsx":  [/useRoute\(\"\/card\/tenant\/:id\"\)/,  /Number\(params\?\.id\)/],
  "src/pages/card/owner/index.tsx":   [/useRoute\(\"\/card\/owner\/:id\"\)/,   /Number\(params\?\.id\)/],
};
for (const [file, pats] of Object.entries(idPatterns)) {
  const p = path.join(ROOT, file);
  if (!fs.existsSync(p)) { console.error("[guardrail] missing", file); failures++; continue; }
  const s = fs.readFileSync(p,"utf8");
  for (const rx of pats) if (!rx.test(s)) { console.error("[guardrail] route/id pattern missing in", file, "→", rx); failures++; }
}

// 5) Required test IDs on heroes
const required = {
  "src/pages/card/property/HeroBlock.tsx": ["kpi-units","kpi-active","kpi-occupancy","kpi-avgrent","address"],
  "src/pages/card/unit/HeroBlock.tsx":     ["kpi-lease-status","kpi-rent","kpi-bedbath","kpi-sqft"],
  "src/pages/card/lease/HeroBlock.tsx":    ["kpi-lease-status","kpi-rent","kpi-term","kpi-balance"],
  "src/pages/card/tenant/HeroBlock.tsx":   ["kpi-active-leases","kpi-current-balance","kpi-on-time-rate","kpi-open-workorders"],
  "src/pages/card/owner/HeroBlock.tsx":    ["kpi-portfolio-units","kpi-active-leases","kpi-occupancy","kpi-avg-rent"],
};
for (const [file, needles] of Object.entries(required)) {
  const p = path.join(ROOT, file);
  if (!fs.existsSync(p)) { console.error("[guardrail] missing", file); failures++; continue; }
  const s = fs.readFileSync(p,"utf8");
  for (const n of needles) if (!s.includes(`data-testid="${n}"`)) { console.error("[guardrail] testid missing in", file, "→", n); failures++; }
}

if (failures) { console.error(`[guardrail] FAILED with ${failures} issue(s)`); process.exit(1); }
console.log("[guardrail] PASS");

7) Server DTO nits (already added earlier, keep in place)

server/routes/rpc.ts Tenant adds activeLease in response.

server/routes/rpc.ts Owner KPIs include avgRentCents.

server/lib/mapping.ts still maps address_* → street1/city/state/zip.

(If you already patched these, no action needed.)

8) Clean rebuild (wipe caches)
rm -rf node_modules/.vite .vite dist .cache .parcel-cache 2>/dev/null || true
npm ci
npm run guardrail
npm run dev

9) Runtime proofs (fail-fast behavior)

API (use real IDs):

curl -s "http://localhost:8787/api/rpc/get_property_card?id=42" | jq '{ok:(.kpis|has("units")), city:.property.city}'
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=1" | jq '{hasActiveLease:(.activeLease!=null)}'
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=1"  | jq '{avg:(.kpis.avgRentCents)}'


UI:

Open http://localhost:5173/card/property/42 etc.

If data is correct → KPIs show real values.

If anything missing → page shows Contract violation box with the exact missing path (e.g., [CONTRACT] Missing required field: kpis.avgRentCents). That’s intended.

What this does (and keeps doing)

No more masking: Any missing/invalid field throws, trips the ErrorBoundary, and shows a precise contract error. No 0, no —.

Resolvers fail-fast: Invalid DTOs do not silently fall back; they surface errors.

Guardrail expands: Blocks legacy imports (alias+relative), duplicate resolver systems, masking patterns (?? 0, || 0, || '—', safeNum()), and enforces routing/testIDs.

DTOs aligned: Server <-> client fields are exact (street1, avgRentCents, occupancyPct, activeLease).

CSP v2 posture preserved: Server-only secrets, RPC-first, flat DTOs, guardrails.

If guardrail flags any remaining masking or legacy instance, paste the file path(s) it prints and I’ll give you a micro-diff for those files on the spot.