CARDS RENDERING PROOF — Lock frontend to hardened RPC + automated UI smoke

You will do these steps exactly, stopping on error and printing the raw output.

0) Preconditions (don’t skip)

vite.config.ts has server: { allowedHosts: true, hmr: { overlay: false } }.

scripts/dev-runner.mjs (dual-process runner) exists and works.

1) Frontend schemas = API truth (single source)

Create/replace src/shared/card-contracts.ts with the exact Zod shapes that match the hardened RPC outputs:

// src/shared/card-contracts.ts
import { z } from "zod";

export const Address = z.object({
  line1: z.string().default(""),
  city: z.string().default(""),
  state: z.string().default(""),
  zip: z.string().default(""),
});

export const PropertyCard = z.object({
  property: z.object({
    id: z.number(),
    name: z.string().optional().default(""),
    type: z.string().default("UNKNOWN"),
    address: Address,
  }),
  kpis: z.object({
    units: z.number().default(0),
    activeLeases: z.number().default(0),
    occupancyPct: z.number().default(0),
    avgRentCents: z.number().nullable().default(null),
  }),
});

export const UnitCard = z.object({
  unit: z.object({
    id: z.number(),
    unit_label: z.string().optional().default(""),
    status: z.string().optional().default("UNKNOWN"),
  }),
  property: z.object({ id: z.number() }).nullable().default(null),
  lease: z.object({ id: z.number(), status: z.string().default("UNKNOWN") }).nullable().default(null),
});

export const LeaseCard = z.object({
  lease: z.object({
    id: z.number(),
    status: z.string().default("UNKNOWN"),
    rent_cents: z.number().nullable().default(null),
  }),
  unit: z.object({ id: z.number() }).nullable().default(null),
  tenant: z.object({ id: z.number(), display_name: z.string().default("") }).nullable().default(null),
  property: z.object({ id: z.number() }).nullable().default(null),
});

export const OwnerCard = z.object({
  owner: z.object({
    id: z.number(),
    display_name: z.string().default(""),
  }),
  properties: z.array(z.object({ id: z.number(), name: z.string().default("") })).default([]),
});

export const TenantCard = z.object({
  tenant: z.object({
    id: z.number(),
    display_name: z.string().default(""),
  }),
  leases: z.array(z.object({ id: z.number(), status: z.string().default("UNKNOWN") })).default([]),
  activeLease: z.object({ id: z.number(), status: z.string().default("UNKNOWN") }).nullable().default(null),
});


Wire these into the resolvers/pages (replace any old DTO imports/parsing):

// example in a property card hook/page
import { PropertyCard } from "@/shared/card-contracts";

const json = await fetch(`/api/rpc/get_property_card?id=${id}`).then(r => r.json());
const data = PropertyCard.parse(json); // ← canonical parse


STOP & PRINT: a single diff hunk showing one page switched from old DTO to the new PropertyCard.parse(...).

2) Start both servers reliably (background)

Add/verify package.json scripts:

{
  "scripts": {
    "dev": "node scripts/dev-runner.mjs",
    "smoke:rpc": "node scripts/smoke.mjs",
    "smoke:ui": "node scripts/ui-smoke.mjs"
  }
}


Run:

# in project root
(timeout 120 node scripts/dev-runner.mjs >/tmp/dev.log 2>&1 &); sleep 10
echo "=== VITE PING ==="; curl -s http://localhost:5173/__vite_ping
echo "=== API HEALTH ==="; curl -s http://localhost:8787/api/health


STOP & PRINT: the two lines. Expect pong and {"status":"ok"}.

3) RPC invariants (already green, re-run for proof)
npm run smoke:rpc


STOP & PRINT: must end with ALL RPC invariants OK.

4) Headless UI smoke (prove cards render)

Install Playwright if needed:

npx playwright install --with-deps chromium


Create scripts/ui-smoke.mjs:

// scripts/ui-smoke.mjs
import { chromium } from "playwright";
import { execSync } from "node:child_process";

function j(cmd){ return JSON.parse(execSync(cmd, {stdio:["ignore","pipe","pipe"]}).toString()); }
const ids = j(`curl -s http://localhost:8787/api/rpc/diag/ids`);
const { property:PID, unit:UID, lease:LID, owner:OID, tenant:TID } = ids;

const routes = [
  [ "portfolio", `http://localhost:5173/portfolio/properties`, '[data-testid="datatable"]' ],
  [ "property",  `http://localhost:5173/card/property/${PID}`, '[data-testid="kpi-units"]' ],
  [ "unit",      `http://localhost:5173/card/unit/${UID}`,     '[data-testid="card-hero"],[data-testid="kpi-lease-status"]' ],
  [ "lease",     `http://localhost:5173/card/lease/${LID}`,    '[data-testid="kpi-lease-status"]' ],
  [ "owner",     `http://localhost:5173/card/owner/${OID}`,    '[data-testid="kpi-avg-rent"],[data-testid="kpi-occupancy"]' ],
  [ "tenant",    `http://localhost:5173/card/tenant/${TID}`,   '[data-testid="kpi-active-leases"]' ],
];

(async () => {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  for (const [name, url, selector] of routes) {
    console.log(`\n== ${name.toUpperCase()} == ${url}`);
    await page.goto(url, { waitUntil: "networkidle" });
    // Assert no Vite error overlay
    const overlay = await page.$('vite-error-overlay, #vite-error-overlay, .vite-error-overlay');
    if (overlay) throw new Error(`${name}: Vite overlay present`);
    // Assert important element exists
    await page.waitForSelector(selector, { timeout: 10000 });
    // Screenshot for audit
    await page.screenshot({ path: `/tmp/ui-${name}.png`, fullPage: true });
    console.log(`OK (${selector})`);
  }
  await browser.close();
  console.log("\nALL UI routes OK");
})();


Run:

npm run smoke:ui
ls -l /tmp/ui-*.png


STOP & PRINT: the ALL UI routes OK line plus the screenshot list.

If unit, lease, owner, or tenant fail here: that page is still parsing with an old DTO or is missing a data-testid the probe expects. Fix by (a) importing the correct Zod from src/shared/card-contracts.ts, and (b) ensuring the hero KPIs include the testids listed in the selectors.

5) Make it stick

Re-enable React.StrictMode in src/main.tsx (we’re cancel-safe now).

Keep server.allowedHosts: true and hmr.overlay: false to avoid red-screens from benign dev errors.

Optional: add "precommit": "npm run smoke:rpc && npm run smoke:ui" with Husky.

What this gives you

Frontend can’t drift: it parses exactly the shapes your hardened RPCs emit.

A repeatable, headless proof that all 6 routes render (and it fails loudly if not).

Screenshots for audit so we can stop arguing about what’s “working”.

If any part of the UI smoke fails, it’s pinpointed to a specific page and selector. Switch that page’s parse to the new shared Zod, keep the KPI testids consistent, and re-run.