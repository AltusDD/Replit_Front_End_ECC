ECC DEV UNBRICK RUNBOOK — “NO MORE WHITE SCREEN”

Objective: Make the app boot reliably in Replit dev (Vite on 5173, API on 8787). Prevent Express from serving the SPA in dev. Prove modules execute. Then restore the normal app with hard error surfacing.

0) Repo hygiene (so Vite scans only one entry)

If test.html exists at repo root, move it to dev/test.html.

Delete any *.bak, .attic/, or stray HTML in root besides index.html.

1) Fix .replit so Replit points to Vite (never cross-wired ports)

Replace the entire file with this:

run = "npm run dev"

[env]
NODE_ENV = "dev"
CI = ""

[[ports]]
port = 5173
primary = true


We intentionally expose only 5173; the API is internal.

2) Package scripts: run guardrail, then concurrently launch Vite + API

Open package.json and set scripts to exactly:

{
  "scripts": {
    "guardrail": "node scripts/guardrail-check.mjs",
    "dev": "npm run guardrail && concurrently -k -n WEB,API -c blue,magenta \"npm:dev:web\" \"npm:dev:api\"",
    "dev:web": "vite --host 0.0.0.0 --port 5173",
    "dev:api": "tsx server/index.ts"
  }
}


Note: use npm:dev:web / npm:dev:api (not pnpm:).

3) Guardrail must not hijack dev startup

Open scripts/guardrail-check.mjs and remove or disable any code that spawns servers (often gated by CI==='true'). The guardrail should only lint/verify, never start servers. If present, change:

if (process.env.CI === 'true') {
  // spawn vite/tsx ...  <-- REMOVE THIS BLOCK
}


to:

// No server spawning here in dev; guardrail = checks only

4) Vite config: Replit-friendly host + API proxy; no custom SPA shim

Open vite.config.ts (or .js) and set:

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "node:path";

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "src"),
    },
  },
  server: {
    host: true,          // 0.0.0.0
    port: 5173,
    strictPort: true,
    proxy: { "/api": "http://localhost:8787" },
    hmr: { clientPort: 443 }
  }
});


Remove any custom configureServer SPA middleware and any optimizeDeps.disabled settings (Vite 5 deprecated).

5) Express should never serve the SPA in dev

Open server/index.ts and ensure:

const isDev = process.env.NODE_ENV !== "production";

// mount /api/* routes here…

if (!isDev) {
  import path from "node:path";
  app.use(express.static(path.resolve("dist")));
  app.get("*", (_req, res) => res.sendFile(path.resolve("dist/index.html")));
}
// In dev, Vite serves index.html; no catch-all here.

6) Index is explicitly Vite-driven + visible pre-mount error catcher

Open index.html and set to:

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Empire Command Center</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script type="module" src="/@vite/client"></script>
    <style>
      html,body,#root { height:100%; }
      body { margin:0; background:#0b0b0d; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- Boot sentinel -->
    <script>
      const r = document.getElementById('root');
      if (r) r.innerHTML = '<div style="padding:16px;color:#9aa0a6;font:14px system-ui">Booting ECC…</div>';
    </script>

    <!-- Pre-mount global error sink -->
    <script>
      (function () {
        function show(msg) {
          const r = document.getElementById('root');
          if (!r) return;
          r.innerHTML =
            '<div style="padding:24px;margin:24px;border-radius:16px;border:1px solid #7f1d1d;background:#450a0a;color:#fecaca;font:14px system-ui">' +
            '<div style="font-weight:600;font-size:16px;margin-bottom:8px">ECC boot error</div>' +
            '<pre style="white-space:pre-wrap;margin:0">'+ String(msg) +'</pre>' +
            '</div>';
        }
        window.addEventListener('error', e => show(e?.error?.stack || e.message));
        window.addEventListener('unhandledrejection', e => show(e?.reason?.stack || e.reason));
      })();
    </script>

    <!-- First run with probe, then switch to main.tsx after it passes -->
    <script type="module" src="/src/_probe.tsx"></script>
  </body>
</html>


Create src/_probe.tsx:

import React from "react";
import ReactDOM from "react-dom/client";

console.log("[ECC] probe loaded");
ReactDOM.createRoot(document.getElementById("root")!).render(
  <div style={{padding:24,color:"#d1fae5",fontFamily:"system-ui"}}>
    <div style={{fontWeight:700,fontSize:18,marginBottom:8}}>ECC Probe OK</div>
    <div>Vite is serving modules and React mounted.</div>
  </div>
);


Run. If you see “ECC Probe OK”, module execution is fixed.

Then edit index.html and change the last script to the real app:

<script type="module" src="/src/main.tsx"></script>

7) Error boundary must not break imports (dual export)

src/components/EccErrorBoundary.tsx:

import React from "react";
type S = { hasError: boolean; msg?: string };

class EccErrorBoundary extends React.Component<React.PropsWithChildren, S> {
  state: S = { hasError: false };
  static getDerivedStateFromError(err: any) { return { hasError: true, msg: String(err?.message || err) }; }
  componentDidCatch(e: any, info: any) { console.error("[EccErrorBoundary]", e, info); }
  render() {
    return this.state.hasError
      ? <div style={{padding:24,color:"#fecaca"}}>Render error: {this.state.msg}</div>
      : this.props.children;
  }
}
export default EccErrorBoundary;
export { EccErrorBoundary };


src/main.tsx minimal mount:

import React from "react";
import ReactDOM from "react-dom/client";
import EccErrorBoundary from "./components/EccErrorBoundary";
import App from "./App";
// Temporarily comment non-critical CSS if needed to isolate CSS-chain issues
// import "@/styles/theme.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <EccErrorBoundary>
      <App />
    </EccErrorBoundary>
  </React.StrictMode>
);

8) Real route on “/” (avoid dead redirects)

In src/App.tsx:

import { Switch, Route, useLocation } from "wouter";
import { useEffect } from "react";

function HomeRedirect() {
  const [, setLoc] = useLocation();
  useEffect(() => { setLoc("/portfolio/properties"); }, [setLoc]);
  return null;
}

export default function App() {
  return (
    <Switch>
      <Route path="/" component={HomeRedirect} />
      {/* …existing routes… */}
    </Switch>
  );
}

9) Automated verification (must pass)

Run these shell checks (Replit Console):

# 5173 must serve JS, not HTML
curl -I http://localhost:5173/@vite/client | grep "200"
curl -I http://localhost:5173/src/_probe.tsx | grep -i "content-type"

# 8787 must NOT serve TSX
curl -I http://localhost:8787/src/_probe.tsx | grep "404"

# API health
curl -s http://localhost:8787/api/health


Expected:

5173 returns 200 and content-type: application/javascript.

8787 returns 404 for TSX.

Health returns your JSON.

If any of the above differs, print the exact headers for the failing line and fix the step that governs that port.

10) CSS chain (only if React mounts but crashes)

If React mounts with probe but crashes after switching to main.tsx, the usual culprit is a CSS import error. Temporarily comment out all but one CSS import in main.tsx, confirm boot, then add them back one by one (the faulty file will surface in the red error card).

Acceptance Criteria (what I expect to see):

The preview shows “ECC Probe OK”, then (after switching to main.tsx) the normal ECC UI.

Network tab includes /@vite/client and /src/main.tsx as JS (not HTML).

index.html is fetched from 5173; Express does not handle the SPA in dev.

API responds on 8787 via /api/*, proxied by Vite from the browser.

This removes the root causes your audit flagged (port cross-wiring, guardrail hijack, dev SPA catch-all, extra HTML entries) and forces visible, actionable errors if anything still fails inside React.