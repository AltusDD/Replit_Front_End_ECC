One-Pass Activation Runbook (no mock data)
0) Secrets (double-check)

In Replit → Secrets:

GOOGLE_MAPS_API_KEY = your server key (Geocoding enabled)

GEOCODER_PROVIDER = google

If you also use client maps, keep VITE_GOOGLE_MAPS_API_KEY for the react map. Server geocoding uses GOOGLE_MAPS_API_KEY.

1) Database sanity (idempotent)

Run these once in your DB (Supabase/PSQL). They won’t change anything if already present.

-- properties table: add lat/lng if missing
ALTER TABLE properties
  ADD COLUMN IF NOT EXISTS lat double precision,
  ADD COLUMN IF NOT EXISTS lng double precision;

-- geocode cache table (for dedupe & speed)
CREATE TABLE IF NOT EXISTS geocode_cache (
  address_hash text PRIMARY KEY,
  provider text NOT NULL,
  lat double precision NOT NULL,
  lng double precision NOT NULL,
  raw jsonb,
  created_at timestamptz DEFAULT now()
);

CREATE INDEX IF NOT EXISTS geocode_cache_created_at_idx ON geocode_cache (created_at DESC);

2) Dry-run a small batch (quick proof)

From your Replit shell:

# See what will be geocoded (no writes)
npx tsx scripts/backfill-geocodes.ts --limit 10 --dry-run


You should see output like:

10 addresses scanned

cache hits: 0 (first run)

to geocode: 10

per-address previews

If that looks right, run for real.

3) Full backfill (rate-limited, resumable)
# 1 req/sec built in; safe to resume if interrupted
npx tsx scripts/backfill-geocodes.ts --resume


What you’ll see:

geocoded: N / 184

cache hits: …

sleeping 1000ms (rate limit)

Any “ZERO_RESULTS” are logged and skipped; those properties simply won’t get pins until address is fixed.

You can throttle scope while testing: --limit 30 or target a market: --city "Gary" (if your script supports filters; otherwise limit).

4) Verify API + UI

Hit the API in your browser: /api/portfolio/properties?limit=5
Confirm each item has lat and lng.

Reload /dashboard

Top-left of the map should show clusters/pins.

The KPI tiles and Action Feed already reflect live data; the map will now match.

5) Common blockers (fast fixes)

Pins still don’t render?

Confirm the map component uses only properties.filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lng)).

Key restrictions: in Google Cloud Console, ensure:

APIs enabled: Geocoding API, Maps JavaScript API

Key restriction: HTTP referrers include your *.replit.dev URL (for the client key). Server key can be IP-restricted or unrestricted as you prefer.

429 / OVER_QUERY_LIMIT

The script already sleeps 1s between calls. If you still see 429, you’re out of daily quota; re-run tomorrow with --resume.

ZERO_RESULTS or bad addresses

Those rows are left blank by design. You can patch addresses and re-run --resume — the cache is address-hash keyed, so only changed addresses will re-geocode.

6) Nice-to-have ops

Re-geocode a single property after fixing its address

npx tsx scripts/backfill-geocodes.ts --property-id 1234 --force


Warm cache without writing to properties

npx tsx scripts/backfill-geocodes.ts --limit 100 --cache-only


Check coverage

SELECT COUNT(*) AS total,
       COUNT(*) FILTER (WHERE lat IS NOT NULL AND lng IS NOT NULL) AS with_coords
FROM properties;

7) What “good” looks like

Console is quiet (no AbortError/eruda spam).

/api/portfolio/properties returns lat/lng on most rows.

Map shows clustered pins in your markets; clicking a pin opens your styled info window and deep links to the property/units/work orders.

KPI tiles: Occupancy & Rent-Ready reflect the same unit/lease math you validated (e.g., 89/177 = 50.3%).

Action Feed: Renewals, delinquencies, hotlist items are populated and the Action buttons navigate correctly.