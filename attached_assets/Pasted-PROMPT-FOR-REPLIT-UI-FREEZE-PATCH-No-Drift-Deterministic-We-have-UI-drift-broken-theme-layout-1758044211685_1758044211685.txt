PROMPT FOR REPLIT — UI FREEZE PATCH (No-Drift, Deterministic)

We have UI drift (broken theme/layout, table & card visuals). Apply these steps exactly and stop after each step to verify.

STEP 0 — Sanity (don’t skip)

Confirm dev task runs Vite on 5173 and API on 8787.

Confirm src exists and app root is #root.

STEP 1 — One CSS entry point (kill duplicate/ordering drift)

Edit src/main.tsx to import only one stylesheet:

// TOP of file — replace all individual CSS imports with ONE line
import "@/styles/index.css";


Create/replace src/styles/index.css with this exact content (these imports and guards restore the original look and keep it stable across HMR):

/* === canonical order: tokens -> theme -> ecc base -> enhancers -> app -> genesis === */
@import "./tokens.css";
@import "./theme.css";
@import "./ecc.css";
@import "./card-enhancer.css";
@import "./no-overlays.css";
@import "./app.css";
@import "./genesis.css";

/* Hard guards to survive HMR */
:root{
  --ecc-bg:#0b0b0d;
  --ecc-surface:#121216;
  --ecc-fg:#e9e9f0;
  --ecc-muted:#9aa0a6;
  --ecc-accent:#d4af37;
  font-synthesis-weight:none;
}
html,body,#root{height:100%;background:var(--ecc-bg);color:var(--ecc-fg)}
#ecc-app{min-height:100%;background:var(--ecc-bg);color:var(--ecc-fg)}

.sidebar{background:var(--ecc-surface)}
.card,.panel,.kpi{background:var(--ecc-surface);border-radius:12px}

/* Layout paddings so top chrome doesn’t collapse after HMR */
.content-wrap{padding:16px 20px 60px}

/* FieldGroup layout (safe defaults even if component CSS didn’t load yet) */
.field-group{display:grid;grid-template-columns:160px 1fr;gap:8px 24px;margin:12px 0}
.field-group .label{color:var(--ecc-muted)}
.field-group .value{color:var(--ecc-fg)}


Edit src/App.tsx (or the file that renders routes) and wrap your routes once:

return (
  <div id="ecc-app">
    {/* existing layout + routes */}
  </div>
);


VERIFY & STOP: Reload /portfolio/properties. The sidebar + KPIs should look “ECC-normal” (dark theme, gold accents, proper spacing). If not, show me a fresh screenshot and the browser console.

STEP 2 — React Query + cancel-safe fetch (stop rows:0 flashes & AbortError spam)

Create src/lib/queryClient.ts:

import { QueryClient, setLogger } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60_000,
      gcTime: 300_000,
      retry: 1,
      refetchOnMount: false,
      refetchOnReconnect: false,
      refetchOnWindowFocus: false,
      keepPreviousData: true,
      placeholderData: (prev) => prev,
      throwOnError: false,
      networkMode: "online",
    },
  },
});

setLogger({
  log: (...a) => console.log(...a),
  warn: (...a) => console.warn(...a),
  error: (err) => {
    const msg = String((err as any)?.message ?? err ?? "");
    if (/AbortError|aborted/i.test(msg)) return; // silence benign cancels
    console.error(err);
  },
});


Create/ensure src/lib/http.ts (cancel-safe fetch used by all hooks/resolvers):

export function isAbortError(e: unknown) {
  return (
    (e instanceof DOMException && e.name === "AbortError") ||
    /AbortError|aborted/i.test(String((e as any)?.message ?? e))
  );
}

export async function fetchJSON<T>(input: RequestInfo, init?: RequestInit & { signal?: AbortSignal }) {
  try {
    const res = await fetch(input, init);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return (await res.json()) as T;
  } catch (err) {
    if (isAbortError(err) || init?.signal?.aborted) {
      // never reject; prevents error boundaries & log spam during HMR
      return new Promise<T>(() => {});
    }
    throw err;
  }
}


Wire the client in src/main.tsx:

import { QueryClientProvider } from "@tanstack/react-query";
import { queryClient } from "@/lib/queryClient";
const Mode: React.ComponentType<any> = import.meta.env.DEV ? React.Fragment : React.StrictMode;

ReactDOM.createRoot(document.getElementById("root")!).render(
  <Mode>
    <EccErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <App />
      </QueryClientProvider>
    </EccErrorBoundary>
  </Mode>
);


Update portfolio hooks to use the helper (repeat for units/leases/tenants/owners):

import { useQuery } from "@tanstack/react-query";
import { fetchJSON } from "@/lib/http";
import { mapProperty } from "@/pages/portfolio/columns";

export function useAllProperties() {
  return useQuery({
    queryKey: ["portfolio","properties"],
    queryFn: ({ signal }) => fetchJSON<any[]>("/api/portfolio/properties", { signal }),
    select: (rows) => (rows ?? []).map(mapProperty),
  });
}


DataTable consumers: make loading depend on flags, not rows.length === 0:

const { data: rows = [], isLoading, isFetching } = useAllProperties();
<DataTable rows={rows} loading={isLoading || (isFetching && rows.length === 0)} ... />


VERIFY & STOP: Watch console. You should NOT see AbortError spam; tables should no longer flash rows: 0 before filling in.

STEP 3 — KPI test id + hero guards (remove runtime contract throws)

Patch src/components/cardkit/KPI.tsx to forward test id props:

type KPIProps = {
  label: string;
  value: React.ReactNode;
} & React.HTMLAttributes<HTMLDivElement>;

export function KPI({ label, value, ...rest }: KPIProps) {
  const anyRest = rest as any;
  const dataTestId = anyRest["data-testid"] ?? anyRest.testid;
  if ("testid" in anyRest) delete anyRest.testid;
  return (
    <div className="kpi" data-testid={dataTestId} {...anyRest}>
      <div className="kpi-label">{label}</div>
      <div className="kpi-value">{value ?? "—"}</div>
    </div>
  );
}
export default KPI;


Standardize hero blocks (src/pages/card/**/HeroBlock.tsx):

Use data-testid="kpi-…" everywhere (no testid prop).

Replace any requireField/requireArray that can run before data is present with safe read + fallback (value ?? "—").

For occupancy with zero units, show 0% (don’t throw).

VERIFY & STOP: Open /card/property/<id>, /card/unit/<id>, etc. KPIs render; no error boundaries; test IDs present.

STEP 4 — Lock the look (optional but recommended)

In vite.config.ts set:

server: { hmr: { overlay: true }, allowedHosts: true }


(Overlay is fine now; we silenced benign cancels.)

Add a tiny “UI guardrail” script so drift is visible at startup:
Create scripts/guardrail-ui.mjs:

import fs from "node:fs";
const m = fs.readFileSync("src/styles/index.css","utf8");
const order = [
  "tokens.css","theme.css","ecc.css","card-enhancer.css","no-overlays.css","app.css","genesis.css"
];
const idx = order.map(n => m.indexOf(n));
const bad = idx.some((i,j,arr)=> i<0 || (j>0 && i<arr[j-1]));
if (bad) {
  console.log("[guardrail-ui] ❌ CSS import order drifted:", idx.map((v,i)=>`${order[i]}=${v}`).join(" "));
  process.exit(1);
}
console.log("[guardrail-ui] ✅ CSS imports locked:", order.join(" → "));


Then prepend it in your dev script before starting servers. If order drifts, you’ll know immediately.

FINAL VERIFICATION (paste exact outputs)

Console: no AbortError spam; Vite connects; no HMR style flicker.

/portfolio/properties: sidebar + KPIs look correct (dark theme, gold accents, proper spacing). Table no longer flashes rows: 0.

Cards: the 5 card pages render KPIs + overview fields with “—” where data is missing; no red overlays.

Network tab: portfolio list calls return once, refetch does not blank the table.