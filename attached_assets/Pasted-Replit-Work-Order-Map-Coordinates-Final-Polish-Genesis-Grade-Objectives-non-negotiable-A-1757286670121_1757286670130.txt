Replit Work Order ‚Äî Map Coordinates + Final Polish (Genesis Grade)
üëë Objectives (non-negotiable)

Add lat/lng to properties in the DB and return them from /api/portfolio/properties.

Backfill coordinates for all existing properties using a safe, rate-limited geocoder with caching.

Render live coordinates on the dashboard map (clustered pins + status colors).

Kill all NaN/empty UI issues (city table, KPIs).

Do not change the left nav, shell layout, routes, or theme tokens.

1) Database migration (Supabase / Postgres)

Create/alter columns and a cache to avoid re-geocoding the same address.

-- 1) Ensure properties table has coordinate columns
ALTER TABLE public.properties
  ADD COLUMN IF NOT EXISTS lat double precision,
  ADD COLUMN IF NOT EXISTS lng double precision;

-- 2) Create a geocode cache table
CREATE TABLE IF NOT EXISTS public.geocode_cache (
  id BIGSERIAL PRIMARY KEY,
  address TEXT UNIQUE NOT NULL,
  lat double precision NOT NULL,
  lng double precision NOT NULL,
  provider TEXT NOT NULL,
  confidence NUMERIC,
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS geocode_cache_address_idx ON public.geocode_cache (address);


Address fields: use street, city, state, zip if you have them; if not, fall back to the best available string (e.g., name).

2) Server: geocoding utility (rate-limited + cache)

File: server/lib/geocode.ts

import fetch from "node-fetch";

const PROVIDER = process.env.GEOCODER_PROVIDER || "google"; // "google" | "osm"
const GOOGLE_KEY = process.env.GOOGLE_MAPS_API_KEY || process.env.VITE_GOOGLE_MAPS_API_KEY;

type GeocodeHit = { lat: number; lng: number; provider: string; confidence?: number };

export async function geocode(address: string): Promise<GeocodeHit | null> {
  if (!address || !address.trim()) return null;

  // 1) cache hit?
  const cached = await getCache(address);
  if (cached) return cached;

  // 2) provider
  let hit: GeocodeHit | null = null;
  if (PROVIDER === "google" && GOOGLE_KEY) {
    hit = await geocodeGoogle(address);
  } else {
    hit = await geocodeOSM(address); // OpenStreetMap Nominatim
  }

  if (hit) await putCache(address, hit);
  return hit;
}

async function geocodeGoogle(address: string): Promise<GeocodeHit | null> {
  const url = new URL("https://maps.googleapis.com/maps/api/geocode/json");
  url.searchParams.set("address", address);
  url.searchParams.set("key", GOOGLE_KEY!);

  const res = await fetch(url.toString());
  if (!res.ok) return null;
  const json = await res.json();
  const result = json?.results?.[0];
  if (!result) return null;

  const loc = result.geometry?.location;
  if (!loc) return null;
  return { lat: loc.lat, lng: loc.lng, provider: "google", confidence: result?.geometry?.location_type ? 1 : undefined };
}

async function geocodeOSM(address: string): Promise<GeocodeHit | null> {
  const url = new URL("https://nominatim.openstreetmap.org/search");
  url.searchParams.set("q", address);
  url.searchParams.set("format", "jsonv2");
  url.searchParams.set("addressdetails", "0");
  const res = await fetch(url.toString(), {
    headers: { "User-Agent": "Altus-Empire/1.0 (contact: admin@altus.example)" },
  });
  if (!res.ok) return null;
  const arr = await res.json();
  const first = arr?.[0];
  if (!first) return null;
  return { lat: parseFloat(first.lat), lng: parseFloat(first.lon), provider: "osm", confidence: first.importance };
}

// --- simple pg helpers (replace with your db util) ---
import { pool } from "../db"; // your pg Pool

async function getCache(address: string): Promise<GeocodeHit | null> {
  const { rows } = await pool.query(
    `SELECT lat, lng, provider, confidence FROM geocode_cache WHERE address = $1`,
    [address]
  );
  if (!rows[0]) return null;
  const r = rows[0];
  return { lat: r.lat, lng: r.lng, provider: r.provider, confidence: r.confidence ?? undefined };
}

async function putCache(address: string, hit: GeocodeHit): Promise<void> {
  await pool.query(
    `INSERT INTO geocode_cache (address, lat, lng, provider, confidence)
     VALUES ($1, $2, $3, $4, $5)
     ON CONFLICT (address) DO UPDATE SET lat = EXCLUDED.lat, lng = EXCLUDED.lng, provider = EXCLUDED.provider, confidence = EXCLUDED.confidence, updated_at = now()`,
    [address, hit.lat, hit.lng, hit.provider, hit.confidence ?? null]
  );
}


Rate limiting: OSM requires it. Add a simple throttle queue if you backfill many records in one run (see script below).

3) Server: backfill script

File: scripts/backfill-geocodes.ts
Run: node -r esbuild-register scripts/backfill-geocodes.ts

import PQueue from "p-queue";
import { pool } from "../server/db";
import { geocode } from "../server/lib/geocode";

function makeAddress(row: any): string {
  // Prefer explicit fields; fallback to name string
  const parts = [row.street || "", row.city || "", row.state || "", row.zip || ""].filter(Boolean);
  if (parts.length === 0) return row.name || "";
  return parts.join(", ");
}

(async () => {
  const { rows } = await pool.query(`
    SELECT id, name, street, city, state, zip, lat, lng
    FROM public.properties
    WHERE lat IS NULL OR lng IS NULL
  `);

  const q = new PQueue({ interval: 1000, intervalCap: 1 }); // polite: 1 req/sec

  let success = 0, fail = 0;
  for (const row of rows) {
    await q.add(async () => {
      const address = makeAddress(row);
      const hit = await geocode(address);
      if (!hit) { fail++; console.warn("No geocode", row.id, address); return; }
      await pool.query(`UPDATE public.properties SET lat = $1, lng = $2 WHERE id = $3`, [hit.lat, hit.lng, row.id]);
      success++;
      console.log(`‚úì ${row.id} ${address} -> ${hit.lat},${hit.lng} (${hit.provider})`);
    });
  }

  await q.onIdle();
  console.log(`Backfill complete: ${success} updated, ${fail} failed.`);
  process.exit(0);
})();

4) Server: include lat/lng in the properties API

File: server/routes/portfolio.ts (or wherever /api/portfolio/properties is defined)

// ...existing imports
app.get("/api/portfolio/properties", async (req, res) => {
  try {
    const { rows } = await pool.query(`
      SELECT id, name, class, type, city, state, zip, active, units, occ_pct,
             lat, lng, street
      FROM public.properties
      WHERE active IS TRUE
      ORDER BY name ASC
    `);
    res.json(rows);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "properties_query_failed" });
  }
});


No on-the-fly geocoding in this endpoint. Keep responses snappy; use the backfill job to populate lat/lng.

5) Frontend: map uses live coordinates only

File: src/features/dashboard/components/PortfolioGoogleMap.tsx

Make sure we only render pins with valid numbers and don‚Äôt warn on missing coords.

// inside map component:
const points = properties
  .filter(p => typeof p.lat === "number" && typeof p.lng === "number" && !Number.isNaN(p.lat) && !Number.isNaN(p.lng))
  .map(p => ({
    id: p.id,
    name: p.name,
    lat: p.lat as number,
    lng: p.lng as number,
    status: computeStatus(p), // your existing status logic
  }));

// ...render markers from `points`
// If points.length === 0, show the styled empty map state that says:
// ‚ÄúNo coordinates available. Add lat/lng to properties to enable the portfolio map.‚Äù

6) Frontend: kill NaN in city table + polish

File: src/features/dashboard/components/OccupancyByCity.tsx

const total = row.totalUnits || 0;
const occ = row.occupiedUnits || 0;
const pct = total > 0 ? (occ / total) * 100 : 0;          // guard
const pctStr = fmtPct(pct, 1);                             // "0.0%"
const width = Math.max(0, Math.min(100, pct));            // 0..100

// render:
// <td>{pctStr}</td>
// <div className="bar"><div className="fill" style={{ width: `${width}%` }} /></div>


File: src/utils/format.ts (ensure these exports exist & are used)

export const fmtMoney = (n?: number | null) =>
  typeof n === "number" && Number.isFinite(n)
    ? n.toLocaleString("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 0 })
    : "$0";

export const fmtPct = (n?: number | null, digits = 1) =>
  typeof n === "number" && Number.isFinite(n)
    ? `${n.toFixed(digits)}%`
    : "0.0%";

export const fmtDate = (iso?: string | null) =>
  iso ? new Date(iso).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }) : "‚Äî";

/** Back-compat aliases (do NOT remove; other files import them) */
export const money = fmtMoney;
export const percent = fmtPct;
export const date = fmtDate;
export const formatMoney = fmtMoney;

7) KPI guards (just to be safe)

File: src/features/dashboard/components/KpiTicker.tsx

const totalUnits = data.kpis.totalUnits ?? 0;
const occupiedUnits = data.kpis.occupiedUnits ?? 0;
const occupancyPct = totalUnits > 0 ? (occupiedUnits / totalUnits) * 100 : 0;

const vacant = Math.max(0, totalUnits - occupiedUnits);
const rentReady = Math.max(0, Math.min(vacant, data.kpis.rentReady ?? 0));

const billed = data.kpis.billedMTD ?? 0;
const receipts = data.kpis.receiptsMTD ?? 0;
const collPct = billed > 0 ? (receipts / billed) * 100 : 0;


Display with fmtPct / fmtMoney and never show NaN.

8) Env & commands

.env

# Map + geocoder
VITE_GOOGLE_MAPS_API_KEY=******      # used by frontend, optional for server
GOOGLE_MAPS_API_KEY=******           # server geocoder (same key ok)
GEOCODER_PROVIDER=google             # "google" or "osm"


Install

npm i p-queue node-fetch


Backfill

node -r esbuild-register scripts/backfill-geocodes.ts


Run

npm run dev

9) Acceptance tests

 /api/portfolio/properties returns lat and lng for (nearly) all active properties.

 Dashboard map renders clusters and colored pins; no ‚Äúmissing coordinates‚Äù warnings.

 City table shows 0.0% when total units = 0; no NaN warnings in console.

 KPI tiles never show NaN; clicking each tile routes to the correct filtered view.

 No changes to left nav, shell layout, or theme tokens.

10) Nice-to-haves (if time allows)

Scheduled backfill (daily): run the backfill script for any newly added properties (lat/lng null).

Geocode confidence column in UI debug overlay (?debug=1), count of missing coordinates.

Map pin tooltips include owner and delinquency badge.

What this accomplishes

Puts the map on real data, at speed.

Eliminates the remaining NaN/empty-state rough edges.

Keeps everything Genesis Grade and DB-first with no mock anywhere.