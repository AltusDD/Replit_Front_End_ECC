0) One new secret (server)

Add this to your environment (Replit ‚ÄúSecrets‚Äù or .env):

ADMIN_SYNC_TOKEN=<make-a-strong-random-string>


The UI sends this token in an X-Admin-Token header. Only users who know this token (you) can run the sync.

üß† 1) Server: DoorLoop + Supabase helpers
server/lib/supabaseAdmin.ts
// server/lib/supabaseAdmin.ts
import { createClient } from '@supabase/supabase-js';

const SUPABASE_URL = process.env.SUPABASE_URL!;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
  throw new Error('Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY');
}

export const sbAdmin = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
  auth: { persistSession: false },
});

server/lib/doorloop.ts
// server/lib/doorloop.ts
const DL_TOKEN = process.env.DOORLOOP_API_KEY!;
const DL_BASE  = process.env.DOORLOOP_BASE_URL || 'https://api.doorloop.com/v1';

if (!DL_TOKEN) {
  throw new Error('Missing DOORLOOP_API_KEY');
}

export async function dlFetch(path: string, query: Record<string,string|number|undefined> = {}) {
  const url = new URL(DL_BASE + path);
  Object.entries(query).forEach(([k,v]) => {
    if (v !== undefined && v !== null) url.searchParams.set(k, String(v));
  });

  const res = await fetch(url.toString(), {
    headers: { Authorization: `Bearer ${DL_TOKEN}` },
  });
  if (!res.ok) {
    const body = await res.text();
    throw new Error(`DoorLoop ${path} failed: ${res.status} ${body}`);
  }
  return res.json();
}

export async function dlPaginate<T>(
  path: string,
  params: Record<string,string|number|undefined> = {},
  pageSize = 200
): Promise<T[]> {
  const out: T[] = [];
  let page = 1;
  while (true) {
    const data = await dlFetch(path, { ...params, page, limit: pageSize });
    const batch: T[] = Array.isArray(data) ? data : (data.data || []);
    out.push(...batch);
    const hasMore = Array.isArray(data) ? batch.length === pageSize
                 : (data?.meta?.nextPage ?? (batch.length === pageSize));
    if (!hasMore) break;
    page += 1;
    await new Promise(r => setTimeout(r, 250)); // polite
  }
  return out;
}

server/lib/integrationState.ts
// server/lib/integrationState.ts
import { sbAdmin } from './supabaseAdmin';

const KEY = (k:string) => `doorloop_${k}`;

export async function getSinceCursor(name: string): Promise<string|null> {
  const { data } = await sbAdmin
    .from('integration_state')
    .select('value')
    .eq('key', KEY(name))
    .single();
  return (data?.value as any)?.last_cursor ?? null;
}

export async function setSinceCursor(name: string, cursor: string) {
  await sbAdmin.from('integration_state').upsert({
    key: KEY(name),
    value: { last_cursor: cursor },
  });
}

üîÅ 2) Server: sync modules (owners, properties, units, leases, tenants)

These are fully working examples. You can extend with work_orders, communications, files, lease_charges, lease_payments, lease_credits using the same pattern.

server/lib/sync/owners.ts
// server/lib/sync/owners.ts
import { dlPaginate } from '../doorloop';
import { sbAdmin } from '../supabaseAdmin';

type DlOwner = {
  id: number;
  companyName?: string | null;
  firstName?: string | null;
  lastName?: string | null;
  updatedAt?: string | null;
};

function displayName(o: DlOwner) {
  const c = (o.companyName || '').trim();
  if (c) return c;
  const p = [o.firstName, o.lastName].filter(Boolean).join(' ').trim();
  return p || null;
}

export async function syncOwners(updated_after?: string) {
  const rows = await dlPaginate<DlOwner>('/owners', { updated_after });
  if (!rows.length) return { fetched: 0, upserted: 0 };

  const mapped = rows.map(o => ({
    doorloop_owner_id: o.id,
    company_name: o.companyName ?? null,
    first_name: o.firstName ?? null,
    last_name: o.lastName ?? null,
    display_name: displayName(o),
  }));

  const { error, count } = await sbAdmin
    .from('owners')
    .upsert(mapped, { onConflict: 'doorloop_owner_id' })
    .select('*', { count: 'exact' });

  if (error) throw error;
  return { fetched: rows.length, upserted: count ?? mapped.length };
}

server/lib/sync/properties.ts
// server/lib/sync/properties.ts
import { dlPaginate } from '../doorloop';
import { sbAdmin } from '../supabaseAdmin';

type DlProperty = {
  id: number;
  name?: string|null;
  ownerId?: number|null;
  address1?: string|null;
  address2?: string|null;
  city?: string|null;
  state?: string|null;
  zip?: string|null;
  updatedAt?: string|null;
};

export async function syncProperties(updated_after?: string) {
  const rows = await dlPaginate<DlProperty>('/properties', { updated_after });
  if (!rows.length) return { fetched: 0, upserted: 0 };

  const mapped = rows.map(p => ({
    doorloop_property_id: p.id,
    owner_doorloop_id: p.ownerId ?? null,
    name: p.name ?? null,
    addr_line1: p.address1 ?? null,
    addr_line2: p.address2 ?? null,
    city: p.city ?? null,
    state: p.state ?? null,
    zip: p.zip ?? null,
  }));

  const { error, count } = await sbAdmin
    .from('properties')
    .upsert(mapped, { onConflict: 'doorloop_property_id' })
    .select('*', { count: 'exact' });

  if (error) throw error;
  return { fetched: rows.length, upserted: count ?? mapped.length };
}

server/lib/sync/units.ts
// server/lib/sync/units.ts
import { dlPaginate } from '../doorloop';
import { sbAdmin } from '../supabaseAdmin';

type DlUnit = {
  id: number;
  propertyId: number;
  label?: string|null;
  beds?: number|null;
  baths?: number|null;
  sqft?: number|null;
  updatedAt?: string|null;
};

export async function syncUnits(updated_after?: string) {
  const rows = await dlPaginate<DlUnit>('/units', { updated_after });
  if (!rows.length) return { fetched: 0, upserted: 0 };

  const mapped = rows.map(u => ({
    doorloop_unit_id: u.id,
    doorloop_property_id: u.propertyId,
    unit_label: u.label ?? null,
    beds: u.beds ?? null,
    baths: u.baths ?? null,
    sqft: u.sqft ?? null,
  }));

  const { error, count } = await sbAdmin
    .from('units')
    .upsert(mapped, { onConflict: 'doorloop_unit_id' })
    .select('*', { count: 'exact' });

  if (error) throw error;
  return { fetched: rows.length, upserted: count ?? mapped.length };
}

server/lib/sync/tenants.ts
// server/lib/sync/tenants.ts
import { dlPaginate } from '../doorloop';
import { sbAdmin } from '../supabaseAdmin';

type DlTenant = {
  id: number;
  firstName?: string|null;
  lastName?: string|null;
  email?: string|null;
  phone?: string|null;
  updatedAt?: string|null;
};

export async function syncTenants(updated_after?: string) {
  const rows = await dlPaginate<DlTenant>('/tenants', { updated_after });
  if (!rows.length) return { fetched: 0, upserted: 0 };

  const mapped = rows.map(t => ({
    doorloop_tenant_id: t.id,
    first_name: t.firstName ?? null,
    last_name:  t.lastName ?? null,
    email:      t.email ?? null,
    phone:      t.phone ?? null,
  }));

  const { error, count } = await sbAdmin
    .from('tenants')
    .upsert(mapped, { onConflict: 'doorloop_tenant_id' })
    .select('*', { count: 'exact' });

  if (error) throw error;
  return { fetched: rows.length, upserted: count ?? mapped.length };
}

server/lib/sync/leases.ts
// server/lib/sync/leases.ts
import { dlPaginate } from '../doorloop';
import { sbAdmin } from '../supabaseAdmin';

type DlLease = {
  id: number;
  unitId: number;
  tenantId: number;
  startDate?: string|null;
  endDate?: string|null;
  status?: string|null;
  updatedAt?: string|null;
};

export async function syncLeases(updated_after?: string) {
  const rows = await dlPaginate<DlLease>('/leases', { updated_after });
  if (!rows.length) return { fetched: 0, upserted: 0 };

  const mapped = rows.map(l => ({
    doorloop_lease_id: l.id,
    doorloop_unit_id: l.unitId,
    doorloop_tenant_id: l.tenantId,
    start_date: l.startDate ?? null,
    end_date:   l.endDate ?? null,
    status:     l.status ?? null,
  }));

  const { error, count } = await sbAdmin
    .from('leases')
    .upsert(mapped, { onConflict: 'doorloop_lease_id' })
    .select('*', { count: 'exact' });

  if (error) throw error;
  return { fetched: rows.length, upserted: count ?? mapped.length };
}

server/lib/sync/index.ts (dispatcher)
// server/lib/sync/index.ts
import { getSinceCursor, setSinceCursor } from '../integrationState';
import { syncOwners }     from './owners';
import { syncProperties } from './properties';
import { syncUnits }      from './units';
import { syncLeases }     from './leases';
import { syncTenants }    from './tenants';

type Entity = 'owners' | 'properties' | 'units' | 'leases' | 'tenants';
type Mode = 'incremental' | 'full';

export async function runSync(entities: Entity[], mode: Mode, sinceDays = 30) {
  const now = new Date();
  const fallbackSince = new Date(now.getTime() - sinceDays*24*60*60*1000).toISOString();

  const results: Record<string, any> = {};
  for (const e of entities) {
    const cursor = (mode === 'incremental') ? (await getSinceCursor(e)) || fallbackSince : undefined;
    switch (e) {
      case 'owners':      results.owners      = await syncOwners(cursor); break;
      case 'properties':  results.properties  = await syncProperties(cursor); break;
      case 'units':       results.units       = await syncUnits(cursor); break;
      case 'leases':      results.leases      = await syncLeases(cursor); break;
      case 'tenants':     results.tenants     = await syncTenants(cursor); break;
    }
    // bump cursor after each entity
    if (mode === 'incremental') await setSinceCursor(e, new Date().toISOString());
  }
  return { mode, results };
}

üåê 3) Server route: /api/admin/sync/run
server/routes/adminSync.ts
// server/routes/adminSync.ts
import type { Request, Response, Router } from 'express';
import express from 'express';
import { runSync } from '../lib/sync';

const router: Router = express.Router();

function isAuthorized(req: Request) {
  const token = req.headers['x-admin-token'];
  return token && token === process.env.ADMIN_SYNC_TOKEN;
}

router.post('/run', async (req: Request, res: Response) => {
  try {
    if (!isAuthorized(req)) return res.status(401).json({ error: 'unauthorized' });

    const {
      entities = ['owners','properties','units','leases','tenants'],
      mode = 'incremental',
      sinceDays = 30,
    } = req.body || {};

    const result = await runSync(entities, mode, sinceDays);
    res.json({ ok: true, ...result });
  } catch (err: any) {
    res.status(500).json({ ok: false, error: err?.message || String(err) });
  }
});

export default router;

Wire it into your server

Open server/index.ts (or wherever you mount routes) and add:

// server/index.ts (excerpt)
import express from 'express';
import adminSyncRoute from './routes/adminSync';

const app = express();
app.use(express.json());

// ... existing routes
app.use('/api/admin/sync', adminSyncRoute);

// ... existing server listen

üñ•Ô∏è 4) UI page (no sidebar change): /admin/sync
src/features/admin/pages/AdminSyncPage.tsx
// src/features/admin/pages/AdminSyncPage.tsx
import { useState } from 'react';

const ALL = ['owners','properties','units','leases','tenants'] as const;
type Entity = typeof ALL[number];

export default function AdminSyncPage() {
  const [mode, setMode] = useState<'incremental'|'full'>('incremental');
  const [sinceDays, setSinceDays] = useState(30);
  const [selected, setSelected] = useState<Record<Entity, boolean>>(
    { owners:true, properties:true, units:true, leases:true, tenants:true }
  );
  const [busy, setBusy] = useState(false);
  const [result, setResult] = useState<any>(null);
  const [error, setError] = useState<string| null>(null);
  const [token, setToken] = useState('');

  const toggle = (k:Entity) => setSelected(s => ({...s, [k]: !s[k]}));

  async function run() {
    setBusy(true); setError(null); setResult(null);
    try {
      const entities = ALL.filter(k => selected[k]);
      const res = await fetch('/api/admin/sync/run', {
        method: 'POST',
        headers: { 'Content-Type':'application/json', 'X-Admin-Token': token },
        body: JSON.stringify({ entities, mode, sinceDays }),
      });
      const json = await res.json();
      if (!res.ok) throw new Error(json?.error || 'Request failed');
      setResult(json);
    } catch (e:any) {
      setError(e.message);
    } finally {
      setBusy(false);
    }
  }

  return (
    <div className="p-6 max-w-3xl mx-auto text-[var(--text)]">
      <h1 className="text-2xl mb-4">Admin Sync</h1>
      <div className="mb-4">
        <label className="block text-sm mb-1">Admin Token</label>
        <input
          className="w-full rounded px-3 py-2 bg-[var(--panel-bg)] border border-[var(--line)]"
          value={token}
          onChange={e=>setToken(e.target.value)}
          placeholder="Paste ADMIN_SYNC_TOKEN"
        />
      </div>
      <div className="mb-4 grid grid-cols-2 gap-2">
        {ALL.map(k => (
          <label key={k} className="flex gap-2 items-center">
            <input type="checkbox" checked={selected[k]} onChange={()=>toggle(k)} />
            <span className="capitalize">{k}</span>
          </label>
        ))}
      </div>
      <div className="mb-4 flex gap-4 items-center">
        <label className="flex gap-2 items-center">
          <input type="radio" checked={mode==='incremental'} onChange={()=>setMode('incremental')} />
          Incremental (recommended)
        </label>
        <label className="flex gap-2 items-center">
          <input type="radio" checked={mode==='full'} onChange={()=>setMode('full')} />
          Full (slow)
        </label>
        {mode==='incremental' &&
          <div className="flex items-center gap-2">
            <span>Since (days)</span>
            <input
              type="number"
              className="w-20 rounded px-2 py-1 bg-[var(--panel-bg)] border border-[var(--line)]"
              value={sinceDays}
              onChange={e=>setSinceDays(Number(e.target.value||30))}
            />
          </div>}
      </div>
      <button
        disabled={busy}
        onClick={run}
        className="px-4 py-2 rounded bg-[var(--altus-gold)] text-black disabled:opacity-50"
      >
        {busy ? 'Running‚Ä¶' : 'Run Sync'}
      </button>

      {error && <div className="mt-4 text-red-400">{error}</div>}
      {result && (
        <pre className="mt-4 p-3 bg-[var(--panel-bg)] border border-[var(--line)] rounded text-xs overflow-auto">
{JSON.stringify(result, null, 2)}
        </pre>
      )}
    </div>
  );
}

Add route (no sidebar changes)

Open your top-level router (likely src/App.tsx where you use wouter) and add:

// src/App.tsx (excerpt)
import { Route, Switch } from 'wouter';
import AdminSyncPage from './features/admin/pages/AdminSyncPage';

// inside <Switch> ‚Ä¶
<Route path="/admin/sync" component={AdminSyncPage} />


Now you can visit /admin/sync directly and run a secure, admin-only, multi-entity sync.

‚úÖ What you get now

Admin-only one-click sync for owners, properties, units, leases, tenants

Incremental by default (fast), or full if you need a complete refresh

No sidebar or nav changes required

Extensible: add work_orders, communications, files, lease_payments/charges/credits by dropping additional modules in server/lib/sync/