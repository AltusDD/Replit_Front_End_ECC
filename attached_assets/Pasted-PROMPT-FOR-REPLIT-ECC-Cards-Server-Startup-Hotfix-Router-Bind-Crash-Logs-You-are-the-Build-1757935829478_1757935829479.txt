PROMPT FOR REPLIT — “ECC Cards: Server Startup Hotfix (Router Bind + Crash Logs)”

You are the Build Agent. Apply these steps exactly. Do not change ports, build scripts, or any files not listed here. If any command fails, STOP and print the full error.

0) Keep the contract

Web on 5173, API on 8787.

Cards only. No portfolio/table work.

No masking fallbacks.

1) Router hotfix (most likely cause of “connection refused”)

Open server/routes/rpc.ts and ensure it uses an Express Router, not app.get.

At the top:

import { Router } from "express";
const rpc = Router();


All handlers must be router-relative, i.e.:

// ✅ CORRECT
rpc.get("/get_property_card", async (req, res) => { /* … */ });
rpc.get("/get_unit_card",     async (req, res) => { /* … */ });
rpc.get("/get_lease_card",    async (req, res) => { /* … */ });
rpc.get("/get_owner_card",    async (req, res) => { /* … */ });
rpc.get("/get_tenant_card",   async (req, res) => { /* … */ });


If any handler currently reads app.get("/api/rpc/get_…") or app.get("/get_…"), replace it with rpc.get("/get_…").

At the bottom of the file:

export default rpc;


Do not add /api/rpc in this file. The mount point lives in server/index.ts.

2) Mount + crash logging

Open server/index.ts and make sure:

You mount the router once:

import rpc from "./routes/rpc";
app.use("/api/rpc", rpc);


Health + env diag routes exist (as you already added):

app.get("/api/health", (_req, res) => res.json({ ok: true }));
app.get("/api/diag/env", (_req, res) => res.json(envSummary()));


Add hard crash logging above app.listen:

process.on("uncaughtException", (e) => {
  console.error("[uncaughtException]", e);
});
process.on("unhandledRejection", (e) => {
  console.error("[unhandledRejection]", e);
});


Keep the original port logic:

const PORT = Number(process.env.API_PORT ?? 8787);
app.listen(PORT, "0.0.0.0", () => {
  console.log(`[Dev API] Listening on :${PORT}`);
});

3) Kill strays, run API alone, print the error if any
pkill -f "tsx server/index.ts" || true
pkill -f vite || true
rm -rf .vite node_modules/.vite dist .cache .parcel-cache 2>/dev/null || true

# Run API only to see a clean stack trace
npm run dev:api || pnpm run dev:api || tsx server/index.ts


If it crashes, STOP and print the full stack trace (this is the error we need).

If it stays up and prints [Dev API] Listening on :8787 and [EnvLock] …, continue.

4) Verify API, then run both
# API-only smoke checks
curl -s http://localhost:8787/api/health
curl -s http://localhost:8787/api/diag/env

# Cards RPC checks (use ids we’ve been testing)
curl -s "http://localhost:8787/api/rpc/get_property_card?id=52" | jq '{kpis:.kpis}'
curl -s "http://localhost:8787/api/rpc/get_unit_card?id=45"      | jq '{unit:.unit?.id, lease:.lease?.id, tenant:.tenant?.id}'
curl -s "http://localhost:8787/api/rpc/get_lease_card?id=1"      | jq '{lease:.lease?.id, unit:.unit?.id, tenant:.tenant?.id}'
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=11"     | jq '{owner:.owner?.id}'
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=3"     | jq '{tenant:.tenant?.id, active:.activeLease!=null}'

# If all good, start full dev (web + api)
npm run dev

5) If it still refuses connections

Run these quick diagnostics and print outputs:

# Is anything bound to 8787?
ss -tulpn | grep 8787 || true

# Type errors during import?
node -e "try{require('fs').accessSync('./server/routes/rpc.ts');console.log('rpc.ts present')}catch(e){console.error(e)}"

# Ensure the file actually exports a router
node -e "const m=require('./server/routes/rpc.ts'); console.log('rpc default:', !!(m && (m.default||m).use))" || true


If rpc default: false, your file isn’t exporting an Express router; return to Step 1.

6) Deliverables (print these)

The full stack trace if the API-only command fails.

If API starts: the [EnvLock] … line, curl /api/health, and the 5 RPC curl outputs.

End of prompt.

This stays inside the guardrails, fixes the most common startup killer (router vs app binding), adds hard crash logs, and gives you deterministic verification. If a stack trace appears, send me that single trace and I’ll give you a one-file micro-patch.