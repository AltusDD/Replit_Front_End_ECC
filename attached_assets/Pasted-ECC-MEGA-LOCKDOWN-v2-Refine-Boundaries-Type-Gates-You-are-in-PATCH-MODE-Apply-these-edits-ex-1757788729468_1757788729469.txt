ECC MEGA LOCKDOWN — v2 (Refine, Boundaries, Type Gates)

You are in PATCH MODE. Apply these edits exactly. Print diffs and the outputs of the verification commands. Do not change anything outside of what’s below.

A) Refine overlay guardrail (reduce false positives; still strict)

Replace scripts/guardrail-overlays.mjs with:

import fs from "fs";
import path from "path";
const ROOT = path.resolve(process.cwd(), "src");

const SCAN_EXT = [".tsx", ".ts", ".css", ".scss", ".less", ".jsx", ".js"];
const offenders = [];
const allowlistFile = path.resolve("scripts/guardrail-allowlist.json");
const allow = fs.existsSync(allowlistFile) ? JSON.parse(fs.readFileSync(allowlistFile,"utf8")) : { files:[], selectors:[] };

// A “cover” must meet TWO conditions: full-viewport + intent (backdrop/overlay/high z)
const rxFullViewport =
  /(position\s*:\s*(fixed|absolute)[^;{]*)(inset\s*:\s*0|top\s*:\s*0[\s\S]*left\s*:\s*0[\s\S]*right\s*:\s*0[\s\S]*bottom\s*:\s*0)/i;
const rxIntent =
  /(backdrop|overlay|page-cover|loading-screen|scrim|modal-backdrop|fullscreen|full-screen|z-?index\s*:\s*(?:[5-9]\d|[1-9]\d{2,}))/i;

// Tailwind-ish class combos (“fixed inset-0”, “z-50”) also count as intent
const rxTW = /(class(Name)?=)["'][^"']*(fixed[^"']*inset-0|inset-0[^"']*fixed)[^"']*["']/i;
const rxZ50 = /(class(Name)?=)["'][^"']*(z-(50|75|100|\[?\d{3,}\]?))[^"']*["']/i;

function walk(dir){ for(const f of fs.readdirSync(dir)){ const full=path.join(dir,f); const s=fs.statSync(full); s.isDirectory()?walk(full):scan(full);} }
function scan(file){
  const ext = path.extname(file).toLowerCase();
  if(!SCAN_EXT.includes(ext)) return;
  if((allow.files||[]).some(a => file.endsWith(a))) return;
  const src = fs.readFileSync(file,"utf8");
  const hitFull = rxFullViewport.test(src) || rxTW.test(src);
  const hitIntent = rxIntent.test(src) || rxZ50.test(src);
  if(hitFull && hitIntent){
    // allow inline doc marker for legitimate small popovers (not desired, but optional)
    if(src.includes("/* ECC-ALLOW-FIXED */")) return;
    offenders.push(file);
  }
}

walk(ROOT);
if(offenders.length){
  console.error("❌ FORBIDDEN OVERLAY PATTERNS:\n"+offenders.map(f=>" - "+f).join("\n"));
  process.exit(2);
}
console.log("✅ Overlay guardrail passed (refined).");


Create scripts/guardrail-allowlist.json:

{ "files": [], "selectors": [] }


(Leave it empty; it’s there in case we ever need a surgical allow for a tiny non-cover tooltip. Default is none.)

B) Add a global ErrorBoundary that renders inline panels (never blank)

Create: src/components/EccErrorBoundary.tsx

import React from "react";

export class EccErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error?: any }
> {
  constructor(props:any){ super(props); this.state = { hasError:false }; }
  static getDerivedStateFromError(error:any){ return { hasError:true, error }; }
  componentDidCatch(err:any, info:any){ console.error("ECC Boundary:", err, info); }
  render(){
    if(!this.state.hasError) return this.props.children as any;
    return (
      <section className="ecc-object">
        <div className="ecc-header">
          <div className="ecc-title">Something went wrong</div>
        </div>
        <div style={{opacity:.8}}>
          The page failed to render. Please try again or navigate elsewhere.
        </div>
      </section>
    );
  }
}


Edit: src/main.tsx — wrap the root <App />

import { EccErrorBoundary } from "./components/EccErrorBoundary";
// ...
ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <EccErrorBoundary>
      <App />
    </EccErrorBoundary>
  </React.StrictMode>
);

C) Forbid return null; in card pages (and enforce inline skeletons)

Create/replace: scripts/guardrail-mega.mjs (append this new rule near others):

// 5b) No 'return null;' or blank fragments in card pages
import path from "path";
const cardPage = /src[\/\\]pages[\/\\]card[\/\\](property|unit|lease|tenant|owner)[\/\\]index\.tsx$/i;
for (const f of files) {
  if (!cardPage.test(f)) continue;
  const src = fs.readFileSync(f, "utf8");
  if (/return\s+null\s*;/.test(src) || /return\s*<>\s*<\/>\s*;/.test(src)) {
    flag(f, "card pages must render a .ecc-object panel; 'return null' is forbidden");
  }
}


(Leave your other mega rules intact: no maps except Property, no raw /api/ in pages, Wouter-only, theme tokens, banned UI libs, required style imports.)

D) Disable dev-time React/Vite overlays at the source

Edit: vite.config.ts (or vite.config.tsx/.js—whichever you have)

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react({
    babel: { plugins: [] },
    // Ensure Babel/React plugin does not inject error overlays
  })],
  server: {
    hmr: { overlay: false }, // disable error overlays in dev
  }
});


(We already hide them via CSS kill-switch, but this prevents them from mounting at all.)

E) Add a cards-only typecheck so we can ship card work now

Create: tsconfig.cards.json

{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": true,
    "skipLibCheck": true,
    "strict": true
  },
  "include": [
    "src/lib/ecc-contract.ts",
    "src/lib/ecc-resolvers.ts",
    "src/lib/format.ts",
    "src/components/**/*",
    "src/pages/card/**/*"
  ],
  "exclude": [
    "node_modules",
    "src/**/__tests__/**"
  ]
}


Edit: package.json scripts (preserve your existing ones):

{
  "scripts": {
    "typecheck:cards": "tsc -p tsconfig.cards.json",
    "guardrail:overlays": "node scripts/guardrail-overlays.mjs",
    "guardrail:mega": "node scripts/guardrail-mega.mjs",
    "predev": "npm run guardrail:mega && npm run guardrail:overlays && npm run typecheck:cards",
    "prebuild": "npm run guardrail:mega && npm run guardrail:overlays && npm run guardrail && tsc -p tsconfig.cards.json"
  }
}


(This means dev is blocked only by card-scope TS errors, not legacy files. Full repo typecheck can remain a separate milestone.)

F) Ensure map-only-on-Property and resolver-only in pages are still enforced

Your guardrail-mega.mjs must keep these checks (do not remove):

GeoMap import only in src/pages/card/property/index.tsx

No "/api/" strings, no apiGet(, no lib/ecc-api imports in any page (use lib/ecc-resolvers)

Router: Wouter only (no react-router-dom)

Required style imports in src/main.tsx: theme.css, card-enhancer.css, no-overlays.css

Theme tokens (--ecc-object-bg: #2A2F38;, radius/padding 16px) stay locked

No banned UI libraries (Tailwind, MUI, Bootstrap, etc.)

G) Run & Report

Execute and paste the outputs:

npm run guardrail:mega
npm run guardrail:overlays
npm run typecheck:cards


Open these routes with real IDs and confirm:

/card/property/:id → renders content ✅, map present ✅, page cover ❌

/card/unit/:id → renders content ✅, no map ✅, page cover ❌

/card/lease/:id → renders content ✅, no map ✅, page cover ❌

/card/tenant/:id → renders content ✅, no map ✅, page cover ❌

/card/owner/:id → renders content ✅, no map ✅, page cover ❌

Return the three command outputs and a 5-line checklist (one per route) with the three booleans.

Why this solves the remaining pain

Refined overlay guardrail trims the 17 false positives but remains strict on true viewport covers.

EccErrorBoundary guarantees we never land on a blank page—errors render as inline .ecc-object panels.

No return null removes the most common silent blank.

Dev overlay disabled at Vite level + kill-switch CSS = no black screens.

Cards-only typecheck lets us ship the asset cards quickly while the repo’s legacy TS errors remain a separate track.

Mega checks keep the hard rules: map only on Property, resolvers-only in pages, Wouter routing, theme tokens, and no UI-framework drift.