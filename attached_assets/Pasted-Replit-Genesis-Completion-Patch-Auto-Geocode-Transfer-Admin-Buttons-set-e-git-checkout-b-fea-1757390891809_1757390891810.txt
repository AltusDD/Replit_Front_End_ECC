Replit — Genesis Completion Patch (Auto-Geocode + Transfer Admin Buttons)
set -e
git checkout -b feat/genesis-completion || git checkout feat/genesis-completion

############################################
# 0) PREREQS (no code changes)
############################################
# Ensure these Secrets exist in Replit (Values you already have):
#   GOOGLE_MAPS_API_KEY = <your key>
#   GEOCODER_PROVIDER   = google
#   ADMIN_SYNC_TOKEN    = <your admin token>
# Optional: INTERNAL_WEBHOOK_URL / SECRET to forward GEOCODE events to your bus.

############################################
# 1) SERVER — Geocoding helper (Google + cache)
############################################
mkdir -p server/lib server/jobs
cat > server/lib/geocode.ts <<'TS'
import fetch from "node-fetch";
import { getState, upsertState } from "./integrationState";
import { recordAudit } from "./audit";
import { sbAdmin } from "./supabaseAdmin";

const RATE_LIMIT_MS = 500; // ~2 req/sec
const PROVIDER = (process.env.GEOCODER_PROVIDER || "google").toLowerCase();
const GOOGLE_KEY = process.env.GOOGLE_MAPS_API_KEY || "";

function sleep(ms:number){ return new Promise(r=>setTimeout(r,ms)); }
function norm(s?:string){ return (s||"").trim().replace(/\s+/g," "); }
function addrKey(line1?:string, city?:string, state?:string, zip?:string){
  const base = [norm(line1), norm(city), norm(state), norm(zip)].filter(Boolean).join(", ").toLowerCase();
  const safe = base.replace(/[^a-z0-9]+/g,"-");
  return `geocode_cache:${safe}`.slice(0, 200);
}

async function getCache(key:string){
  const row = await getState(key);
  return row?.value || null;
}
async function setCache(key:string, value:any){
  await upsertState(key, value);
}

async function geocodeGoogle(addr:string){
  if(!GOOGLE_KEY) throw new Error("NO_GOOGLE_KEY");
  const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(addr)}&key=${GOOGLE_KEY}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error(`GEOCODE_HTTP_${res.status}`);
  const j = await res.json();
  if(j.status==="ZERO_RESULTS") return null;
  if(!j.results?.[0]?.geometry?.location) return null;
  const { lat, lng } = j.results[0].geometry.location;
  return { lat, lng, raw: j.results[0] };
}

export async function geocodePropertyRow(p:any){
  const line1 = p.line1 || p.address || "";
  const city = p.city || "";
  const state = p.state || "";
  const zip = p.postal_code || p.zip || "";
  const addr = [line1, city, state, zip].filter(Boolean).join(", ");
  if(!addr) return null;

  const key = addrKey(line1, city, state, zip);
  // cache first
  const cached = await getCache(key);
  if(cached && cached.lat && cached.lng) return { ...cached, cached:true };

  // call provider
  let out = null as any;
  if(PROVIDER==="google") out = await geocodeGoogle(addr);
  if(!out) return null;

  await setCache(key, { lat: out.lat, lng: out.lng, addr });
  return { lat: out.lat, lng: out.lng, raw: out.raw, cached:false };
}

export async function writeGeocode(p:any, geo:any){
  const { error } = await sbAdmin.from("properties").update({ lat: geo.lat, lng: geo.lng }).eq("id", p.id);
  if(error) throw new Error(error.message);
  await recordAudit({
    event_type: "GEOCODE_AUTO",
    label: "GEOCODE",
    ref_table: "properties",
    ref_id: p.id,
    payload: { lat: geo.lat, lng: geo.lng }
  });
}
TS

############################################
# 2) SERVER — Background tick (scan & fill)
############################################
cat > server/jobs/autoGeocodeTick.ts <<'TS'
import { sbAdmin } from "../lib/supabaseAdmin";
import { geocodePropertyRow, writeGeocode } from "../lib/geocode";

function sleep(ms:number){ return new Promise(r=>setTimeout(r,ms)); }

let running = false;
export async function runAutoGeocodeTick(){
  if(running) return;
  running = true;
  try{
    // scan small batch of properties missing coordinates with viable address
    const { data, error } = await sbAdmin
      .from("properties")
      .select("id,line1,address,city,state,postal_code,lat,lng")
      .or("lat.is.null,lng.is.null")
      .limit(20);

    if(error) return;
    const list = (data||[]).filter(p => (p.line1||p.address) && (p.city||p.state||p.postal_code));
    for(const p of list){
      try{
        const geo = await geocodePropertyRow(p);
        if(geo && geo.lat && geo.lng){
          await writeGeocode(p, geo);
        }
      }catch(_e){ /* swallow per-row errors */ }
      await sleep(500); // ~2 per second
    }
  } finally {
    running = false;
  }
}
TS

############################################
# 3) SERVER — Schedule the tick on boot
############################################
applypatch <<'PATCH'
*** Begin Patch
*** Update File: server/index.ts
@@
-import { runDueTransfersTick } from "./lib/ownerTransfer";
-import { runAutoGeocodeTick } from "./jobs/autoGeocodeTick";
+import { runDueTransfersTick } from "./lib/ownerTransfer";
+import { runAutoGeocodeTick } from "./jobs/autoGeocodeTick";
@@
 setInterval(() => runDueTransfersTick(), 5*60*1000)
+// Auto-geocoding loop (every 60s)
+setInterval(() => runAutoGeocodeTick(), 60*1000)
*** End Patch
PATCH

############################################
# 4) FRONTEND — Owner Transfer detail admin buttons (Approve/Authorize/Execute)
############################################
applypatch <<'PATCH'
*** Begin Patch
*** Update File: src/features/owners/pages/OwnerTransferDetailPage.tsx
@@
-import React, { useEffect, useMemo, useState } from "react";
+import React, { useEffect, useMemo, useState } from "react";
 import { useLocation } from "wouter";
 import { useToast } from "../../../components/ui/Toast";
 import RightRail, { RiskScoreWidget, KeyDatesWidget, PinnedFilesWidget } from "../../cards/widgets/RightRail";
 import ProvenanceTag from "../../../components/ui/ProvenanceTag";
+import ActivityFeed from "../../activity/ActivityFeed";
 
 export default function OwnerTransferDetailPage(){
   const [loc] = useLocation();
   const params = new URLSearchParams(loc?.split("?")[1]||"");
   const id = params.get("id");
   const { push } = useToast();
+  const [transfer, setTransfer] = useState<any>(null);
+  const [loading, setLoading] = useState(false);
+
+  useEffect(()=>{ (async()=>{
+    if(!id) return;
+    try{
+      const r = await fetch(`/api/owner-transfer/${id}`);
+      if(r.ok){ const j = await r.json(); setTransfer(j?.transfer||j); }
+    }catch{}
+  })(); },[id]);
+
+  async function post(path:string, admin=false){
+    setLoading(true);
+    try{
+      const headers:any = { "Content-Type":"application/json" };
+      if(admin){
+        const t = localStorage.getItem("ADMIN_SYNC_TOKEN") || "";
+        if(t) headers["Authorization"] = `Bearer ${t}`;
+      }
+      const r = await fetch(path, { method:"POST", headers, body: JSON.stringify({ transfer_id: Number(id) }) });
+      if(!r.ok){ const msg = await r.text(); throw new Error(msg||"Request failed"); }
+      const j = await r.json().catch(()=> ({}));
+      // refresh
+      try{ const rr = await fetch(`/api/owner-transfer/${id}`); if(rr.ok){ const jj = await rr.json(); setTransfer(jj?.transfer||jj); } }catch{}
+      push({ title: "Success", message: "Action completed.", type: "success" });
+    }catch(e:any){
+      push({ title: "Error", message: String(e.message||e), type: "error" });
+    }finally{
+      setLoading(false);
+    }
+  }
@@
-            <h2 className="text-lg font-semibold">
+            <h2 className="text-lg font-semibold">
               Owner Transfer Detail — #{id}
               {/* show CoreLogic provenance if available (example only) */}
               <ProvenanceTag source="CoreLogic" />
             </h2>
+            <div className="flex items-center gap-2">
+              <button className="btn btn-secondary"
+                disabled={loading}
+                onClick={()=>post("/api/owner-transfer/approve-accounting", false)}
+                title="Mark accounting as approved">
+                Approve Accounting
+              </button>
+              <button className="btn"
+                disabled={loading}
+                onClick={()=>post("/api/owner-transfer/authorize", true)}
+                title="Admin-only authorization">
+                Authorize
+              </button>
+              <button className="btn btn-primary"
+                disabled={loading}
+                onClick={()=>post("/api/owner-transfer/execute", true)}
+                title="Admin-only immediate execution">
+                Execute Now
+              </button>
+            </div>
           </div>
         </div>
         <div className="card-content p-4">
-          {/* Activity feed with filters */}
-          <ActivityFeed table="owner_transfers" refId={String(id)} />
+          {/* Activity feed with filters */}
+          <ActivityFeed table="owner_transfers" refId={String(id)} />
         </div>
*** End Patch
PATCH

git add -A
git commit -m "feat: auto-geocode tick (rate-limited + cached) and transfer admin buttons on detail page"

What you’ll get right away

Auto-Geocode starts filling lat/lng automatically (during tick) and logs GEOCODE_AUTO events. This feeds your map and keeps running until all properties are covered.

Transfer detail now has the Approve / Authorize / Execute buttons with proper admin gating via localStorage.ADMIN_SYNC_TOKEN. (Ask Replit to set that in the browser console once; it persists.)

The rest of the Genesis upgrades (badges, Files tabs, Activity, Teams/Planner/SharePoint hooks) remain intact.

Replit → quick verification script (paste for them)

Title: “Genesis Completion QA (Geocode + Transfer Admin)”

Restart app.

Geocode sanity:

Run SQL (Supabase): select count(*) from properties where lat is null or lng is null;

Wait ~2–3 minutes, run again; the number should be dropping.

Check recent audit: GEOCODE_AUTO entries appear.

Owner Transfer Admin:

In browser devtools: localStorage.ADMIN_SYNC_TOKEN = "<your ADMIN_SYNC_TOKEN>";

Visit /owners/transfer/detail?id=<id>.

Click Approve Accounting → then Authorize → then Execute Now.

Confirm toasts, status update, audit events, and (if set) Teams notifications.

Map check: when a few properties geocode, load the dashboard map and confirm pins.

Deliverables:

Screenshot of GEOCODE_AUTO audit events

Before/after counts of missing coordinates

Screenshot of transfer detail with buttons + a complete transfer