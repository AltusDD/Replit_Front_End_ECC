ECC Contract Standardization Pack (CSP) v2
What this fixes (matches your audit)

Data structure: Property page stops using data.raw.property; all cards consume the same flat contract ({ property | unit | lease | tenant | owner, … }).

Auth parity: RPC routes use the same multi-env Supabase client as /entities.

Response format: Client no longer “unwraps”; server returns raw JSON; client reads raw JSON.

Guardrail: All cards import from @/lib/ecc-resolvers (we re-export there).

Query keys: Standardized to ['card', '<type>', id].

Abort safety: Server RPC gets a best-effort abort hook; client keeps React Query aborts.

Patch 0 — Shared Supabase client (auth parity)

Create server/lib/supabase.ts:

// server/lib/supabase.ts
import { createClient } from '@supabase/supabase-js';

const SUPABASE_URL =
  process.env.SUPABASE_URL ??
  process.env.VITE_SUPABASE_URL ?? '';

const SUPABASE_KEY =
  process.env.SUPABASE_SERVICE_ROLE_KEY ??
  process.env.SUPABASE_SERVICE_KEY ??
  process.env.SUPABASE_KEY ??
  process.env.SUPABASE_ANON_KEY ??
  process.env.VITE_SUPABASE_ANON_KEY ?? '';

export function getSupabase() {
  if (!SUPABASE_URL || !SUPABASE_KEY) {
    console.warn('[ECC/API] Missing Supabase envs; url:', !!SUPABASE_URL, ' key:', !!SUPABASE_KEY);
  }
  return createClient(SUPABASE_URL, SUPABASE_KEY, { auth: { persistSession: false } });
}


Update both server/routes/entities.ts and server/routes/rpc.ts to:

import { getSupabase } from '../lib/supabase';
const supabase = getSupabase();


(No other behavior changes here; just ensure both routes use this helper.)

Patch 1 — Entities shapes + filters (if not already applied)

In server/routes/entities.ts:

Single: return the row directly.

Collection: support ?field=eq.value + ?limit=n.

r.get('/:table/:id', async (req, res) => {
  const { table, id } = req.params;
  const { data, error } = await supabase.from(table).select('*').eq('id', id).single();
  if (error) return res.status(500).json({ error: error.message });
  res.json(data); // raw object
});

r.get('/:table', async (req, res) => {
  const { table } = req.params;
  let q = supabase.from(table).select('*');
  for (const [key, val] of Object.entries(req.query)) {
    if (key === 'limit') continue;
    const [op, value] = String(val).split('=');
    if (op === 'eq') q = q.eq(key, value);
  }
  if (req.query.limit) q = q.limit(Number(req.query.limit));
  const { data, error } = await q;
  if (error) return res.status(500).json({ error: error.message });
  res.json(data); // raw array
});

Patch 2 — RPC best-effort abort + shared client

At top of each handler in server/routes/rpc.ts:

r.get('/get_property_card', async (req, res) => {
  const ac = new AbortController();
  req.on('close', () => ac.abort()); // best effort
  // pass `ac.signal` to node fetches if you add any; supabase-js v2 has limited abort support
  // ...existing logic using `const supabase = getSupabase()`
});


(This addresses your “Missing AbortController” item pragmatically.)

Patch 3 — Client fetcher simplification (remove unwrap)

Edit src/lib/ecc-api-client.ts (or wherever j() lives):

export async function j<T>(url: string, init?: RequestInit): Promise<T> {
  const r = await fetch(url, init);
  if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
  // server now returns raw JSON – no legacy "unwrap"
  return (await r.json()) as T;
}


(Delete any unwrap() helpers and their call sites.)

Patch 4 — One import to satisfy guardrail

Create src/lib/ecc-resolvers.ts:

// Re-export hooks so every card imports from here (guardrail-compliant)
export {
  usePropertyCard,
  useUnitCard,
  useLeaseCard,
  useTenantCard,
  useOwnerCard,
} from './ecc-card-queries';


Update all 5 card pages to import hooks from @/lib/ecc-resolvers.

Patch 5 — Standardize hook contracts + query keys

Edit src/lib/ecc-card-queries.ts: (illustrative snippets)

import { useQuery } from '@tanstack/react-query';
import { j } from './ecc-api-client';

type Id = string | number;

export function usePropertyCard(id: Id) {
  return useQuery({
    queryKey: ['card','property', id], // normalized
    queryFn: async () => {
      // RPC first
      try {
        const dto = await j<{ property: any; units: any[]; leases: any[]; owner?: any }>(
          `/api/rpc/get_property_card?id=${id}`
        );
        // return flat, no "raw"
        return dto;
      } catch {
        // fallback: compose from entities
        const property = await j<any>(`/api/entities/properties/${id}`);
        const units = await j<any[]>(`/api/entities/units?doorloop_property_id=eq.${property.doorloop_id}`);
        const leases = await j<any[]>(`/api/entities/leases?property_id=eq.${property.id}`);
        // owner optional
        return { property, units, leases, owner: null };
      }
    },
    staleTime: 60_000,
  });
}

export function useUnitCard(id: Id) {
  return useQuery({
    queryKey: ['card','unit', id],
    queryFn: async () => {
      try {
        return await j<{ unit: any; property?: any; lease?: any; tenant?: any }>(
          `/api/rpc/get_unit_card?id=${id}`
        );
      } catch {
        const unit = await j<any>(`/api/entities/units/${id}`);
        const property = unit?.doorloop_property_id
          ? await j<any>(`/api/entities/properties?doorloop_id=eq.${unit.doorloop_property_id}&limit=1`)
              .then(arr => arr[0] ?? null)
          : null;
        const lease = await j<any[]>(`/api/entities/leases?unit_id=eq.${unit.id}&limit=1`).then(a=>a[0]??null);
        const tenant = lease?.primary_tenant_id
          ? await j<any>(`/api/entities/tenants/${lease.primary_tenant_id}`)
          : null;
        return { unit, property, lease, tenant };
      }
    },
    staleTime: 60_000,
  });
}

// Do the same key + flat shape for useLeaseCard/useTenantCard/useOwnerCard

Patch 6 — Property page contract fix

Edit src/pages/card/property/index.tsx:

Replace all data?.raw?.property with data?.property.

Ensure you destructure from the hook result:

import { usePropertyCard } from '@/lib/ecc-resolvers';

const { data, isLoading, error } = usePropertyCard(id);
const property = data?.property;
const units = data?.units ?? [];
const leases = data?.leases ?? [];
const owner = data?.owner ?? null;


(Do the same import path change on Unit/Lease/Tenant/Owner pages. Their access pattern already matches { unit | lease | tenant | owner }.)

Patch 7 — Query key normalization on all hooks

Ensure every hook uses ['card','<type>', id] so caching/invalidation is consistent.

Definition of Done (CSP v2)

Server

Starts with your existing secrets (no renames needed).

/api/entities/properties/42 → raw object.

/api/entities/leases?property_id=eq.42&limit=5 → raw array.

/api/rpc/get_property_card?id=42 → 200 (if implemented), otherwise client fallback succeeds.

Client

No references to raw or unwrap remain.

All 5 card pages import hooks from @/lib/ecc-resolvers.

All hooks use query keys ['card','<type>', id].

UI

Navigate to:

/card/property/42 (no “not found”; hero KPIs reflect real counts if data exists)

/card/unit/45

/card/lease/1

/card/tenant/1

/card/owner/1

Switching tabs doesn’t refetch base entity due to normalized keys.

Quick sanity checklist (copy/paste to console after start)
# API shape checks
curl -s http://localhost:8787/api/entities/properties/42 | jq '.id,.name'
curl -s "http://localhost:8787/api/entities/leases?property_id=eq.42&limit=2" | jq 'length'

# (If RPC exists)
curl -s "http://localhost:8787/api/rpc/get_property_card?id=42" | jq '.property.id,.units|length,.leases|length'
