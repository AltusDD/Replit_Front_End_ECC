REPLIT CHAT PROMPT — “Stabilize Dashboard Fetches (StrictMode-safe), Silence AbortErrors, Gate Eruda”

Goal (non-negotiable):

Eliminate all DOMException AbortError logs and eruda DOMException.

Ensure all dashboard data hooks are StrictMode-safe (React dev double-invoke) and fast.

No regressions to Portfolio V3 pages. Live data only.

Phase 0 — Preflight (read-only; paste back)

Find the offending lines mentioned in the stack:

src/features/dashboard/hooks/useDashboardData.ts around line ~257 (where cleanup abort triggers a logged error or setState).

Any console.error/throw in catches that runs for aborts.

Locate any eruda init (regex: eruda, __replco/static/devtools/eruda).

Paste the snippets you find (file + line numbers).

Phase 1 — Add shared, StrictMode-safe fetch helpers

Create src/utils/net.ts:

// src/utils/net.ts
export const isAbortError = (e: any): boolean =>
  !!e && (e.name === "AbortError" || e.code === 20 || String(e).includes("AbortError"));

export async function fetchJSON<T = any>(
  input: RequestInfo | URL,
  init?: RequestInit & { signal?: AbortSignal }
): Promise<T> {
  const res = await fetch(input, init);
  if (!res.ok) {
    // Preserve real errors; these are not aborts
    const text = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} ${res.statusText}: ${text}`);
  }
  return (await res.json()) as T;
}

/** Guards setState after unmount and silences AbortErrors */
export function guardAsync<T extends any[]>(
  fn: (...args: T) => Promise<void>
) {
  return (...args: T) => {
    let alive = true;
    const stop = () => { alive = false; };
    const run = async () => {
      try {
        await fn(...args);
      } catch (e) {
        if (isAbortError(e)) return; // swallow aborts
        throw e; // let caller handle real errors
      }
    };
    return { run, stop, aliveRef: () => alive };
  };
}

Phase 2 — Harden all dashboard hooks (StrictMode-safe, silent aborts)

Open src/features/dashboard/hooks/useDashboardData.ts and refactor each useEffect that does network work to this pattern:

import { useEffect, useState, useMemo } from "react";
import { fetchJSON, isAbortError, guardAsync } from "@/utils/net"; // adjust alias if needed

// Example for one dataset; apply to every fetch in this file:
useEffect(() => {
  const ac = new AbortController();

  const { run, stop, aliveRef } = guardAsync(async () => {
    setLoading(true);

    // 1) Fetch in parallel (pass signal to every request)
    const [properties, units, leases] = await Promise.all([
      fetchJSON("/api/portfolio/properties", { signal: ac.signal }),
      fetchJSON("/api/portfolio/units", { signal: ac.signal }),
      fetchJSON("/api/portfolio/leases", { signal: ac.signal }),
    ]);

    if (!aliveRef()) return; // StrictMode: don’t set state after unmount

    // 2) Derive metrics here (memoize outside if heavy)
    const derived = computeStuff(properties, units, leases);

    setData(derived);
    setError(null);
  });

  run().catch((e) => {
    if (isAbortError(e)) return; // never log aborts
    console.error("[dashboard] data fetch error:", e);
    setError(e);
  }).finally(() => {
    if (!ac.signal.aborted) setLoading(false);
  });

  return () => {
    stop();
    ac.abort(); // triggers AbortError in the fetch; we’re swallowing it
  };
}, [/* stable deps only; avoid recreating needlessly */]);


Rules to enforce across the file:

Always create a fresh AbortController per effect; pass signal to every fetch.

Never console.error or throw on an AbortError — check with isAbortError.

Never call setState after unmount — guard with the aliveRef() gate (or a mounted ref).

In finally, do not log or set error if signal.aborted is true; only flip loading if not aborted.

Remove any catch(e){ console.error(e) } that prints on aborts.

Replace any ad-hoc fetches inside components (KPI, Map, Feed, Charts) with calls to these normalized hook functions or reuse the same pattern.

Phase 3 — Gate eruda devtools to avoid DOMException

Wherever eruda is initialized (often a tiny script in index.html, main.tsx, or a dev helper):

// Wrap in a strict gate. Pseudocode; adjust location/file accordingly.
if (import.meta.env.DEV && location.search.includes("eruda")) {
  import("eruda")
    .then((eruda) => {
      try { eruda.default.init(); } catch {}
    })
    .catch(() => {});
}
// Remove any unconditional eruda injection or shadow-DOM manipulation.


AC: No eruda scripts load unless ?eruda is in the URL and we’re in dev.

Phase 4 — Final polish & QA (no console noise, still fast)

Add skeletons to all dashboard panels during loading if not already present.

Verify the KPI click-throughs still route correctly.

Ensure Google Map cluster/pins render only after data exists; otherwise show an inline neutral empty state.

Confirm global date formatting remains Mon D, YYYY for all dashboard dates.

Phase 5 — Acceptance criteria (paste proof)

Console clean: Reload, navigate away/back, resize — paste a screenshot or log capture showing no errors/warnings.

StrictMode stress test: Rapidly switch between Dashboard and one Portfolio page 5x — no AbortError logs.

Code diff: Show the exact lines changed in useDashboardData.ts (around prior line ~257) and where eruda was gated.

Performance check: First data paint ≤ 1s on Replit dev (after cache), charts defer until data present.

Commit message

chore(dashboard): StrictMode-safe data hooks — silent AbortErrors, unified fetch helpers; gate eruda behind ?eruda; skeletons + stable loading

Notes

If any other hooks (Portfolio pages) show the same abort pattern, apply the same Phase 2 fix there as well (but only in a separate incremental commit to avoid risky blast radius).

Do not remove aborts — they’re valuable for perf; the fix is to swallow them and avoid setState after unmount.

Run Phase 0 and paste findings first, then proceed.