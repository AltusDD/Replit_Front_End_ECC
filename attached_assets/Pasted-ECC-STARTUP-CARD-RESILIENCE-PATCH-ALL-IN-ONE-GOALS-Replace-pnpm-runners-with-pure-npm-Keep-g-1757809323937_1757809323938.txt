ECC STARTUP + CARD RESILIENCE PATCH (ALL-IN-ONE)

GOALS

Replace pnpm runners with pure npm.

Keep guardrails passing.

Property card renders with partial data (no page-blocking on relation fetch errors).

Resolver imports comply with ECC rules (from lib/ecc-card-resolvers).

A) PACKAGE.JSON — DEV SCRIPT (npm only)

Open package.json.

In "scripts", replace the current "dev" with:
"dev": "npm run guardrail && concurrently -k -n WEB,API -c blue,magenta "npm run dev:web" "npm run dev:api""

Ensure these two scripts exist (create if missing):
"dev:web": "vite --strictPort --port=5173",
"dev:api": "node server/index.js"

Ensure these exist (or keep as-is if already present):
"guardrail": "node scripts/guardrail-check.mjs",
"guardrail:overlays": "node scripts/guardrail-overlays.mjs",
"guardrail:mega": "node scripts/guardrail-mega.mjs",
"typecheck:cards": "tsc -p tsconfig.cards.json"

Add devDeps if needed (edit package.json, do not run shell commands):

concurrently @ "^8.2.2"

Do NOT add pnpm. We must run with npm only.

B) RESOLVER IMPORT COMPLIANCE

We must import ECC resolvers from lib/ecc-card-resolvers.

If there is a file at src/lib/cards/property.api.ts, delete it (we will use the ECC resolver file).

In src/pages/card/property/index.tsx, change resolver import to:
import { usePropertyCardData } from "@/lib/ecc-card-resolvers";

C) PROPERTY CARD — NON-BLOCKING RELATIONS
Edit src/lib/ecc-card-resolvers.ts to expose a DTO-first + entities-fallback property resolver that NEVER changes the number of hooks per render and only treats the base property as fatal:

// === BEGIN PATCH: in src/lib/ecc-card-resolvers.ts ===
// Add or replace the property hook with this version.
export function usePropertyCardData(id: string | number) {
const dtoQ = useQuery({
queryKey: ["propertyCardDTO", id],
queryFn: async () => {
try { return await apiGet(/api/rpc/get_property_card?id=${id}); }
catch { return null; }
},
staleTime: 60_000,
});

const propQ = useQuery({
queryKey: ["property", id],
queryFn: async () => {
try { return await apiGet(/entities/properties/${id}); }
catch {
const arr = await apiGet(/entities/properties?id=eq.${id});
return Array.isArray(arr) ? (arr[0] ?? null) : null;
}
},
enabled: !dtoQ.data,
staleTime: 60_000,
});

const unitsQ = useQuery({
queryKey: ["unitsByDoorloop", propQ.data?.doorloop_id ?? null],
queryFn: () => apiGet(/entities/units?doorloop_property_id=eq.${propQ.data!.doorloop_id}),
enabled: !!(!dtoQ.data && propQ.data?.doorloop_id),
staleTime: 60_000,
});

const leasesQ = useQuery({
queryKey: ["leasesByProperty", propQ.data?.id ?? null],
queryFn: () => apiGet(/entities/leases?property_id=eq.${propQ.data!.id}),
enabled: !!(!dtoQ.data && propQ.data?.id),
staleTime: 60_000,
});

const ownerQ = useQuery({
queryKey: ["ownerById", propQ.data?.owner_id ?? null],
queryFn: async () => {
const oid = propQ.data!.owner_id!;
try { return await apiGet(/entities/owners/${oid}); }
catch {
try {
const arr = await apiGet(/entities/owners?id=eq.${oid});
if (Array.isArray(arr)) return arr[0] ?? null;
} catch {}
try {
const arr = await apiGet(/entities/owner?id=eq.${oid});
if (Array.isArray(arr)) return arr[0] ?? null;
} catch {}
return null;
}
},
enabled: !!(!dtoQ.data && propQ.data?.owner_id),
staleTime: 60_000,
});

const data = dtoQ.data
? {
property: dtoQ.data.property ?? null,
units: dtoQ.data.units ?? [],
leases: dtoQ.data.leases ?? [],
owner: dtoQ.data.owner ?? null,
}
: {
property: propQ.data ?? null,
units: unitsQ.data ?? [],
leases: leasesQ.data ?? [],
owner: ownerQ.data ?? null,
};

const fatalError = dtoQ.data ? null : (!data.property ? (propQ.error ?? null) : null);
const relationErrors = [
dtoQ.data ? null : unitsQ.error,
dtoQ.data ? null : leasesQ.error,
dtoQ.data ? null : ownerQ.error,
].filter(Boolean) as Error[];

const isLoading =
dtoQ.isLoading ||
(!dtoQ.data && (propQ.isLoading || unitsQ.isLoading || leasesQ.isLoading || ownerQ.isLoading));

return { data, isLoading, fatalError, relationErrors };
}
// === END PATCH ===

D) PROPERTY PAGE — SHOW PARTIAL DATA, NEVER BLANK
Edit src/pages/card/property/index.tsx:

Use the updated hook:
const { data, isLoading, fatalError, relationErrors } = usePropertyCardData(id);

Fatal-only blocker:
if (fatalError) {
return <Section className="ecc-object">Error loading property. Please try again.</Section>;
}

Inline, non-blocking relation warning (inside Relationships section or near the tabs):
{relationErrors.length > 0 && (

<div className="ecc-object" style={{ padding: 8, opacity: .8 }}> Some related data failed to load (units / leases / owner). Property details are shown. </div> )}

E) VERIFY

Run:
node scripts/guardrail-mega.mjs
node scripts/guardrail-overlays.mjs
npx tsc -p tsconfig.cards.json

All must pass with 0 violations / errors.

F) RUN

Start with: npm run dev

Confirm both WEB and API processes are live in one terminal (via concurrently).

G) DEMO ROUTES (post-patch)

/card/property/42 and /card/property/57 must render:

Hero (title + KPIs),

Overview details (owner link when present),

Map in right rail,

If any relation fetch fails → small inline warning but the page renders.

Post the three verification outputs and a note confirming both /card/property/42 and /card/property/57 display as described.

If Replit cannot modify package.json due to platform constraints, apply this fallback:

Create dev.mjs at repo root that uses child_process to spawn:

vite --strictPort --port=5173

node server/index.js
with stdio inherited, kill on exit.

Then set "dev": "node dev.mjs" in package.json.