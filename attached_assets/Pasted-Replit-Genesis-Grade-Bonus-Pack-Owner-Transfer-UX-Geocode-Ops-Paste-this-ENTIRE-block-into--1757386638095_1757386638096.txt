Replit — “Genesis-Grade” Bonus Pack (Owner Transfer UX + Geocode Ops)

Paste this ENTIRE block into the Replit Shell:

set -e
git checkout -b feat/genesis-bonus-pack

########################################
# 0) FOLDERS
########################################
mkdir -p server/routes server/jobs server/lib server/lib/geocode db/migrations
mkdir -p src/components/ui src/features/audit src/features/owners/{components,pages} src/features/admin/pages
touch .keep

########################################
# 1) SERVER — Audit helper (idempotent)
########################################
cat > server/lib/audit.ts <<'TS'
import { sbAdmin } from "./supabaseAdmin";
type Audit = {
  event_type: string;
  label?: string | null;
  ref_table?: string | null;
  ref_id?: number | string | null;
  payload?: any;
};
export async function recordAudit(a: Audit) {
  await sbAdmin.from("audit_events").insert({
    event_type: a.event_type,
    label: a.label ?? null,
    ref_table: a.ref_table ?? null,
    ref_id: a.ref_id ?? null,
    payload: a.payload ?? null
  });
}
TS

########################################
# 2) SERVER — Geocode cache table (once)
########################################
cat > db/migrations/20250908_geocode_cache.sql <<'SQL'
create table if not exists public.geocode_cache (
  address_hash text primary key,
  normalized   text,
  lat          double precision not null,
  lng          double precision not null,
  updated_at   timestamptz default now()
);
create index if not exists geocode_cache_updated_at on public.geocode_cache(updated_at desc);
SQL
echo "REMINDER: run db/migrations/20250908_geocode_cache.sql in Supabase (SQL editor)."

########################################
# 3) SERVER — Geocoder helper (Google)
########################################
cat > server/lib/geocode/geocode.ts <<'TS'
import fetch from "node-fetch";
import crypto from "crypto";
import { sbAdmin } from "../supabaseAdmin";
import { recordAudit } from "../audit";

const PROVIDER = process.env.GEOCODER_PROVIDER || "google";
const API_KEY  = process.env.GOOGLE_MAPS_API_KEY || "";

function norm(s:string){ return s.trim().replace(/\s+/g," ").toUpperCase(); }
function addrKey(a:{line1?:string;line2?:string;city?:string;state?:string;postal_code?:string;}){
  const base=[a.line1,a.line2,a.city,a.state,a.postal_code].filter(Boolean).map(norm).join(", ");
  return crypto.createHash("sha256").update(base).digest("hex");
}
async function getFromCache(hash:string){
  const { data, error } = await sbAdmin.from("geocode_cache").select("lat,lng,normalized").eq("address_hash",hash).maybeSingle();
  if (error) throw error; return data||null;
}
async function putInCache(hash:string, normalized:string, lat:number, lng:number){
  const { error } = await sbAdmin.from("geocode_cache").upsert({ address_hash: hash, normalized, lat, lng });
  if (error) throw error;
}
async function googleGeocode(q:string){
  if(!API_KEY) return null;
  const res=await fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(q)}&key=${API_KEY}`);
  if(!res.ok) return null;
  const j=await res.json();
  const hit=j?.results?.[0]; if(!hit) return null;
  const lat=hit.geometry?.location?.lat, lng=hit.geometry?.location?.lng;
  const normalized=hit.formatted_address || q;
  if(typeof lat!=="number"||typeof lng!=="number") return null;
  return { lat,lng,normalized };
}

let last=0;
async function throttle(){ const gap=500, d=Date.now()-last; if(d<gap) await new Promise(r=>setTimeout(r,gap-d)); last=Date.now(); }

export type Address={line1?:string;line2?:string;city?:string;state?:string;postal_code?:string;};
export async function geocodeAddress(addr:Address){
  const parts=[addr.line1,addr.line2,addr.city,addr.state,addr.postal_code].filter(Boolean);
  if(!parts.length) return null;
  const query=parts.join(", "); const hash=addrKey(addr);
  const cached=await getFromCache(hash); if(cached) return { lat: cached.lat, lng: cached.lng };
  await throttle();
  let result: any = null;
  if(PROVIDER==="google") result = await googleGeocode(query);
  if(result){
    await putInCache(hash,result.normalized,result.lat,result.lng);
    await recordAudit({event_type:"GEOCODE_AUTO",label:"GEOCODE_AUTO",ref_table:"properties",payload:{provider:PROVIDER,query,normalized:result.normalized}});
    return { lat: result.lat, lng: result.lng };
  }
  return null;
}
TS

########################################
# 4) SERVER — Auto-geocode tick + heartbeat
########################################
cat > server/jobs/autoGeocodeTick.ts <<'TS'
import { sbAdmin } from "../lib/supabaseAdmin";
import { geocodeAddress } from "../lib/geocode/geocode";
import { recordAudit } from "../lib/audit";

async function getState(key:string){
  const { data } = await sbAdmin.from("integration_state").select("value").eq("key",key).maybeSingle();
  return data?.value ?? null;
}
async function setState(key:string, value:any){
  await sbAdmin.from("integration_state").upsert({ key, value });
}

export async function runAutoGeocodeTick(){
  // prefer integration_state override, else env, else 10
  const overrideBatch = (await getState("GEOCODE_TICK_BATCH")) ?? null;
  const BATCH = Number.isFinite(Number(overrideBatch)) ? Number(overrideBatch) : parseInt(process.env.GEOCODE_TICK_BATCH || "10",10);

  const { data: props, error } = await sbAdmin
    .from("properties")
    .select("id,line1,line2,city,state,postal_code,lat,lng")
    .or("lat.is.null,lng.is.null")
    .limit(BATCH);

  if (error) return;

  let done = 0;
  for (const p of (props||[])) {
    try{
      const res = await geocodeAddress({ line1:p.line1, line2:p.line2, city:p.city, state:p.state, postal_code:p.postal_code });
      if(res){
        await sbAdmin.from("properties").update({ lat: res.lat, lng: res.lng }).eq("id", p.id);
        await recordAudit({ event_type:"GEOCODE_AUTO_APPLY", label:"GEOCODE_AUTO", ref_table:"properties", ref_id:p.id, payload:res });
        done++;
      }
    }catch{}
  }
  await setState("GEOCODE_LAST_RUN", { ts: new Date().toISOString(), processed: (props||[]).length, updated: done });
}
TS

########################################
# 5) SERVER — Owner Transfer routes: preflight, dry-run, report, csv, audit
########################################
applypatch <<'PATCH'
*** Begin Patch
*** Update File: server/routes/ownerTransfer.ts
@@
 import express from "express";
 import { initiateTransfer, approveAccounting, authorizeTransfer, executeTransfer } from "../lib/ownerTransfer";
+import { sbAdmin } from "../lib/supabaseAdmin";
+import { recordAudit } from "../lib/audit";
 const router = express.Router();
@@
 router.post("/api/owner-transfer/initiate", async (req, res) => {
   const { old_owner_id, new_owner_id, property_ids, effective_date, notes } = req.body || {};
   const user = (req as any).user || null;
   const transfer = await initiateTransfer({ old_owner_id, new_owner_id, property_ids, effective_date, notes, user });
   return res.json({ ok: true, id: transfer.id, transfer });
 });
@@
 router.post("/api/owner-transfer/approve-accounting", async (req, res) => {
   const { transfer_id } = req.body || {};
   const t = await approveAccounting(transfer_id);
   return res.json({ ok: true, transfer: t });
 });
@@
 router.post("/api/owner-transfer/authorize", async (req, res) => {
   const token = (req.headers["authorization"]||"").replace(/^Bearer\s+/i,"");
   if (token !== process.env.ADMIN_SYNC_TOKEN) return res.status(401).send("Unauthorized");
   const { transfer_id } = req.body || {};
   const t = await authorizeTransfer(transfer_id);
   return res.json({ ok: true, transfer: t });
 });
@@
 router.post("/api/owner-transfer/execute", async (req, res) => {
   const token = (req.headers["authorization"]||"").replace(/^Bearer\s+/i,"");
   if (token !== process.env.ADMIN_SYNC_TOKEN) return res.status(401).send("Unauthorized");
   const { transfer_id } = req.body || {};
   const t = await executeTransfer(transfer_id);
   return res.json({ ok: true, transfer: t });
 });
+
+// ---- Preflight: non-destructive checks
+router.post("/api/owner-transfer/preflight", async (req, res) => {
+  const { transfer_id } = req.body || {};
+  const { data: t, error } = await sbAdmin.from("owner_transfers").select("*").eq("id", transfer_id).maybeSingle();
+  if (error || !t) return res.status(404).send("Transfer not found");
+  const checks = [];
+  if (!t.effective_date) checks.push({ level:"blocker", message:"Missing effective date" });
+  if (!t.property_ids?.length) checks.push({ level:"blocker", message:"No properties selected" });
+  // verify properties belong to old_owner_id
+  const { data: props } = await sbAdmin.from("properties").select("id,owner_id").in("id", t.property_ids || []);
+  const wrong = (props||[]).filter(p => p.owner_id !== t.old_owner_id).map(p => p.id);
+  if (wrong.length) checks.push({ level:"blocker", message:`Properties not owned by old_owner_id: ${wrong.join(", ")}` });
+  // heads-up if future date
+  const today = new Date(); today.setHours(0,0,0,0);
+  const eff = new Date(t.effective_date); eff.setHours(0,0,0,0);
+  if (eff > today) checks.push({ level:"warning", message:"Effective date is in the future (will execute on/after that date)" });
+  return res.json({ ok:true, checks });
+});
+
+// ---- Dry-run: show intended changes (no writes)
+router.post("/api/owner-transfer/dry-run", async (req, res) => {
+  const { transfer_id } = req.body || {};
+  const { data: t, error } = await sbAdmin.from("owner_transfers").select("*").eq("id", transfer_id).maybeSingle();
+  if (error || !t) return res.status(404).send("Transfer not found");
+  const { data: props } = await sbAdmin.from("properties").select("id,owner_id").in("id", t.property_ids || []);
+  const changes = (props||[]).map(p => ({ property_id: p.id, from_owner: p.owner_id, to_owner: t.new_owner_id }));
+  return res.json({ ok:true, transfer_id, changes, summary:{ count: changes.length } });
+});
+
+// ---- CSV for Accounting Packet
+router.get("/api/owner-transfer/:id/accounting.csv", async (req, res) => {
+  const id = Number(req.params.id);
+  const { data: t } = await sbAdmin.from("owner_transfers").select("*").eq("id", id).maybeSingle();
+  if (!t) return res.status(404).send("Not found");
+  const { data: props } = await sbAdmin.from("properties").select("id,owner_id,line1,city,state,postal_code").in("id", t.property_ids || []);
+  const rows = [
+    "transfer_id,old_owner_id,new_owner_id,effective_date,property_id,from_owner,to_owner,address,city,state,postal_code",
+    ...(props||[]).map(p => `${id},${t.old_owner_id},${t.new_owner_id},${t.effective_date},${p.id},${p.owner_id},${t.new_owner_id},"${(p as any).line1||""}",${(p as any).city||""},${(p as any).state||""},${(p as any).postal_code||""}`)
+  ].join("\n");
+  res.setHeader("Content-Type","text/csv");
+  res.setHeader("Content-Disposition",`attachment; filename=owner_transfer_${id}_accounting.csv`);
+  return res.send(rows);
+});
+
+// ---- Print-friendly HTML report (simple)
+router.get("/api/owner-transfer/:id/report.html", async (req, res) => {
+  const id = Number(req.params.id);
+  const { data: t } = await sbAdmin.from("owner_transfers").select("*").eq("id", id).maybeSingle();
+  if (!t) return res.status(404).send("Not found");
+  const { data: props } = await sbAdmin.from("properties").select("id,line1,city,state,postal_code").in("id", t.property_ids || []);
+  const html = `<!doctype html>
+  <html><head><meta charset="utf-8"><title>Owner Transfer #${id}</title>
+  <style>
+    body{font-family:ui-sans-serif,system-ui; color:#e5e7eb; background:#0a0a0a; padding:24px;}
+    h1{font-size:22px;margin:0 0 8px;}
+    .muted{color:#9ca3af;}
+    table{width:100%;border-collapse:collapse;margin-top:12px;}
+    td,th{border:1px solid #1f2937;padding:8px;text-align:left;}
+    th{background:#111827;}
+  </style></head>
+  <body>
+    <h1>Owner Transfer #${id}</h1>
+    <div class="muted">Effective: ${t.effective_date} &nbsp;|&nbsp; Old Owner: ${t.old_owner_id} → New Owner: ${t.new_owner_id}</div>
+    <table>
+      <thead><tr><th>ID</th><th>Address</th><th>City</th><th>State</th><th>Postal</th></tr></thead>
+      <tbody>
+        ${(props||[]).map(p=>`<tr><td>${p.id}</td><td>${(p as any).line1||""}</td><td>${(p as any).city||""}</td><td>${(p as any).state||""}</td><td>${(p as any).postal_code||""}</td></tr>`).join("")}
+      </tbody>
+    </table>
+  </body></html>`;
+  res.setHeader("Content-Type","text/html");
+  return res.send(html);
+});
*** End Patch
PATCH

########################################
# 6) SERVER — Audit: filter by ref (helper route)
########################################
cat > server/routes/audit.ts <<'TS'
import express from "express";
import { sbAdmin } from "../lib/supabaseAdmin";
const router = express.Router();

router.get("/api/audit/by-ref", async (req, res) => {
  const ref_table = String(req.query.table||"");
  const ref_id = String(req.query.ref_id||"");
  if (!ref_table || !ref_id) return res.status(400).send("Missing table/ref_id");
  const { data, error } = await sbAdmin
    .from("audit_events")
    .select("created_at,event_type,label,ref_table,ref_id,payload")
    .eq("ref_table", ref_table)
    .eq("ref_id", ref_id)
    .order("created_at", { ascending: false })
    .limit(50);
  if (error) return res.status(500).send(error.message);
  return res.json({ ok:true, events: data||[] });
});
export default router;
TS

########################################
# 7) SERVER — Wire routes + geocode tick + properties sync hook
########################################
applypatch <<'PATCH'
*** Begin Patch
*** Update File: server/index.ts
@@
 import express from "express";
 import cors from "cors";
 import ownerTransferRouter from "./routes/ownerTransfer";
+import auditRouter from "./routes/audit";
 import { runDueTransfersTick } from "./lib/ownerTransfer";
+import { runAutoGeocodeTick } from "./jobs/autoGeocodeTick";
 
 const app = express();
 app.use(cors());
 app.use(express.json());
 app.use(ownerTransferRouter);
+app.use(auditRouter);
 
 setInterval(() => runDueTransfersTick(), 5*60*1000);
 if ((process.env.AUTO_SYNC_ENABLED || "true") === "true") {
   setInterval(() => runAutoGeocodeTick(), 60*1000);
 }
 export default app;
*** End Patch
PATCH

# Hook geocode attempt into properties sync (best-effort)
applypatch <<'PATCH'
*** Begin Patch
*** Update File: server/lib/sync/properties.ts
@@
 import { sbAdmin } from "../../supabaseAdmin";
+import { geocodeAddress } from "../../geocode/geocode";
+import { recordAudit } from "../../audit";
@@
   // after property upsert:
+  try {
+    const needs = (!mapped.lat && !mapped.lng);
+    const hasAddr = !!(mapped.line1 || mapped.city || mapped.postal_code);
+    if (needs && hasAddr) {
+      const geo = await geocodeAddress({ line1: mapped.line1, line2: mapped.line2, city: mapped.city, state: mapped.state, postal_code: mapped.postal_code });
+      if (geo) {
+        await sbAdmin.from("properties").update({ lat: geo.lat, lng: geo.lng }).eq("id", upsertedId);
+        await recordAudit({ event_type:"GEOCODE_AUTO_APPLY", label:"GEOCODE_AUTO", ref_table:"properties", ref_id: upsertedId, payload: geo });
+      }
+    }
+  } catch {}
*** End Patch
PATCH

########################################
# 8) FRONTEND — Toast system (no deps)
########################################
cat > src/components/ui/Toast.tsx <<'TSX'
import React, { createContext, useContext, useState, useCallback } from "react";

type ToastItem = { id: number; kind: "success"|"error"|"info"; message: string; };
const ToastCtx = createContext<{ push:(t:Omit<ToastItem,"id">)=>void }|null>(null);

export function ToastProvider({ children }:{children:any}){
  const [items,setItems]=useState<ToastItem[]>([]);
  const push = useCallback((t:Omit<ToastItem,"id">)=>{
    const id=Date.now()+Math.random();
    setItems(s=>[...s,{ id, ...t }]);
    setTimeout(()=>setItems(s=>s.filter(x=>x.id!==id)), 4000);
  },[]);
  return (
    <ToastCtx.Provider value={{ push }}>
      {children}
      <div className="fixed bottom-4 right-4 space-y-2 z-50">
        {items.map(i=>(
          <div key={i.id} className={`px-3 py-2 rounded-md shadow-md border text-sm
            ${i.kind==="success" ? "bg-green-900/40 border-green-600 text-green-300" :
               i.kind==="error"   ? "bg-red-900/40 border-red-600 text-red-300" :
                                    "bg-neutral-800 border-neutral-600 text-neutral-200"}`}>
            {i.message}
          </div>
        ))}
      </div>
    </ToastCtx.Provider>
  );
}
export function useToast(){
  const ctx = useContext(ToastCtx);
  if(!ctx) throw new Error("Wrap app with <ToastProvider>");
  return ctx;
}
TSX

# (If you have a root App, wrap ToastProvider—idempotent hint)
applypatch <<'PATCH'
*** Begin Patch
*** Update File: src/main.tsx
@@
-import React from "react";
+import React from "react";
 import ReactDOM from "react-dom/client";
 import App from "./App";
+import { ToastProvider } from "./components/ui/Toast";
@@
-  <App />
+  <ToastProvider><App /></ToastProvider>
*** End Patch
PATCH

########################################
# 9) FRONTEND — Owner Card: deep link button
########################################
applypatch <<'PATCH'
*** Begin Patch
*** Update File: src/features/owners/components/OwnerCard.tsx
@@
 import { Link } from "wouter";
@@
   <div className="mt-4 flex gap-2">
     <Link href={`/owners/transfer?ownerId=${owner.id}`}>
       <a className="btn btn-primary">Transfer Ownership</a>
     </Link>
+    <Link href={`/owners/transfers?ownerId=${owner.id}`}>
+      <a className="btn btn-secondary">Recent Transfers</a>
+    </Link>
   </div>
*** End Patch
PATCH

########################################
# 10) FRONTEND — Owner Transfer Detail: confirmations, toasts, preflight, dry-run, audit, exports
########################################
applypatch <<'PATCH'
*** Begin Patch
*** Update File: src/features/owners/pages/OwnerTransferDetailPage.tsx
@@
-import React, { useEffect, useState } from "react";
-import { useLocation } from "wouter";
+import React, { useEffect, useMemo, useState } from "react";
+import { useLocation } from "wouter";
+import { useToast } from "../../../components/ui/Toast";
 
 type Transfer = { id: number; status: string; effective_date: string; old_owner_id: number; new_owner_id: number; property_ids: number[] };
@@
   const [t, setT] = useState<Transfer | null>(null);
   const [busy, setBusy] = useState(false);
   const [err, setErr] = useState<string | null>(null);
+  const [checks, setChecks] = useState<{level:"blocker"|"warning",message:string}[]|null>(null);
+  const [dry, setDry] = useState<any|null>(null);
+  const [confirmKind, setConfirmKind] = useState<""|"authorize"|"execute">("");
+  const [confirmText, setConfirmText] = useState("");
+  const { push } = useToast();
 
   async function load() {
     setErr(null);
     try { const j = await api(`/api/owner-transfer/${id}`); setT(j); } catch (e:any){ setErr(e.message); }
   }
   useEffect(() => { if (id) load(); }, [id]);
 
   async function doPost(endpoint: string) {
-    setBusy(true); setErr(null);
+    setBusy(true); setErr(null);
     try { await api(endpoint, { method: "POST", body: JSON.stringify({ transfer_id: Number(id) }) }); await load(); }
-    catch (e:any){ setErr(e.message) } finally { setBusy(false); }
+    catch (e:any){ setErr(e.message) } finally { setBusy(false); }
   }
+  async function runPreflight(){
+    setChecks(null); setErr(null); setBusy(true);
+    try{ const j = await api("/api/owner-transfer/preflight", { method:"POST", body: JSON.stringify({ transfer_id: Number(id) })}); setChecks(j.checks||[]); push({kind:"success",message:"Preflight complete"}); }
+    catch(e:any){ setErr(e.message); }
+    finally{ setBusy(false); }
+  }
+  async function runDryRun(){
+    setDry(null); setErr(null); setBusy(true);
+    try{ const j = await api("/api/owner-transfer/dry-run", { method:"POST", body: JSON.stringify({ transfer_id: Number(id) })}); setDry(j); push({kind:"info",message:`Dry-run: ${j?.summary?.count||0} change(s)`}); }
+    catch(e:any){ setErr(e.message); }
+    finally{ setBusy(false); }
+  }
+  function canConfirm(){
+    if(confirmKind==="authorize") return confirmText.toUpperCase()==="AUTHORIZE";
+    if(confirmKind==="execute")   return confirmText.toUpperCase()==="EXECUTE";
+    return false;
+  }
 
   if (!id) return <div className="p-6 text-red-400">Missing transfer id</div>;
   return (
     <div className="p-6 text-neutral-200">
       <div className="card bg-neutral-900 border border-neutral-800">
         <div className="card-header px-4 py-3 border-b border-neutral-800">
-          <h2 className="text-lg font-semibold">Owner Transfer Detail — #{id}</h2>
+          <div className="flex items-center justify-between">
+            <h2 className="text-lg font-semibold">Owner Transfer Detail — #{id}</h2>
+            {t && (
+              <span className={`px-2 py-1 rounded text-xs border ${
+                t.status?.includes("COMPLETE") ? "bg-green-900/30 border-green-600 text-green-300" :
+                t.status?.includes("READY")    ? "bg-yellow-900/30 border-yellow-600 text-yellow-300" :
+                t.status?.includes("PENDING")  ? "bg-blue-900/30 border-blue-600 text-blue-300" :
+                                                 "bg-neutral-800 border-neutral-700 text-neutral-200"
+              }`}>{t.status}</span>
+            )}
+          </div>
           {err && <div className="mt-2 text-sm text-red-400">{err}</div>}
         </div>
         <div className="card-content p-4 space-y-3">
           {!t ? <div>Loading…</div> : (
             <>
               <div className="grid grid-cols-2 gap-3 text-sm">
                 <div><span className="text-neutral-400">Status:</span> {t.status}</div>
                 <div><span className="text-neutral-400">Effective:</span> {t.effective_date}</div>
                 <div><span className="text-neutral-400">Old Owner:</span> {t.old_owner_id}</div>
                 <div><span className="text-neutral-400">New Owner:</span> {t.new_owner_id}</div>
                 <div className="col-span-2"><span className="text-neutral-400">Properties:</span> {t.property_ids?.join(", ")}</div>
               </div>
+              {/* Action row */}
               <div className="pt-3 flex flex-wrap gap-2">
-                <button disabled={busy} onClick={() => doPost("/api/owner-transfer/approve-accounting")} className="btn btn-secondary">Approve Accounting</button>
-                <button disabled={busy} onClick={() => doPost("/api/owner-transfer/authorize")} className="btn btn-warning">Authorize</button>
-                <button disabled={busy} onClick={() => doPost("/api/owner-transfer/execute")} className="btn btn-primary">Execute Now</button>
+                <button disabled={busy} onClick={async()=>{ await doPost("/api/owner-transfer/approve-accounting"); push({kind:"success",message:"Accounting approved"}); }} className="btn btn-secondary">Approve Accounting</button>
+                <button disabled={busy} onClick={()=>{ setConfirmKind("authorize"); setConfirmText(""); }} className="btn btn-warning">Authorize</button>
+                <button disabled={busy} onClick={()=>{ setConfirmKind("execute"); setConfirmText(""); }} className="btn btn-primary">Execute Now</button>
+                <button disabled={busy} onClick={runPreflight} className="btn">Run Preflight</button>
+                <button disabled={busy} onClick={runDryRun} className="btn">Dry-Run</button>
+                <a className="btn" href={`/api/owner-transfer/${id}/accounting.csv`} target="_blank" rel="noreferrer">Download Accounting CSV</a>
+                <a className="btn" href={`/api/owner-transfer/${id}/report.html`} target="_blank" rel="noreferrer">Print Report</a>
               </div>
+              {/* Preflight results */}
+              {checks && (
+                <div className="mt-3 border border-neutral-800 rounded p-3">
+                  <div className="text-sm font-medium mb-2">Preflight Checks</div>
+                  <ul className="text-sm space-y-1">
+                    {checks.length===0 && <li className="text-green-300">All clear</li>}
+                    {checks.map((c,i)=>(
+                      <li key={i} className={c.level==="blocker"?"text-red-300":"text-yellow-300"}>• [{c.level}] {c.message}</li>
+                    ))}
+                  </ul>
+                </div>
+              )}
+              {/* Dry-run view */}
+              {dry && (
+                <div className="mt-3 border border-neutral-800 rounded p-3">
+                  <div className="text-sm font-medium mb-2">Dry-Run Summary</div>
+                  <div className="text-sm text-neutral-300 mb-2">{dry?.summary?.count||0} change(s)</div>
+                  <pre className="text-xs bg-neutral-950 border border-neutral-800 p-2 rounded overflow-auto max-h-48">{JSON.stringify(dry, null, 2)}</pre>
+                </div>
+              )}
+              {/* Audit feed */}
+              <AuditFeed table="owner_transfers" refId={String(id)} />
               <p className="text-xs text-neutral-500 pt-2">Note: “Authorize” and “Execute Now” require an admin token. Set <code>ADMIN_SYNC_TOKEN</code> into <code>localStorage</code> if prompted.</p>
             </>
           )}
         </div>
       </div>
+      {/* Confirm Modal */}
+      {confirmKind && (
+        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50">
+          <div className="bg-neutral-900 border border-neutral-800 rounded-lg p-4 w-full max-w-md">
+            <div className="text-lg font-semibold mb-2">
+              {confirmKind==="authorize" ? "Confirm Authorization" : "Confirm Execute Now"}
+            </div>
+            <div className="text-sm text-neutral-300 mb-3">
+              Type <code className="text-neutral-100">{confirmKind==="authorize"?"AUTHORIZE":"EXECUTE"}</code> to confirm.
+            </div>
+            <input className="w-full bg-neutral-950 border border-neutral-800 rounded px-2 py-1 mb-3"
+                   value={confirmText} onChange={e=>setConfirmText(e.target.value)} placeholder="Type here..." />
+            <div className="flex justify-end gap-2">
+              <button className="btn" onClick={()=>setConfirmKind("")}>Cancel</button>
+              <button className={`btn ${confirmKind==="authorize"?"btn-warning":"btn-primary"}`} disabled={!canConfirm() || busy}
+                onClick={async ()=>{
+                  try{
+                    if(confirmKind==="authorize"){ await doPost("/api/owner-transfer/authorize"); push({kind:"success",message:"Authorized"}); }
+                    if(confirmKind==="execute")  { await doPost("/api/owner-transfer/execute");   push({kind:"success",message:"Executed"}); }
+                  } finally { setConfirmKind(""); }
+                }}>
+                {confirmKind==="authorize"?"Authorize":"Execute Now"}
+              </button>
+            </div>
+          </div>
+        </div>
+      )}
     </div>
   );
 }
 
+function AuditFeed({ table, refId }:{ table:string; refId:string }){
+  const [items,setItems]=useState<any[]|null>(null);
+  useEffect(()=>{ (async()=>{
+    try{ const r=await fetch(`/api/audit/by-ref?table=${encodeURIComponent(table)}&ref_id=${encodeURIComponent(refId)}`); const j=await r.json(); setItems(j.events||[]); }catch{ setItems([]); }
+  })(); },[table,refId]);
+  if(!items) return <div className="text-sm text-neutral-400 mt-3">Loading audit…</div>;
+  return (
+    <div className="mt-3 border border-neutral-800 rounded p-3">
+      <div className="text-sm font-medium mb-2">Recent Activity</div>
+      {items.length===0 ? <div className="text-xs text-neutral-500">No events</div> : (
+        <ul className="text-xs space-y-1">
+          {items.map((e,i)=>(
+            <li key={i} className="flex items-center gap-2">
+              <span className="text-neutral-500">{new Date(e.created_at).toLocaleString()}</span>
+              <span className="px-1.5 py-0.5 rounded border border-neutral-700 bg-neutral-800 text-neutral-200">{e.event_type}</span>
+              <span className="text-neutral-300">{e.label}</span>
+            </li>
+          ))}
+        </ul>
+      )}
+    </div>
+  )
+}
*** End Patch
PATCH

########################################
# 11) FRONTEND — Owner Transfer Stepper: success CTA (already added previously, idempotent)
########################################
# (No change if you already applied my last patch. Kept here as a safeguard.)
applypatch <<'PATCH'
*** Begin Patch
*** Update File: src/features/owners/pages/OwnerTransferPage.tsx
@@
 import { Link } from "wouter";
*** End Patch
PATCH

########################################
# 12) FRONTEND — Recent Transfers page (owner-scoped)
########################################
cat > src/features/owners/pages/OwnerTransfersListPage.tsx <<'TSX'
import React, { useEffect, useState } from "react";
import { useLocation, Link } from "wouter";

type T = { id:number; status:string; effective_date:string; old_owner_id:number; new_owner_id:number; property_ids:number[]; created_at?:string };

export default function OwnerTransfersListPage(){
  const [loc] = useLocation();
  const qs = new URLSearchParams(loc.split("?")[1]||"");
  const ownerId = Number(qs.get("ownerId")||0);
  const [items,setItems]=useState<T[]|null>(null);
  useEffect(()=>{ (async()=>{
    try{
      const r = await fetch(`/api/owner-transfers?ownerId=${ownerId}`);
      const j = await r.json(); setItems(j.items||[]);
    }catch{ setItems([]); }
  })(); },[ownerId]);
  return (
    <div className="p-6 text-neutral-200">
      <div className="card bg-neutral-900 border border-neutral-800">
        <div className="card-header px-4 py-3 border-b border-neutral-800">
          <h2 className="text-lg font-semibold">Recent Transfers {ownerId?`— Owner #${ownerId}`:""}</h2>
        </div>
        <div className="card-content p-4">
          {!items ? <div>Loading…</div> : items.length===0 ? <div className="text-neutral-400">No transfers</div> : (
            <table className="w-full text-sm">
              <thead><tr className="text-neutral-400">
                <th className="text-left py-2">ID</th><th className="text-left">Status</th><th className="text-left">Effective</th><th className="text-left">Props</th><th></th>
              </tr></thead>
              <tbody>
                {items.map(t=>(
                  <tr key={t.id} className="border-t border-neutral-800">
                    <td className="py-2">{t.id}</td>
                    <td>{t.status}</td>
                    <td>{t.effective_date}</td>
                    <td>{t.property_ids?.length||0}</td>
                    <td className="text-right">
                      <Link href={`/owners/transfer/detail?id=${t.id}`}><a className="btn btn-primary btn-sm">Open</a></Link>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </div>
      </div>
    </div>
  );
}
TSX

# Route + server endpoint for list
applypatch <<'PATCH'
*** Begin Patch
*** Update File: src/routes.tsx
@@
 import OwnerTransferPage from "./features/owners/pages/OwnerTransferPage";
 import OwnerTransferDetailPage from "./features/owners/pages/OwnerTransferDetailPage";
+import OwnerTransfersListPage from "./features/owners/pages/OwnerTransfersListPage";
@@
   { path: "/owners/transfer", component: OwnerTransferPage },
   { path: "/owners/transfer/detail", component: OwnerTransferDetailPage },
+  { path: "/owners/transfers", component: OwnerTransfersListPage },
*** End Patch
PATCH

applypatch <<'PATCH'
*** Begin Patch
*** Update File: server/routes/ownerTransfer.ts
@@
 const router = express.Router();
@@
 // list by owner (recent)
+router.get("/api/owner-transfers", async (req, res) => {
+  const ownerId = Number(req.query.ownerId || 0);
+  let q = sbAdmin.from("owner_transfers").select("*").order("created_at", { ascending:false }).limit(50);
+  if (ownerId) q = q.or(`old_owner_id.eq.${ownerId},new_owner_id.eq.${ownerId}`);
+  const { data, error } = await q;
+  if (error) return res.status(500).send(error.message);
+  return res.json({ ok:true, items: data||[] });
+});
*** End Patch
PATCH

########################################
# 13) FRONTEND — Admin Sync page: geocode heartbeat + batch override
########################################
applypatch <<'PATCH'
*** Begin Patch
*** Update File: src/features/admin/pages/AdminSyncPage.tsx
@@
 import React, { useEffect, useState } from "react";
@@
+async function getState(key:string){
+  const r = await fetch(`/api/admin/state?key=${encodeURIComponent(key)}`);
+  return r.ok ? r.json() : null;
+}
+async function setState(key:string, value:any){
+  await fetch(`/api/admin/state`, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ key, value }) });
+}
+
 export default function AdminSyncPage(){
   // existing code...
+  const [geoStatus,setGeoStatus]=useState<any|null>(null);
+  const [batch,setBatch]=useState<string>("");
+  useEffect(()=>{ (async()=>{
+    const s = await getState("GEOCODE_LAST_RUN"); setGeoStatus(s?.value||null);
+    const b = await getState("GEOCODE_TICK_BATCH"); setBatch(String(b?.value??""));
+  })(); },[]);
@@
   return (
     <div className="p-6 text-neutral-200">
       <div className="card bg-neutral-900 border border-neutral-800">
         <div className="card-header px-4 py-3 border-b border-neutral-800">
           <h2 className="text-lg font-semibold">Admin — Sync</h2>
         </div>
         <div className="card-content p-4 space-y-3">
           {/* existing admin controls ... */}
+          <div className="border border-neutral-800 rounded p-3">
+            <div className="text-sm font-semibold mb-2">Geocode Heartbeat</div>
+            {geoStatus ? (
+              <div className="text-sm">
+                Last: <span className="text-neutral-300">{new Date(geoStatus.ts).toLocaleString()}</span>
+                &nbsp; • Processed: <span className="text-neutral-300">{geoStatus.processed}</span>
+                &nbsp; • Updated: <span className="text-neutral-300">{geoStatus.updated}</span>
+              </div>
+            ) : <div className="text-sm text-neutral-400">No geocode runs recorded yet.</div>}
+            <div className="mt-3 flex items-center gap-2">
+              <label className="text-sm text-neutral-300">Tick Batch Override:</label>
+              <input className="bg-neutral-950 border border-neutral-800 rounded px-2 py-1 text-sm w-24" value={batch} onChange={e=>setBatch(e.target.value)} placeholder="(blank = env)" />
+              <button className="btn btn-secondary btn-sm" onClick={async()=>{ await setState("GEOCODE_TICK_BATCH", batch===""?null:Number(batch)); alert("Saved"); }}>Save</button>
+            </div>
+          </div>
         </div>
       </div>
     </div>
   );
 }
*** End Patch
PATCH

# Admin state endpoints (idempotent)
applypatch <<'PATCH'
*** Begin Patch
*** Update File: server/routes/adminSync.ts
@@
 import express from "express";
 import { runIncrementalSync, runFullSync } from "../lib/sync";
 import { requireAdmin } from "../lib/adminGuard";
+import { sbAdmin } from "../lib/supabaseAdmin";
 
 const router = express.Router();
@@
 router.post("/api/admin/sync", requireAdmin, async (req, res) => {
   const { mode="incremental", entities=[] } = req.body || {};
   if (mode === "full") await runFullSync(entities);
   else await runIncrementalSync(entities);
   res.json({ ok: true });
 });
+
+router.get("/api/admin/state", requireAdmin, async (req,res)=>{
+  const key = String(req.query.key||"");
+  if(!key) return res.status(400).send("Missing key");
+  const { data } = await sbAdmin.from("integration_state").select("*").eq("key", key).maybeSingle();
+  return res.json(data||{ key, value: null });
+});
+router.post("/api/admin/state", requireAdmin, async (req,res)=>{
+  const { key, value } = req.body||{};
+  if(!key) return res.status(400).send("Missing key");
+  await sbAdmin.from("integration_state").upsert({ key, value });
+  return res.json({ ok:true });
+});
*** End Patch
PATCH

########################################
# 14) OPTIONAL — Theme tokens (no changes). Buttons rely on existing classes.
########################################

git add -A
git commit -m "Genesis Bonus Pack: toasts, confirms, preflight, dry-run, audit feed, CSV/print report, geocode heartbeat + batch override, owner transfers list, deep links, hooks"

What you just got (all at once)

Action toasts: Success/Info/Error snack-bars for admin actions (approve/authorize/execute, preflight, dry-run).

Confirm modals: Type-to-confirm for Authorize (AUTHORIZE) and Execute (EXECUTE).

Preflight checks: Blocks execution on obvious problems (missing date, wrong owner on selected properties), warns on future date.

Dry-run: Non-destructive diff of intended owner changes for all properties; copyable JSON.

Audit feed: Real-time “Recent Activity” feed on transfer detail (50 latest, dark-theme).

Accounting packet: One-click CSV download for Accounting; print-friendly report (HTML) for easy PDF printing.

Owner Card links: Transfer button + “Recent Transfers” shortcut (owner-scoped list).

Recent Transfers page: Simple, dark-theme list with quick open to detail.

Geocode heartbeat: Admin page shows last geocode tick timestamp + processed/updated counts.

Geocode controls: Admin can override tick batch (integration_state.GEOCODE_TICK_BATCH) without redeploying env vars.

Geocode integration: Already wired into property sync and a background 60-sec trickle with caching, audits, and rate limit.

All of this uses your existing dark theme classes (card, btn, neutral shades). No new styling frameworks or visual drift.

90-second smoke test

SQL → Run the geocode cache migration in Supabase:

db/migrations/20250908_geocode_cache.sql

Owner Transfer flow

Create transfer on /owners/transfer?ownerId=<id> → see green success banner, click View transfer details.

On detail: Run Preflight, then open Dry-Run.

In DevTools: localStorage.setItem("ADMIN_SYNC_TOKEN","<your token>")

Click Authorize → type AUTHORIZE → confirm. Toast appears.

Click Execute Now → type EXECUTE → confirm. Toast appears.

Download Accounting CSV / open Print Report.

Audit feed shows your actions in seconds.

Admin → Sync: See Geocode Heartbeat box. Change Tick Batch to 25 → Save.

After a minute, heartbeat updates processed/updated.