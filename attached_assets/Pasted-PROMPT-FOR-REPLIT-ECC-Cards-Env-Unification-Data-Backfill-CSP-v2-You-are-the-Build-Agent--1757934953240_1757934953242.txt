PROMPT FOR REPLIT — “ECC Cards: Env Unification + Data Backfill (CSP v2)”

You are the Build Agent. Execute these steps exactly. Stop on the first error and print it. Do not “improve” anything outside of what’s listed.

0) Guardrails

Keep Vite 5173 + API 8787. Do not change ports.

Work only in: server/index.ts, server/routes/rpc.ts.

SQL only in Supabase. No Drizzle changes. No schema drops.

No masking in UI (?? 0, || 0, || '—').

1) ENV LOCK — prove API is using the intended Supabase project

Edit server/index.ts (near the top, after env loads) and add:

function mask(s?: string) {
  if (!s) return "MISSING";
  return s.slice(0, 6) + "…" + s.slice(-4);
}
function envSummary() {
  return {
    SUPABASE_URL: process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL || "MISSING",
    ANON_KEY: mask(process.env.SUPABASE_ANON_KEY),
    SERVICE_ROLE: mask(process.env.SUPABASE_SERVICE_ROLE_KEY),
    NODE_ENV: process.env.NODE_ENV || "dev",
  };
}
console.log("[EnvLock]", envSummary());


Add a read-only diag route (non-prod use):

app.get("/api/diag/env", (_req, res) => {
  res.json(envSummary());
});


Purpose: eliminate “environment mismatch.” This prints a sanitized summary at startup and exposes it at /api/diag/env.

2) RPC fetch function (if not present)

At top of server/routes/rpc.ts:

async function fetchOneMulti(sb:any, table:string, id:string|number, alt:string[]) {
  const v = String(id);
  const ors = ["id.eq."+v, ...alt.map(f => `${f}.eq.${v}`)].join(",");
  const { data, error } = await sb.from(table).select("*").or(ors).limit(1).maybeSingle();
  if (error) throw error;
  return data ?? null;
}
const low = (x:any) => String(x ?? "").toLowerCase();

3) RELATIONSHIP BACKFILL — run idempotent SQL in Supabase

Open Supabase → SQL Editor and run this block as-is:

-- ---- DIAGNOSTICS BEFORE -----------------------------
select
  (select count(*) from properties) as properties,
  (select count(*) from units) as units,
  (select count(*) from leases) as leases,
  (select count(*) from tenants) as tenants,
  (select count(*) from owners)  as owners,
  (select count(*) from leases where unit_id is null) as leases_missing_unit,
  (select count(*) from leases where property_id is null) as leases_missing_property,
  (select count(*) from leases where tenant_id is null) as leases_missing_tenant;

-- ---- INDEXES (safe) ---------------------------------
create index if not exists idx_units_prop_id          on public.units(property_id);
create index if not exists idx_leases_prop_id         on public.leases(property_id);
create index if not exists idx_leases_unit_id         on public.leases(unit_id);
create index if not exists idx_leases_tenant_id       on public.leases(tenant_id);
create index if not exists idx_units_doorloop_unit_id on public.units(doorloop_unit_id);
create index if not exists idx_leases_doorloop_unit   on public.leases(doorloop_unit_id);
create index if not exists idx_leases_doorloop_lease  on public.leases(doorloop_lease_id);
create index if not exists idx_tenants_dl_id          on public.tenants(doorloop_tenant_id);
create index if not exists idx_properties_dl_id       on public.properties(doorloop_property_id);

-- ---- BACKFILL: leases.unit_id from doorloop match ---
update public.leases l
set unit_id = u.id
from public.units u
where l.unit_id is null
  and l.doorloop_unit_id is not null
  and u.doorloop_unit_id = l.doorloop_unit_id;

-- ---- BACKFILL: leases.property_id via linked unit ---
update public.leases l
set property_id = u.property_id
from public.units u
where l.property_id is null
  and l.unit_id = u.id;

-- ---- BACKFILL: tenant_id by doorloop tenant id ------
update public.leases l
set tenant_id = t.id
from public.tenants t
where l.tenant_id is null
  and l.doorloop_tenant_id is not null
  and t.doorloop_tenant_id = l.doorloop_tenant_id;

-- Fallback (optional): try by unique email if present
update public.leases l
set tenant_id = t.id
from public.tenants t
where l.tenant_id is null
  and l.tenant_email is not null
  and t.email = l.tenant_email;

-- ---- DIAGNOSTICS AFTER ------------------------------
select
  (select count(*) from leases where unit_id is null) as leases_missing_unit_after,
  (select count(*) from leases where property_id is null) as leases_missing_property_after,
  (select count(*) from leases where tenant_id is null) as leases_missing_tenant_after;


This does not drop or overwrite good data. It fills obvious gaps to restore card relationships.

4) Unit & Lease RPCs — keep dual-key + JSON errors only

Ensure these handlers behave like this (diff only if yours differs):

Unit

app.get("/api/rpc/get_unit_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const unit = await fetchOneMulti(supabase, "units", id, ["doorloop_unit_id","doorloop_id"]);
    if (!unit) return res.status(404).json({ error: "unit not found", id });

    const property = unit.property_id
      ? await fetchOneMulti(supabase, "properties", unit.property_id, ["doorloop_property_id","doorloop_id"])
      : null;

    const { data: leaseRows } = await supabase
      .from("leases").select("*")
      .or(`unit_id.eq.${unit.id},doorloop_unit_id.eq.${unit.doorloop_unit_id ?? ""}`)
      .order("start", { ascending: false })
      .limit(1);
    const lease = leaseRows?.[0] ?? null;

    const tenant = lease?.tenant_id
      ? await fetchOneMulti(supabase, "tenants", lease.tenant_id, ["doorloop_tenant_id"])
      : null;

    res.json({ unit, property: property ? { ...property, ...mapAddress(property) } : null, lease, tenant });
  } catch (e:any) {
    console.error("[rpc:get_unit_card]", e);
    res.status(500).json({ error: String(e?.message || e) });
  }
});


Lease

app.get("/api/rpc/get_lease_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const lease = await fetchOneMulti(supabase, "leases", id, ["doorloop_lease_id","doorloop_id"]);
    if (!lease) return res.status(404).json({ error: "lease not found", id });

    const unit = lease.unit_id
      ? await fetchOneMulti(supabase, "units", lease.unit_id, ["doorloop_unit_id","doorloop_id"])
      : null;

    const property = unit?.property_id
      ? await fetchOneMulti(supabase, "properties", unit.property_id, ["doorloop_property_id","doorloop_id"])
      : null;

    const tenant = lease.tenant_id
      ? await fetchOneMulti(supabase, "tenants", lease.tenant_id, ["doorloop_tenant_id"])
      : null;

    res.json({ lease, unit, property: property ? { ...property, ...mapAddress(property)} : null, tenant });
  } catch (e:any) {
    console.error("[rpc:get_lease_card]", e);
    res.status(500).json({ error: String(e?.message || e) });
  }
});


(Owner/Tenant already hardened; leave as is.)

5) Start & Verify

Start dev:

npm run dev


Confirm env matches:

Visit /api/diag/env. The SUPABASE_URL must be the same value you expect. If not, stop and print both values (what you expected vs what’s running).

Verify RPCs (use ids you know exist):

curl -s "http://localhost:8787/api/rpc/get_property_card?id=52" | jq '{kpis:.kpis}'
curl -s "http://localhost:8787/api/rpc/get_unit_card?id=45"      | jq '{unit:.unit?.id, lease:.lease?.id, tenant:.tenant?.id}'
curl -s "http://localhost:8787/api/rpc/get_lease_card?id=1"      | jq '{lease:.lease?.id, unit:.unit?.id, tenant:.tenant?.id}'
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=11"     | jq '{owner:.owner?.id, props:(.properties|length)}'
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=3"     | jq '{tenant:.tenant?.id, active:.activeLease!=null}'


Open in browser:

/card/property/52 shows KPIs and address.

/card/unit/45 no [CONTRACT] Missing required field: unit.

/card/lease/1 shows unit, tenant, property.

/card/owner/11, /card/tenant/3 show data, no contract errors.

If any curl returns 404, do not change code. Print the failing id and stop (that means the record doesn’t exist in this environment).

6) Deliverables (print these)

[EnvLock] line from server logs.

Output of the 5 curl checks (post-backfill).

The “DIAGNOSTICS AFTER” row from the SQL block (counts of remaining null FKs).

End of prompt.