REPLIT FIX PROMPT — Make Vite Own the Page (No More White Screen)
1) Make port 5173 the only web page in dev (Express = API only)

Edit server/index.ts – guard the SPA catch-all so dev does not serve HTML:

// ...existing imports...
import path from "node:path";

const app = express();
const isDev = process.env.NODE_ENV !== "production";

// in dev, DO NOT serve SPA; Vite owns the page
if (!isDev) {
  app.use(express.static(path.resolve("dist")));
  app.get("*", (_req, res) => {
    res.sendFile(path.resolve("dist/index.html"));
  });
}

// keep your API routes (including /api/health, /api/rpc/*) below as-is

2) Make Vite the primary web port on Replit

Create/Update .replit so port 5173 is primary:

run = "npm run dev"

[env]
NODE_ENV = "dev"

[[ports]]
port = 5173
primary = true


(If a [deployment] or other [[ports]] section exists, keep them — just ensure 5173 is marked primary = true.)

3) Lock Vite’s dev server to Replit

Edit vite.config.ts:

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    host: true,        // bind 0.0.0.0 on Replit
    port: 5173,
    strictPort: true,
    proxy: { "/api": "http://localhost:8787" }, // API remains on 8787
    hmr: { clientPort: 443 },                   // Replit HTTPS tunnel
  },
  preview: { host: true, port: 5173 },
});

4) Ensure index.html is compiled by Vite (not Express)

Edit index.html (root). Add Vite’s client shim and keep main module:

<head>
  <!-- ... -->
  <script type="module" src="/@vite/client"></script>
</head>
<body>
  <div id="root"></div>

  <!-- Boot sentinel to prove we reached HTML -->
  <script>
    (function () {
      const r = document.getElementById('root');
      if (r) r.innerHTML = '<div style="padding:16px;font:14px system-ui;color:#bbb">Booting ECC…</div>';
    })();
  </script>

  <!-- Global pre-mount error sink -->
  <script>
    (function () {
      function show(msg) {
        const r = document.getElementById('root');
        if (!r) return;
        r.innerHTML =
          '<div style="padding:24px;margin:24px;border-radius:16px;border:1px solid #7f1d1d;background:#450a0a;color:#fecaca;font:14px system-ui">' +
          '<div style="font-weight:600;font-size:16px;margin-bottom:8px">ECC boot error</div>' +
          '<div style="white-space:pre-wrap;color:#fecaca">' + msg + '</div>' +
          '<div style="margin-top:12px;color:#ddd"><a href="/portfolio/properties" style="color:#93c5fd">Go to Properties</a></div>' +
          '</div>';
      }
      window.addEventListener('error', e => show(String(e.error?.message || e.message || e)));
      window.addEventListener('unhandledrejection', e => show('Unhandled promise rejection: ' + String(e.reason)));
    })();
  </script>

  <!-- Vite module. IMPORTANT: absolute path so Vite rewrites it -->
  <script type="module" src="/src/main.tsx"></script>
</body>


If test.html exists at repo root, move it out (e.g. dev/test.html) so Vite doesn’t treat it as an entry.

5) Export + import safety for the error boundary (prevents silent mount failures)

src/components/EccErrorBoundary.tsx

import React from "react";
type State = { hasError: boolean; msg?: string };

class EccErrorBoundary extends React.Component<React.PropsWithChildren, State> {
  state: State = { hasError: false };
  static getDerivedStateFromError(err: any) { return { hasError: true, msg: String(err?.message || err) }; }
  componentDidCatch(error: any, info: any) { console.error("[EccErrorBoundary]", error, info); (window as any).__ECC_LAST_ERROR__ = { error, info }; }
  render() {
    return this.state.hasError ? (
      <div className="p-8">
        <div className="rounded-2xl border border-red-600/40 bg-red-950/20 p-6">
          <h1 className="text-xl font-semibold text-red-300 mb-2">Something went wrong</h1>
          <p className="text-red-200/80 text-sm mb-4">{this.state.msg || "Unexpected render error."}</p>
          <div className="text-sm text-neutral-400"><a className="underline" href="/portfolio/properties">Go to Properties</a></div>
        </div>
      </div>
    ) : this.props.children;
  }
}
export default EccErrorBoundary;
export { EccErrorBoundary };


src/main.tsx (use default import)

import React from "react";
import ReactDOM from "react-dom/client";
import EccErrorBoundary from "./components/EccErrorBoundary";
// …your providers/router/App remain unchanged…

6) Verify Vite is serving modules (not Express)

After clicking Run:

In the Replit shell, run:

curl -I http://localhost:5173/src/main.tsx


✅ Expect 200 and Content-Type: text/javascript (or application/javascript).
❌ If you see HTML (e.g., <!doctype html>), Express is intercepting; re-check Step 1 & Step 2.

Also run:

curl -I http://localhost:8787/src/main.tsx


✅ Expect 404. The API must not serve the module path in dev.

7) Route safety (optional but recommended)

Ensure / redirects to a real page using Wouter in App.tsx:

import { Route, useLocation } from "wouter";
import { useEffect } from "react";

function HomeRedirect() {
  const [, setLocation] = useLocation();
  useEffect(() => { setLocation("/portfolio/properties"); }, [setLocation]);
  return null;
}

<Route path="/"><HomeRedirect /></Route>

What you’ll see

If index.html is served by Vite and /src/main.tsx returns JS, React will mount and the app shows (no more permanent “Booting ECC…”).

If something inside React crashes, the EccErrorBoundary renders a visible error card (never a blank).

If routing is off, the NotFound/Redirect will land users on a real page.

This is the minimal, production-safe way to end the white screen: Vite owns the page in dev, Express owns only the API, and any failure becomes visible instead of silent.