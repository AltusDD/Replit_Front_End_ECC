You’re seeing that Vite error because a dev-only page (src/dev/AtomsGallery.tsx) is importing CardKit atoms that don’t exist in the repo yet (@/components/cardkit/ActionButton, MiniCard, and it also references the legacy FieldRows). Vite eagerly resolves those imports during build, so the whole app breaks even if you never visit that page.

Let’s fix this in the least-error-prone way so the app boots cleanly and your asset cards render.

Do this (safe, minimal, deterministic)
1) Quarantine the dev gallery so it can’t block the app

Remove any route/imports of AtomsGallery from your app shell (src/App.tsx, src/routes.tsx, or wherever routes are declared). Delete the import and the route entry entirely.

Delete or move the file: src/dev/AtomsGallery.tsx → src/dev/_disabled/AtomsGallery.tsx.

Why: Vite still resolves dynamic imports; if the file references missing atoms it will keep failing. Removing the route + file guarantees the dev page can’t break production.

2) Make sure no other dev overlays/scripts can run

Open index.html and ensure these are not present (remove them if they reappeared):

<script type="module" src="/src/boot/mountEnhancer.tsx"></script>
<script type="module" src="/src/dev/index.ts"></script>


Those were the source of the earlier red “removeChild” overlay crash.

3) Kill any remaining FieldRows usage

We already replaced this in the cards, but the gallery reintroduced it. Search the repo for FieldRows and replace with CardKit’s FieldGroup:

import { FieldGroup } from "@/components/cardkit/FieldGroup";
<FieldGroup label="Email" value={tenant?.email ?? "—"} />

4) Restart and verify routes

Stop / Run.

Visit:

/portfolio/properties (table should load)

/card/property/42

/card/unit/45

/card/lease/1

/card/tenant/1

/card/owner/1

If you still see a “missing required field” banner on any card, that’s a server DTO mapping issue (not a frontend crash). The quick server-side guardrails that must be in place (in server/routes/rpc.ts) are:

Property card: always set property.type (map type | property_type | kind, or return "UNKNOWN" if you want tolerant behavior).

Lease card: always return a lease object; map start | start_date, end | end_date, and convert rent/balance to cents.

Tenant/Owner/Unit cards: always return tenant, owner, unit root objects respectively (wrap the row; don’t send raw rows).

(If Replit already merged that patch, you’re good. If not, ping me and I’ll paste the exact snippets again.)

Optional: keep the dev gallery (only if you really want it)

If you prefer to keep /dev/AtomsGallery, either:

A. Stub the missing atoms so imports resolve:

Create src/components/cardkit/ActionButton.tsx and MiniCard.tsx as minimal components and export both default and named:

// ActionButton.tsx
import React from "react";
type Props = React.ButtonHTMLAttributes<HTMLButtonElement> & { icon?: React.ComponentType<any> };
const ActionButton: React.FC<Props> = ({ icon: Icon, children, ...rest }) => (
  <button className="px-3 py-2 rounded-md border" {...rest}>
    {Icon ? <Icon className="mr-2 inline-block" /> : null}
    {children}
  </button>
);
export default ActionButton;
export { ActionButton };

// MiniCard.tsx
import React from "react";
const MiniCard: React.FC<React.PropsWithChildren<{ title?: string }>> = ({ title, children }) => (
  <div className="rounded-xl border p-4">
    {title ? <div className="text-sm mb-2 opacity-70">{title}</div> : null}
    {children}
  </div>
);
export default MiniCard;
export { MiniCard };


…and change AtomsGallery to use FieldGroup instead of FieldRows.

B. Make the dev gallery route compile-time invisible:
Don’t import it at the top-level. Remove any static imports and only add the route when import.meta.env.DEV and you’ve confirmed the file exists; otherwise omit the route. (Static or dynamic imports still need the file to compile; that’s why removing the route is simpler.)

Why this stops the tail-chasing

The gallery file was the immediate build-stopper. Removing it (or stubbing the atoms) lets the UI mount.

The overlay scripts were the removeChild crash. Keeping them out makes React unmount/mount stable.

Remaining “contract violation” banners are data shape issues; the DTO guards above ensure the UI always receives the required root object and key fields.