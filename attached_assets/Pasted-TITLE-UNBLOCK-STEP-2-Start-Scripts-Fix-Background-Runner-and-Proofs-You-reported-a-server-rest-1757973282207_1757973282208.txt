TITLE: UNBLOCK STEP 2 — Start Scripts Fix, Background Runner, and Proofs

You reported a server restart issue after updating server/routes/rpc.ts. We’re going to (1) fix start scripts, (2) add a simple dev runner, (3) start both servers, and (4) produce the exact proof outputs required.

Do each task in order. Stop after each “PROVE” and paste the raw output. If a step fails, fix it before proceeding.

0) Clean slate (kill any stale procs)

Run these one-liners to clear stale Vite/Node processes:

pkill -f "vite" || true
pkill -f "server/index.ts" || true
sleep 1

1) Fix start scripts (package.json) and .replit

Edit package.json scripts to this exact set (keep other scripts as-is, but replace these):

{
  "scripts": {
    "predev": "node scripts/guardrail-check.mjs",
    "dev": "node scripts/dev-runner.mjs",
    "dev:web": "vite --host 0.0.0.0 --port 5173",
    "dev:api": "cross-env PORT=8787 tsx server/index.ts"
  }
}


If cross-env isn’t in deps, install it (dev dep is fine).

Edit .replit so the run command is simply:

run = "npm run dev"


Leave the ports section alone if it already exposes 5173 (web) and 8787 (api). If not, expose them.

PROVE: Paste the modified scripts block and .replit run line.

2) Add a tiny background runner

Create scripts/dev-runner.mjs with this exact code:

// scripts/dev-runner.mjs
import { spawn } from 'node:child_process';

function run(name, cmd, args) {
  const p = spawn(cmd, args, { stdio: ['ignore', 'pipe', 'pipe'], env: process.env });
  p.stdout.on('data', d => process.stdout.write(`[${name}] ${d}`));
  p.stderr.on('data', d => process.stderr.write(`[${name}] ${d}`));
  p.on('close', code => console.log(`[${name}] exited ${code}`));
  return p;
}

const web = run('WEB', 'npm', ['run', 'dev:web']);
const api = run('API', 'npm', ['run', 'dev:api']);

process.on('SIGINT', () => { web.kill('SIGINT'); api.kill('SIGINT'); process.exit(0); });
process.on('SIGTERM', () => { web.kill('SIGTERM'); api.kill('SIGTERM'); process.exit(0); });


PRO TIP: Make sure file is executable or run via node.

PROVE: Run npm run dev and paste the banner lines showing:

VITE vX.Y.Z ready… with URLs (Local + Network)

[Dev API] Listening on :8787

3) Verify hardened RPCs are actually live

Run the exact proof sequence:

# 1) Discover one ID of each type
IDS=$(curl -s http://localhost:8787/api/rpc/diag/ids)
echo "$IDS" | jq .

PID=$(echo "$IDS" | jq -r '.property')
UID=$(echo "$IDS" | jq -r '.unit')
LID=$(echo "$IDS" | jq -r '.lease')
OID=$(echo "$IDS" | jq -r '.owner')
TID=$(echo "$IDS" | jq -r '.tenant')

# 2) Hit all five endpoints and save JSON
echo "== property ==" && curl -s "http://localhost:8787/api/rpc/get_property_card?id=${PID}" | tee /tmp/prop.json | jq .
echo "== unit =="     && curl -s "http://localhost:8787/api/rpc/get_unit_card?id=${UID}"   | tee /tmp/unit.json | jq .
echo "== lease =="    && curl -s "http://localhost:8787/api/rpc/get_lease_card?id=${LID}"  | tee /tmp/lease.json | jq .
echo "== owner =="    && curl -s "http://localhost:8787/api/rpc/get_owner_card?id=${OID}"  | tee /tmp/owner.json | jq .
echo "== tenant =="   && curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=${TID}" | tee /tmp/tenant.json | jq .

# 3) Assertions (must print *_OK)
echo "ASSERTS:"
jq -e 'has("property") and has("kpis") and (.kpis.units|type=="number") and (.property.type|type=="string")' /tmp/prop.json && echo PROP_OK || echo PROP_FAIL
jq -e 'has("unit") and has("property") and has("lease")' /tmp/unit.json && echo UNIT_OK || echo UNIT_FAIL
jq -e 'has("lease") and has("unit") and has("tenant") and has("property")' /tmp/lease.json && echo LEASE_OK || echo LEASE_FAIL
jq -e 'has("owner") and has("properties") and (.properties|type=="array")' /tmp/owner.json && echo OWNER_OK || echo OWNER_FAIL
jq -e 'has("tenant") and has("leases") and (.leases|type=="array") and has("activeLease")' /tmp/tenant.json && echo TENANT_OK || echo TENANT_FAIL


PROVE: Paste the raw JSON outputs and the five *_OK lines.
If any print *_FAIL, fix server/routes/rpc.ts and re-run.

4) Frontend contract alignment (fast check)

Make sure Zod for Property card accepts our guarantees (string type, numeric KPIs, nested address), e.g. type: z.string().default('UNKNOWN'), and that card pages parse with Schema.parse(json).

Then browse:

/portfolio/properties
/card/property/<PID>
/card/unit/<UID>
/card/lease/<LID>
/card/owner/<OID>
/card/tenant/<TID>


PROVE: Confirm all six routes render with no red overlay and no “Contract violation” text.

Notes (why this fixes today’s blocker)

Your earlier error (“workflow ‘Start application’ doesn’t exist”) is side-stepped by a deterministic npm run dev that uses a tiny Node runner to bring up both processes reliably.

The hardened RPCs already in place will now actually be served; the Property card’s property.type will always be a string (defaults to 'UNKNOWN') and kpis.units will always be a number (defaults to 0).

If the cards still show contract errors after Step 3 passes, that’s frontend schema mismatch — fix the Zod defaults to mirror the exact shapes we just asserted.

Run this now and paste proofs at each gate.