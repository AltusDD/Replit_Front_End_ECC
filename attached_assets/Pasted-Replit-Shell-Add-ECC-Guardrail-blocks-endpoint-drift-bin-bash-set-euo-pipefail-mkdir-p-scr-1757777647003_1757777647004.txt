Replit Shell — Add ECC Guardrail (blocks endpoint drift)
#!/bin/bash
set -euo pipefail

mkdir -p scripts

# 1) Create the guardrail checker (no deps)
cat > scripts/guardrail-check.mjs <<'EOF'
import fs from "fs";
import path from "path";

/**
 * ECC Guardrail: Prevent endpoint drift in card pages.
 * Fails if any file under src/pages/card/** uses:
 *  - direct "/api/" strings
 *  - imports from lib/ecc-api
 *  - calls apiGet(…) in page files
 * Enforces usage of lib/ecc-resolvers.
 */

const ROOT = process.cwd();
const CARD_DIR = path.join(ROOT, "src", "pages", "card");

const violations = [];
const pages = [];

/** Recursively collect files under src/pages/card */
function walk(dir) {
  if (!fs.existsSync(dir)) return;
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const p = path.join(dir, entry.name);
    if (entry.isDirectory()) walk(p);
    else if (/\.(t|j)sx?$/.test(entry.name)) pages.push(p);
  }
}

/** Simple contains matcher with helpful context */
function contains(hay, what) { return hay.indexOf(what) !== -1; }

/** Regex helpers */
const reApiString = /["'`]\/api\//;             // any "/api/" literal
const reImportEccApi = /from\s+["''][^"']*lib\/ecc-api["'']/;
const reApiGetCall = /\bapiGet\s*\(/;
const reImportResolvers = /from\s+["''][^"']*lib\/ecc-resolvers["'']/;

walk(CARD_DIR);

for (const file of pages) {
  const rel = path.relative(ROOT, file);
  const src = fs.readFileSync(file, "utf8");

  // Disallow direct API usage in page files
  if (reApiString.test(src)) {
    violations.push({ file: rel, rule: "NO_DIRECT_API_STRING", msg: 'Do not use "/api/*" in card pages. Use resolvers from lib/ecc-resolvers.' });
  }
  if (reImportEccApi.test(src)) {
    violations.push({ file: rel, rule: "NO_IMPORT_ECC_API", msg: "Do not import lib/ecc-api in card pages. Use lib/ecc-resolvers." });
  }
  if (reApiGetCall.test(src)) {
    violations.push({ file: rel, rule: "NO_DIRECT_apiGet", msg: "Do not call apiGet in card pages. Use lib/ecc-resolvers." });
  }

  // Require resolvers import (so devs follow the pattern)
  if (!reImportResolvers.test(src)) {
    violations.push({ file: rel, rule: "MUST_USE_RESOLVERS", msg: "Card pages must import from lib/ecc-resolvers." });
  }
}

if (violations.length) {
  console.error("\n✗ ECC Guardrail failed. Fix the following before running dev/build:\n");
  for (const v of violations) {
    console.error(`  • ${v.file} :: ${v.rule}\n    ${v.msg}\n`);
  }
  process.exit(1);
}
console.log("✓ ECC Guardrail passed: no endpoint drift in card pages.");
EOF

# 2) Wire it into package.json (run before dev/build)
node - <<'EOF'
const fs = require('fs');
const pkgPath = 'package.json';
if (!fs.existsSync(pkgPath)) {
  console.error('package.json not found'); process.exit(1);
}
const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
pkg.scripts = pkg.scripts || {};

// Add guardrail script
pkg.scripts.guardrail = "node scripts/guardrail-check.mjs";

// Prepend guardrail to dev/build (idempotent)
const withGuard = (cmd, fallback) => {
  const cur = pkg.scripts[cmd] || fallback;
  if (cur.includes("npm run guardrail")) return cur; // already wired
  return `npm run guardrail && ${cur}`;
};
pkg.scripts.dev = withGuard("dev", "vite");
pkg.scripts.build = withGuard("build", "vite build");

fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2));
console.log("✓ package.json updated: guardrail attached to dev/build");
EOF

echo "Done. Now run: npm run dev"

What this enforces (from now on)

If someone edits any src/pages/card/** file and:

types "/api/" anywhere → ❌ dev/build fails

imports lib/ecc-api → ❌ fail

calls apiGet(...) → ❌ fail

forgets to import lib/ecc-resolvers → ❌ fail

They’ll get a clear error listing the file, the rule, and how to fix it.

Result: Pages can only talk to data through our resolvers. No guessing. No drift.