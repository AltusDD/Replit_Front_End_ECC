FINAL FIX PACK: “Cards Look Right or It Didn’t Happen”

Run these steps exactly, and STOP after each proof. Don’t claim success until the proof command output is pasted.

Step 0 — Ensure alias + toolchain are correct

vite.config.ts

Confirm alias is set:

resolve: {
  alias: { "@": fileURLToPath(new URL("./src", import.meta.url)) }
}


tsconfig.json

Confirm:

"baseUrl": ".",
"paths": { "@/*": ["src/*"] }


postcss.config.cjs must have:

module.exports = { plugins: { tailwindcss: {}, autoprefixer: {} } }


tailwind.config.(ts|js) must include:

content: ["./index.html","./src/**/*.{ts,tsx,js,jsx}"]


PROOF (paste):

The exact alias object from vite.config.ts

The exact content array from tailwind.config

Step 1 — Restore the global stylesheet pipeline

Create a single aggregator stylesheet and import it first in the app.

Create/overwrite: src/styles/index.css

/* Tailwind layers */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* ECC theme bundle (order matters: tokens → theme → brand → comps) */
@import "./tokens.css";
@import "./theme.css";
@import "./ecc.css";
@import "./genesis.css";

/* Safety defaults if brand files are sparse */
:root { --ecc-bg: #0b0b0d; --ecc-fg: #e8e8ea; }
html,body,#root { height: 100%; }
body { background: var(--ecc-bg); color: var(--ecc-fg); }


Edit: src/main.tsx (top of file, before any components)

import "@/styles/index.css";  // <— must be FIRST


Remove any stray <link> or extra <script> tags from index.html (keep only the Vite entry).

PROOF (run and paste):

# Start servers, then show the first 20 lines of served HTML and confirm CSS is injected
sleep 6 && curl -s http://localhost:5173 | head -20
# Confirm the aggregated CSS is being served by Vite (200 OK expected)
curl -s -I http://localhost:5173/src/styles/index.css

Step 2 — Re-export CardKit atoms exactly how pages import them

Some pages import named and some default. Provide both.

Create/overwrite:
src/components/cardkit/KPI.tsx

import * as React from "react";

type KPIProps = React.HTMLAttributes<HTMLDivElement> & {
  label: string;
  value?: React.ReactNode;
  "data-testid"?: string;
  testid?: string; // legacy
};

const KPIBase: React.FC<KPIProps> = ({ label, value, testid, ...rest }) => {
  const dataTestid = rest["data-testid"] ?? testid;
  const { className, ...dom } = rest;
  return (
    <div className={`kpi ${className ?? ""}`} {...dom} data-testid={dataTestid}>
      <div className="kpi-label">{label}</div>
      <div className="kpi-value">{value ?? "—"}</div>
    </div>
  );
};

export default KPIBase;
export const KPI = KPIBase;
export const KPIRow: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ className, ...props }) => (
  <div className={`kpi-row grid grid-cols-4 gap-4 ${className ?? ""}`} {...props} />
);


src/components/cardkit/CardPanel.tsx

import * as React from "react";
const CardPanelBase: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ className, ...props }) => (
  <div className={`card-panel p-4 rounded-xl border border-white/10 ${className ?? ""}`} {...props} />
);
export default CardPanelBase;
export const CardPanel = CardPanelBase;


src/components/cardkit/FieldGroup.tsx

import * as React from "react";
type FGProps = { label: string; value?: React.ReactNode } & React.HTMLAttributes<HTMLDivElement>;
const FGBase: React.FC<FGProps> = ({ label, value, className, ...rest }) => (
  <div className={`field-group flex gap-2 py-1 ${className ?? ""}`} {...rest}>
    <div className="text-xs opacity-70 w-40">{label}</div>
    <div className="text-sm">{value ?? "—"}</div>
  </div>
);
export default FGBase;
export const FieldGroup = FGBase;


src/components/cardkit/RightRailPanel.tsx

import * as React from "react";
const RRPBase: React.FC<React.HTMLAttributes<HTMLDivElement>> = ({ className, ...props }) => (
  <aside className={`right-rail w-[320px] shrink-0 ${className ?? ""}`} {...props} />
);
export default RRPBase;
export const RightRailPanel = RRPBase;


PROOF (paste):

The last 5 lines of each of those four files showing default and named exports

Then run:

grep -R "from \"@/components/cardkit/KPI\"" -n src | wc -l


(>0 confirms imports are resolvable)

Step 3 — Make hero/overview tolerant and visible

Replace hard requireField/requireArray throws with safe reads in the hero blocks so we render what we have.

Property Hero: src/pages/card/property/HeroBlock.tsx

Replace any requireField(...) with safe helpers:

const safe = <T,>(v: T | null | undefined, d: T) => (v ?? d);
const n = (v?: number | null) => (typeof v === "number" ? v : undefined);

<KPIRow data-testid="property-kpis">
  <KPI label="Units" value={n(data.kpis?.units)?.toLocaleString() ?? "—"} />
  <KPI label="Active Leases" value={n(data.kpis?.activeLeases)?.toLocaleString() ?? "—"} />
  <KPI label="Occupancy" value={
    typeof data.kpis?.occupancyPct === "number"
      ? `${Math.round(data.kpis.occupancyPct)}%`
      : "—"
  } />
  <KPI label="Avg Rent" value={
    typeof data.kpis?.avgRentCents === "number"
      ? `$${Math.round(data.kpis.avgRentCents / 100).toLocaleString()}`
      : "—"
  } />
</KPIRow>


Property Overview: src/pages/card/property/Overview.tsx

If you previously passed an array to <FieldGroup items=[...]/>, remove that. Render each <FieldGroup> explicitly:

<CardPanel>
  <h3>Overview</h3>
  <FieldGroup label="Type" value={data.property?.type ?? "—"} />
  <FieldGroup label="Owner" value={data.owner?.display_name ?? "—"} />
  <FieldGroup label="Address" value={[
    data.property?.address?.line1,
    data.property?.address?.city,
    data.property?.address?.state,
    data.property?.address?.zip
  ].filter(Boolean).join(", ") || "—"} />
  <FieldGroup label="Units" value={n(data.kpis?.units) ?? "—"} />
  <FieldGroup label="Active Leases" value={n(data.kpis?.activeLeases) ?? "—"} />
  <FieldGroup label="Class" value={data.property?.property_class ?? "—"} />
  <FieldGroup label="Status" value={data.property?.status ?? "—"} />
  <FieldGroup label="DoorLoop ID" value={data.property?.doorloop_id ?? "—"} />
</CardPanel>


Repeat the same “safe rendering” pattern for Unit, Lease, Tenant, Owner hero/overview files:

Use FieldGroup per field (no array prop).

Never throw during render.

For arrays that may be missing (e.g., leases), use (data.leases ?? []).

PROOF (paste):

One snippet from Property Hero showing the new KPI usages

One snippet from Property Overview showing individual FieldGroup components

Step 4 — Verify theme + layout are actually applied

PROOF (run and paste):

# 1) card page HTML boots
curl -s http://localhost:5173/card/property/57 | head -20

# 2) CSS actually served
curl -s -I http://localhost:5173/src/styles/index.css

# 3) API still healthy
curl -s http://localhost:8787/api/health


Then visit in browser:

/card/property/57, /card/unit/48, /card/lease/23, /card/tenant/3, /card/owner/6
You should see:

Card header/crumbs present

Right rail present (if used)

KPIs in a neat row (not raw text)

Typography/colors following your dark theme

Step 5 — Data sanity pings (no empty tables)

If portfolio tables show “rows: 0” intermittently because of StrictMode/HMR, keep the cancel-safe fetch you added, and increase staleTime to reduce churn. But first, confirm the five hardened RPCs still return data:

PROOF (run and paste):

curl -s "http://localhost:8787/api/rpc/get_property_card?id=57" | jq '.kpis'
curl -s "http://localhost:8787/api/rpc/get_unit_card?id=48" | jq '.unit.id'
curl -s "http://localhost:8787/api/rpc/get_lease_card?id=23" | jq '.lease.id,.tenant,.unit'
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=3" | jq '.tenant.display_name,.activeLease'
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=6" | jq '.owner.display_name,.properties|length'


You should see numeric IDs/strings and arrays lengths (not undefined), with avgRentCents either a number or null.

Why this fixes your screenshots

The pages rendering as plain text with huge gaps means global CSS wasn’t loading; Step 1 attaches Tailwind and your ECC theme bundle in the right order and ensures it’s imported before anything else.

“Components missing” happens when CardKit defaults/named exports don’t match page imports; Step 2 exports both forms from KPI/CardPanel/FieldGroup/RightRailPanel and forwards data-testid, fixing the earlier runtime contract checks.

“Values missing” with no crash means render code was throwing on optional fields or trying to render arrays-as-props; Step 3 replaces runtime throws with safe reads and renders each FieldGroup explicitly.

The hardened RPCs you already shipped remain the source of truth; Step 5 proves they still deliver normalized shapes.

Drop this into Replit, have it execute step-by-step, and paste each proof. Once the CSS + CardKit exports + safe hero/overview are in place, the cards should look like the designed CardKit pages (right rail, KPIs, spacing, dark theme) with the data that’s actually in the DB.