1) One QueryClient for the whole app + silence AbortError

Create src/lib/queryClient.ts:

import { QueryClient, setLogger } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60_000,        // 1m: reduces churn
      gcTime: 5 * 60_000,
      retry: 1,
      refetchOnMount: false,
      refetchOnReconnect: false,
      refetchOnWindowFocus: false,
      throwOnError: false,
      networkMode: "online",
      placeholderData: (prev) => prev,   // keep last data during refetch
      keepPreviousData: true,
    },
  },
});

// Drop noisy AbortError logs from HMR/StrictMode
setLogger({
  log: (...a) => console.log(...a),
  warn: (...a) => console.warn(...a),
  error: (err) => {
    const msg = String((err as any)?.message ?? err ?? "");
    if (/AbortError/i.test(msg) || /aborted/i.test(msg)) return;
    console.error(err);
  },
});

2) Use that client and stop double-mount in dev

Edit src/main.tsx (or wherever you create the app root):

import React from "react";
import ReactDOM from "react-dom/client";
import { QueryClientProvider } from "@tanstack/react-query";
import { queryClient } from "@/lib/queryClient";
import "@/styles/index.css";
import EccErrorBoundary from "@/components/EccErrorBoundary";
import App from "./App";

const Mode: React.ComponentType<any> = import.meta.env.DEV ? React.Fragment : React.StrictMode;

ReactDOM.createRoot(document.getElementById("root")!).render(
  <Mode>
    <EccErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <App />
      </QueryClientProvider>
    </EccErrorBoundary>
  </Mode>
);

3) Make fetch cancel-safe (single helper)

Ensure src/lib/http.ts looks like this:

export function isAbortError(e: unknown) {
  return (
    (e instanceof DOMException && e.name === "AbortError") ||
    /AbortError|aborted/i.test(String((e as any)?.message ?? e))
  );
}

export async function fetchJSON<T>(input: RequestInfo, init?: RequestInit & { signal?: AbortSignal }) {
  try {
    const res = await fetch(input, init);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return (await res.json()) as T;
  } catch (err) {
    if (isAbortError(err) || init?.signal?.aborted) {
      // never reject — avoid error boundaries/log spam during HMR
      return new Promise<T>(() => {});
    }
    throw err;
  }
}


Use this helper everywhere (portfolio hooks + card resolvers).

4) Stop the “rows: 0 → rows: 185” flash

Example: properties hook (apply the same pattern to units/leases/tenants/owners).

// src/features/portfolio/useAllProperties.ts
import { useQuery } from "@tanstack/react-query";
import { fetchJSON } from "@/lib/http";
import { mapProperty } from "@/pages/portfolio/columns";

export function useAllProperties() {
  return useQuery({
    queryKey: ["portfolio","properties"],
    queryFn: ({ signal }) => fetchJSON<any[]>("/api/portfolio/properties", { signal }),
    select: (rows) => (rows ?? []).map(mapProperty),
    // defaults for placeholderData/keepPreviousData come from QueryClient (step 1)
  });
}


In your DataTable consumer, show skeleton based on query flags rather than empty length:

const { data: rows = [], isLoading, isFetching } = useAllProperties();
<DataTable rows={rows} loading={isLoading || (isFetching && rows.length === 0)} ... />

5) Navbar “affected” after HMR? lock in stylesheet order

Ensure exactly one import of your bundle and that it’s first:

// src/main.tsx – keep this at the very top before anything else
import "@/styles/index.css";


And keep the order inside index.css (tokens → theme → ecc → genesis). If you added overrides during troubleshooting, move custom rules below imports so they win:

/* bottom of src/styles/index.css */
.sidebar { background:#0b0b0d; color:#e8e8ea; } /* example safe override if needed */

What this changes (and why your logs will calm down)

AbortError spam is filtered at two levels (fetch helper + React Query logger). Those are benign cancellations from HMR/StrictMode; they won’t bubble into error boundaries or console anymore.

Lists keep their previous data while refetching, so you won’t see rows: 0 flashes or nav glitches as the table remounts.

Dev uses Fragment instead of StrictMode, eliminating the double-mount that triggers extra cancels. Prod stays strict.

CSS loads deterministically; the sidebar shouldn’t “lose” theme during hot updates.