ECC – Full UI Influence Audit & Debug Overlay (Genesis Grade)

Operating Mode: Debugging Specialist + UI-Nav Engineer + Consistency Enforcer
Repo: Empire Command Center (ECC) — React + Vite
Goal: Find why /card/* pages show “Property Not Found” / “landing overlay” and why visible changes don’t show. Produce a machine-readable audit and a live UI Inspector overlay toggleable with ?debug=1.

Guardrails (do these, nothing else)

Router: use existing router (don’t add react-router if not present).

Design: keep Altus dark theme; do not import a new UI framework.

Scope: only touch files listed below; back up any file you fully replace as *.bak.

Data: never hardcode KPIs or IDs; pull flags from /api/config/integrations.

Idempotent: all shell patches must be re-runnable.

Files to create/modify

tools/ecc_ui_audit.sh, tools/ecc_ui_verify.sh (shell)

src/dev/UiInspector.tsx (debug overlay panel)

src/dev/index.ts (lazy loader for inspector)

src/boot/mountEnhancer.tsx (read-only unless missing mount)

public/index.html (inject <script type="module"> boot tag if missing)

src/styles/dev-inspector.css (scoped CSS for overlay)

(Optional tiny route) src/pages/dev/InspectorPage.tsx mounted at /dev/inspect

What to output (deliverables)

/public/__audit/ui_audit.json — JSON with:

routes discovered, enhancers mounted/unmounted, feature-flag snapshot, secrets presence (boolean only), CSS layers applied to the current card, any elements with position: fixed/z-index > 1000, network calls from the card route with status codes, and RBAC gates encountered.

Screenshots of:

/card/owner/:id, /card/property/:id, /card/unit/:id, /card/lease/:id, /card/tenant/:id with the UI Inspector open.

Console paste of tools/ecc_ui_audit.sh output.

JSON from GET /api/config/integrations.

CHANGESET (step-by-step)
1) Add the UI Inspector overlay (toggle: ?debug=1)

Create src/dev/UiInspector.tsx that:

Fetches /api/config/integrations and shows booleans (m365, dropbox, doorloop, etc.).

Hooks window.fetch and XMLHttpRequest to log network calls (method, URL, status) during the current page.

Reads the current route and the mounted component names:

For mounted names, wrap the card shell in an ErrorBoundary that captures the component stack via componentStack and expose it in the overlay.

Scans the DOM for potential overlays:

Any element with computed position in (fixed,sticky) or z-index >= 1000, list selector, size, and whether it covers .card-shell.

Lists CSS files that apply to the page (iterate document.styleSheets and collect rules containing .card-shell, .kpi-row, .left-rail, .right-rail, .panel, owner-card, property-card, etc.).

Shows RBAC & feature gates encountered:

Scan rendered DOM for [data-role-required] and [data-feature] attributes; also expose any local store state if available (safe—no secrets).

Writes a merged object to window.__ECC_UI_AUDIT__ and POSTs it to /__audit (we’ll polyfill to write a file under public/__audit in dev).

Create src/dev/index.ts that conditionally mounts the inspector if location.search contains debug=1.

2) Ensure the bootloader runs

If public/index.html lacks a <script type="module"> that imports the app entry (and src/boot/mountEnhancer.tsx is not guaranteed to run), inject a tiny module that imports the normal entry and src/dev/index.ts.

3) Add a dev route (optional but helpful)

/dev/inspect renders just the inspector panel and an iframe of the current page so we can audit any route without navigating.

4) Add Shell audit commands (enumerate everything)

Create tools/ecc_ui_audit.sh that prints and writes to public/__audit/ui_audit.json:

Node & package manager; .replit run command.

Verify public/index.html has <script type="module">.

Enhancer mount check: list all *Enhancer.tsx under src/features/** and compare to imports/usage in src/boot/mountEnhancer.tsx.

Route inventory: grep /card/(owner|property|unit|lease|tenant) and list file owning each route.

Feature flags: curl /api/config/integrations → public/__audit/integrations.json.

Secrets presence (booleans) for common keys (don’t print values).

Static analysis: ripgrep for display: none, position: fixed, z-index across src/styles and feature CSS.

API smoke: curl the entity endpoints used by the cards (if known), else log “unknown”.

Git discipline: branch name, uncommitted diffs, last commit hash.

Create tools/ecc_ui_verify.sh that re-runs the audit and prints a short ✅/❌ summary.

SHELL PATCH (run idempotently)
#!/bin/bash
set -e

mkdir -p tools public/__audit src/dev src/pages/dev src/styles

# --- add dev inspector css ---
cat > src/styles/dev-inspector.css <<'CSS'
.ecc-inspector{position:fixed;right:16px;bottom:16px;z-index:99999;background:var(--panel, #141414);color:var(--fg,#fff);border:1px solid var(--border-1,#2c2c2c);border-radius:12px;width:420px;max-height:70vh;overflow:auto;box-shadow:0 10px 30px rgba(0,0,0,.5);font:13px/1.4 system-ui,sans-serif}
.ecc-inspector header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid var(--border-1,#2c2c2c)}
.ecc-inspector .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:#222;margin-left:6px}
.ecc-inspector pre{white-space:pre-wrap;word-break:break-word;background:transparent;margin:0;padding:8px 12px}
CSS

# --- add dev inspector loader ---
cat > src/dev/index.ts <<'TS'
export async function enableInspector() {
  const url = new URL(location.href);
  if (url.searchParams.get('debug') !== '1') return;
  const { UiInspector } = await import('./UiInspector');
  // mount immediately after app root
  const root = document.createElement('div');
  root.id = 'ecc-ui-inspector-root';
  document.body.appendChild(root);
  UiInspector.mount('#ecc-ui-inspector-root');
}
enableInspector();
TS

# --- add dev inspector component ---
cat > src/dev/UiInspector.tsx <<'TSX'
import './..//styles/dev-inspector.css';

function h(tag:string, props:any={}, ...children:any[]) {
  const el = document.createElement(tag);
  Object.entries(props||{}).forEach(([k,v])=>{ if(k==='className') el.setAttribute('class', String(v)); else if(k.startsWith('on')) (el as any)[k.toLowerCase()] = v; else el.setAttribute(k, String(v)); });
  children.flat().forEach((c:any)=> el.appendChild(typeof c==='string'?document.createTextNode(c):c));
  return el;
}

function collectOverlays(){
  const els = Array.from(document.querySelectorAll<HTMLElement>('body *'));
  const suspects:any[]=[];
  for (const el of els) {
    const cs = getComputedStyle(el);
    const zi = parseInt(cs.zIndex || '0', 10);
    if ((cs.position==='fixed' || cs.position==='sticky' || zi>=1000)) {
      const rect = el.getBoundingClientRect();
      suspects.push({selector: getSelector(el), position: cs.position, zIndex: zi||0, w: Math.round(rect.width), h: Math.round(rect.height)});
    }
  }
  return suspects;
}
function getSelector(el:Element){
  if (el.id) return '#'+el.id;
  const classes = (el.getAttribute('class')||'').split(/\s+/).filter(Boolean).slice(0,3).map(c=>'.'+c).join('');
  return el.tagName.toLowerCase()+classes;
}

async function getFlags(){
  try{ const r = await fetch('/api/config/integrations'); return await r.json(); }catch{ return {error:'flags-unavailable'}; }
}

function scanCSS(){
  const matches:string[]=[];
  const needles = ['.card-shell','.left-rail','.right-rail','.kpi-row','owner-card','property-card','unit-card','lease-card','tenant-card'];
  for(const ss of Array.from(document.styleSheets)){
    try{
      const rules = (ss as CSSStyleSheet).cssRules || [];
      for(const r of Array.from(rules)){
        const txt = r.cssText || '';
        if(needles.some(n => txt.includes(n))) matches.push((ss as any).href||'inline');
      }
    }catch{/* cross-origin or unreadable */}
  }
  return Array.from(new Set(matches));
}

function networkTap(){
  const calls:any[]=[];
  const origFetch = window.fetch;
  (window as any).fetch = async (...args:any[]) => {
    const startedAt = performance.now();
    const res = await origFetch(...args as any);
    calls.push({url: String(args[0]), status: res.status, ms: Math.round(performance.now()-startedAt)});
    return res;
  };
  // XHR tap
  const origOpen = XMLHttpRequest.prototype.open;
  const origSend = XMLHttpRequest.prototype.send;
  (XMLHttpRequest.prototype as any).open = function(method:string,url:string){ (this as any).__ecc = {method,url,ts:performance.now()}; return origOpen.apply(this, arguments as any); };
  (XMLHttpRequest.prototype as any).send = function(){ const xhr=this as any; const meta=xhr.__ecc||{}; xhr.addEventListener('loadend',()=>{ calls.push({url:meta.url,status:xhr.status,ms:Math.round(performance.now()-meta.ts)}); }); return origSend.apply(this, arguments as any); };
  return calls;
}

export const UiInspector = {
  async mount(selector:string){
    const calls = networkTap();
    const panel = h('div',{className:'ecc-inspector'});
    const header = h('header',{}, h('strong',{},'ECC UI Inspector'), h('span',{className:'badge'},'debug=1'));
    const body = h('div');
    panel.appendChild(header); panel.appendChild(body);
    document.querySelector(selector)?.appendChild(panel);

    const flags = await getFlags();
    const overlays = collectOverlays();
    const styles = scanCSS();
    const route = location.pathname + location.search;

    const audit = { route, flags, overlays, styles, calls, timestamp: new Date().toISOString() };
    (window as any).__ECC_UI_AUDIT__ = audit;

    body.appendChild(h('pre',{}, JSON.stringify(audit,null,2)));
    try{
      await fetch('/__audit', {method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(audit)});
    }catch{/* dev only */}
  }
}
TSX

# --- ensure public index boot exists; if missing, inject tiny module import ---
HTML_FILE=""
if [ -f public/index.html ]; then HTML_FILE=public/index.html; elif [ -f index.html ]; then HTML_FILE=index.html; fi
if [ -n "$HTML_FILE" ] && ! grep -q 'type="module"' "$HTML_FILE"; then
  cp "$HTML_FILE" "$HTML_FILE.bak"
  cat >> "$HTML_FILE" <<'HTML'
<script type="module">
  import '/src/main.tsx';
  import '/src/dev/index.ts';
</script>
HTML
fi

# --- write audit script ---
cat > tools/ecc_ui_audit.sh <<'AUD'
#!/bin/bash
set -e
echo "[ECC] UI Influence Audit starting…"
PM="npm"; [ -f pnpm-lock.yaml ] && PM="pnpm"; [ -f yarn.lock ] && PM="yarn"
echo "Node: $(node -v)  | PM: $PM"
echo ".replit run: $(grep -E '^run' -n .replit 2>/dev/null || echo 'N/A')"
mkdir -p public/__audit

# Bootloader check
if grep -q 'type="module"' public/index.html 2>/dev/null; then BOOT="present"; else BOOT="missing"; fi

# Enhancer mount scan
ENH=$(rg -n --glob 'src/features/**/**/*Enhancer.tsx' -l | sed 's#^src/##' | sort || true)
MOUNT=$(rg -n 'Enhancer' src/boot/mountEnhancer.tsx 2>/dev/null || true)

# Routes
ROUTES=$(rg -n '/card/(owner|property|unit|lease|tenant)' src | sed 's#^src/##' | sort || true)

# Feature flags
FLAGS=$(curl -sS http://localhost:3000/api/config/integrations || echo '{}')

# Secrets (booleans only)
check() { [ -n "${!1}" ] && echo "\"$1\":true" || echo "\"$1\":false"; }
SECRETS="{ $(check DOORLOOP_API_KEY), $(check GOOGLE_MAPS_API_KEY), $(check M365_CLIENT_ID), $(check DROPBOX_ACCESS_TOKEN), $(check ADMIN_SYNC_TOKEN) }"

# CSS z-index scan
ZSCAN=$(rg -n 'z-index\s*:\s*([1-9][0-9]{2,})' src/styles src/features 2>/dev/null || true)

# Git
GIT="{\"branch\":\"$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'N/A')\",\"last\":\"$(git rev-parse --short HEAD 2>/dev/null || echo 'N/A')\",\"dirty\":\"$(git status --porcelain | wc -l | tr -d ' ')\"}"

# Compose JSON
cat > public/__audit/ui_audit.json <<JSON
{
  "bootloader":"$BOOT",
  "enhancers":{"all":[${ENH:+$(printf '"%s",' $ENH | sed 's/,$//')}], "mountFileHas":"${MOUNT//"/\\"}"},
  "routes":[${ROUTES:+$(printf '"%s",' $ROUTES | sed 's/,$//')}],
  "flags": $FLAGS,
  "secrets": $SECRETS,
  "zindex_hits":"${ZSCAN//"/\\"}",
  "git": $GIT,
  "timestamp":"$(date -Iseconds)"
}
JSON

echo "[ECC] Audit written to public/__audit/ui_audit.json"
AUD
chmod +x tools/ecc_ui_audit.sh

# --- write verify script ---
cat > tools/ecc_ui_verify.sh <<'VER'
#!/bin/bash
set -e
bash tools/ecc_ui_audit.sh
jq '.bootloader, .routes | length, .flags, .secrets, .git' public/__audit/ui_audit.json || cat public/__audit/ui_audit.json
echo "[ECC] Verify complete."
VER
chmod +x tools/ecc_ui_verify.sh

echo "[ECC] Running verify…"
bash tools/ecc_ui_verify.sh

VERIFICATION CHECKLIST (Replit must confirm)

App restarts cleanly; visiting any /card/* route with ?debug=1 shows the ECC UI Inspector panel.

public/__audit/ui_audit.json exists and includes:

"bootloader":"present"

non-empty routes[]

flags JSON from /api/config/integrations

secrets booleans

zindex_hits (if any big overlays exist)

Screenshots of each card with the inspector open.

Console paste of bash tools/ecc_ui_verify.sh.

Plain GET /api/config/integrations JSON.

Known culprits to call out (have the audit highlight these)

Un-mounted enhancers (listed but never imported in mountEnhancer.tsx).

Missing bootloader (no <script type="module">, overlay never mounts).

Feature-flag off (m365/dropbox/doorloop false → parts of UI hidden).

Overlay z-index (a full-page panel with z-index >= 1000 covering the card).

Empty API data / 404 (cards render fallback like “Property Not Found”).

Wrong route file (cards implemented under /dashboard instead of /card/*).

CSS not imported (card appears “unchanged” because the stylesheet never loads).

Hand-off back to me

Please return:

public/__audit/ui_audit.json

/api/config/integrations JSON

Screenshots of all five cards with the Inspector open

Summary: which culprits were detected (from the list above)