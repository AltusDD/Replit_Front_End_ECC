1) Make / always land somewhere real (no reloads)

Edit src/App.tsx (or wherever your routes live). Add a client-side redirect and a visible NotFound.

// src/App.tsx
import React, { useEffect } from "react";
import { Route, useLocation } from "wouter";

// OPTIONAL: import your real Dashboard if it exists
// import Dashboard from "@/pages/dashboard"; 

function HomeRedirect() {
  const [, setLocation] = useLocation();
  useEffect(() => {
    // pick a known-good landing route that exists in this app
    setLocation("/portfolio/properties");
  }, [setLocation]);
  return null;
}

function NotFound() {
  return (
    <div className="p-8 text-center">
      <h1 className="text-2xl font-semibold mb-2">Route not found</h1>
      <p className="text-neutral-400 mb-6">
        The page you requested doesn’t exist. Try a known route:
      </p>
      <div className="flex gap-3 justify-center">
        <a className="px-3 py-2 rounded-xl border border-neutral-700" href="/portfolio/properties">Properties</a>
        <a className="px-3 py-2 rounded-xl border border-neutral-700" href="/portfolio/units">Units</a>
        <a className="px-3 py-2 rounded-xl border border-neutral-700" href="/portfolio/leases">Leases</a>
      </div>
    </div>
  );
}

export default function App() {
  return (
    <>
      {/* Your header/sidebar layout stays the same */}
      {/* ROUTES */}
      <Route path="/"><HomeRedirect /></Route>

      {/* If you actually have a dashboard, keep it; else it will never match */}
      {/* <Route path="/dashboard"><Dashboard /></Route> */}

      {/* portfolio + card routes already defined elsewhere */}

      {/* Catch-all fallback: MUST be last */}
      <Route><NotFound /></Route>
    </>
  );
}


Why: If /dashboard doesn’t exist (very common during refactors), Wouter renders nothing. This ensures / goes to /portfolio/properties (or any route you know exists), and unmatched paths show a friendly screen instead of white.

2) Make the ErrorBoundary display a visible fallback (not an invisible div)

Edit src/components/ErrorBoundary.tsx (or your EccErrorBoundary component) so failures are obvious:

import React from "react";

type State = { hasError: boolean; msg?: string };

export default class EccErrorBoundary extends React.Component<
  React.PropsWithChildren, State
> {
  state: State = { hasError: false };

  static getDerivedStateFromError(err: any) {
    return { hasError: true, msg: String(err?.message || err) };
  }

  componentDidCatch(error: any, info: any) {
    // keep console error visible during dev
    // eslint-disable-next-line no-console
    console.error("[EccErrorBoundary]", error, info);
    (window as any).__ECC_LAST_ERROR__ = { error, info };
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="p-8">
          <div className="rounded-2xl border border-red-600/40 bg-red-950/20 p-6">
            <h1 className="text-xl font-semibold text-red-300 mb-2">
              Something went wrong
            </h1>
            <p className="text-red-200/80 text-sm mb-4">
              {this.state.msg || "An unexpected error occurred while rendering this page."}
            </p>
            <div className="text-sm text-neutral-400">
              Try a known-good route:{" "}
              <a className="underline" href="/portfolio/properties">/portfolio/properties</a>
            </div>
          </div>
        </div>
      );
    }
    return this.props.children;
  }
}


Why: If a component throws during mount, you’ll see a clear error card instead of a blank screen.

3) Ensure CardKit named imports don’t crash

You already fixed CardPanel. Do the same pattern for any CardKit primitive you created (so both default and named imports work). Double-check these files export both:

// src/components/cardkit/CardPanel.tsx
export default CardPanel;
export { CardPanel };

// src/components/cardkit/FieldGroup.tsx
export default FieldGroup;
export { FieldGroup };

// src/components/cardkit/RightRailPanel.tsx
export default RightRailPanel;
export { RightRailPanel };

// If you created Skeleton/PrefetchLink similarly:
export default Skeleton; export { Skeleton };
export default PrefetchLink; export { PrefetchLink };


If any page imports { Something } but the file only had export default, Vite won’t always show a red overlay; the render can just stall. This neutralizes that class of error.

4) Quick reload + known-good routes

Click Run (keep it open).

Hard refresh the preview (or open the Local URL).

Visit a known route directly:

/portfolio/properties (lists)

/card/property/<existing-id>

/card/unit/<existing-id>

If you added the diag route earlier, grab real IDs from it:

curl -s http://localhost:8787/api/rpc/diag/ids

If you still see white, your ErrorBoundary will now print a visible error box. Copy just the first line of that error message (the message in the red card), and I’ll give you a one-file micro-patch targeted to that exact failure.

Why this solves it

When /dashboard doesn’t exist, Wouter renders nothing — the new HomeRedirect guarantees a valid landing page.

When any render throws, the error was likely being caught silently — the visible ErrorBoundary makes it obvious.

When a CardKit component is imported by name but only exported as default, some bundler paths don’t throw visibly — dual exports make those pages safe.

This is the minimal, contract-safe way to kill the “blank white page” class of failures without touching your backend or card logic.