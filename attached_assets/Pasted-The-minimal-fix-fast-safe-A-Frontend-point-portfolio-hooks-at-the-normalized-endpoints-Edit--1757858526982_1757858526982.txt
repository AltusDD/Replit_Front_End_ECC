The minimal fix (fast + safe)
A) Frontend: point portfolio hooks at the normalized endpoints

Edit: src/lib/ecc-resolvers.ts
Replace the collection hooks with this:

/* --------- Collection hooks (for portfolio pages) --------- */
export function useAllProperties() {
  return useQuery({
    queryKey: ["portfolio","properties"],
    queryFn: async ({signal}) => (await fetch("/api/portfolio/properties",{signal})).json()
  });
}
export function useAllUnits() {
  return useQuery({
    queryKey: ["portfolio","units"],
    queryFn: async ({signal}) => (await fetch("/api/portfolio/units",{signal})).json()
  });
}
export function useAllLeases() {
  return useQuery({
    queryKey: ["portfolio","leases"],
    queryFn: async ({signal}) => (await fetch("/api/portfolio/leases",{signal})).json()
  });
}
export function useAllTenants() {
  return useQuery({
    queryKey: ["portfolio","tenants"],
    queryFn: async ({signal}) => (await fetch("/api/portfolio/tenants",{signal})).json()
  });
}
export function useAllOwners() {
  return useQuery({
    queryKey: ["portfolio","owners"],
    queryFn: async ({signal}) => (await fetch("/api/portfolio/owners",{signal})).json()
  });
}


Optional belt-and-suspenders: in src/pages/portfolio/columns.tsx, add fallbacks in mapProperty so it reads address_city/address_state/address_zip if city/state/zip are missing. That way even if someone points back to /api/entities/* by mistake, the table still renders.

export function mapProperty(src:any): PropertyRow {
  return {
    id: String(src.id),
    name: src.name || "—",
    type: src.type || "—",
    class: src.class || "—",
    state: src.state ?? src.address_state ?? "—",
    city:  src.city  ?? src.address_city  ?? "—",
    zip:   src.zip   ?? src.address_zip   ?? "—",
    units: Number(src.units ?? 0),
    occPct: Number(src.occPct ?? 0),
    active: !!src.active,
  };
}

B) Backend: harden joins + compute KPIs in the RPC

Edit: server/routes/rpc.ts → enhance /get_property_card

Drop this into the property handler after you load property (pseudo-patch shows only the new middle block):

// build maps for dual-key joins (id OR doorloop_id)
const [{ data: allUnits }] = await Promise.all([
  supabase.from('units').select('*').or(`property_id.eq.${property.id},doorloop_property_id.eq.${property.doorloop_id ?? '___none___'}`),
]);

const [{ data: allLeases }] = await Promise.all([
  supabase.from('leases').select('*').or(`property_id.eq.${property.id},doorloop_property_id.eq.${property.doorloop_id ?? '___none___'}`),
]);

// Occupancy and avg rent from the joined arrays
const units = allUnits ?? [];
const leases = allLeases ?? [];

const activeLeases = leases.filter(l => String(l?.status ?? '').toLowerCase() === 'active');
const occupancyPct = units.length ? Math.round((activeLeases.length / units.length) * 1000) / 10 : 0;
const avgRentCents = leases.length
  ? Math.round((leases.reduce((sum, l) => sum + (Number(l?.rent_cents ?? 0) || 0), 0)) / leases.length)
  : null;

// keep your existing owner lookup, then:
res.json({ property, units, leases, owner, kpis: { units: units.length, activeLeases: activeLeases.length, occupancyPct, avgRentCents } });


If your units / leases tables use different external key names (e.g., doorloop_prop_id), change doorloop_property_id accordingly—this is the dual-key join that prevents “0 Units / 0%” when only DoorLoop IDs are present.

C) Backend: make portfolio endpoints resilient to missing FKs (once)

Edit: server/index.ts → inside /api/portfolio/properties and /api/portfolio/units handlers, when you build counts/names, prefer:

// build property maps by id and by doorloop_id
const { data: propertiesData } = await supa.client.from(TABLE.properties).select("id, name, doorloop_id, address_city, address_state, address_zip").limit(5000);
const byId = new Map((propertiesData??[]).map(p => [String(p.id), p]));
const byDL = new Map((propertiesData??[]).filter(p => p.doorloop_id).map(p => [String(p.doorloop_id), p]));

// when attributing a unit to a property:
const p =
  (unit.property_id && byId.get(String(unit.property_id))) ||
  (unit.doorloop_property_id && byDL.get(String(unit.doorloop_property_id))) ||
  null;
const propKey = p ? String(p.id) : String(unit.property_id ?? '');


…and then compute units, occPct, and (for units list) propertyName from p?.name.

That gives you the hardened data mapping layer so even if Replit rearranges a fetch or someone accidentally points at raw tables, your API still returns normalized, computed shapes.

Copy-paste prompt for Replit (no guessing)
PLAN
Operating Mode: Debugging Specialist, Consistency Enforcer
Files to Touch:
- src/lib/ecc-resolvers.ts
- src/pages/portfolio/columns.tsx  (fallbacks only)
- server/routes/rpc.ts
- server/index.ts  (portfolio handlers: properties/units)
Guardrails:
- Only edit the files listed.
- Back up each touched file to *.bak before writing.
- No new deps. Keep existing endpoints.

CHANGESET
1) Rewire portfolio hooks to /api/portfolio/* in src/lib/ecc-resolvers.ts.
2) Add address_* fallbacks in mapProperty (columns.tsx).
3) In server/routes/rpc.ts, enhance /get_property_card to:
   - Join units/leases by id OR doorloop_id.
   - Compute kpis { units, activeLeases, occupancyPct, avgRentCents } in the response.
4) In server/index.ts, make /api/portfolio/properties and /api/portfolio/units robust to missing FKs by:
   - Building property maps by id and doorloop_id.
   - Attributing units and computed counts using either key.
   - Keep normalized fields (city/state/zip).

VERIFICATION CHECKLIST
- Visit /portfolio/properties: CITY/STATE/ZIP show real values; UNITS and OCC% non-zero.
- Visit /portfolio/units: PROPERTY column populated.
- Visit /card/property/<known-id>: KPIs show non-zero Units/Active Leases/Occupancy; Avg Rent populated.
- Console: no 4xx/5xx from /api/portfolio/* or /api/rpc/get_property_card.
- Dev script (optional): run runPortfolioAudit() and confirm “Field Coverage Analysis” shows values.