1) Property Card – route param → number (fix type mismatch)

File: src/pages/card/property/index.tsx
Action: Coerce id to number before passing to the hook; add error/loading boundaries.

// BEFORE (pattern varies, key is string id going into hook)
// const { id } = params;
// const q = usePropertyCard(id);

/// AFTER
import { useRoute } from "wouter";
import { ErrorBoundary } from "@/components/ErrorBoundary"; // already added in Fix Pack v4
import PropertyHero from "./HeroBlock"; // your hero component

export default function PropertyCardPage() {
  const [, params] = useRoute("/card/property/:id");
  const idNum = Number(params?.id);
  const { data, isLoading, isError, error } = usePropertyCard(idNum);

  if (!Number.isFinite(idNum)) {
    return <div data-testid="prop-invalid">Invalid property id</div>;
  }

  return (
    <ErrorBoundary>
      {isError ? (
        <div data-testid="prop-error">Failed to load: {String(error)}</div>
      ) : (
        <div className="grid grid-cols-12 gap-4">
          <section className="col-span-12 ecc-object">
            <PropertyHero data={data} isLoading={isLoading} />
          </section>
          {/* rest of your tabs/sections unchanged */}
        </div>
      )}
    </ErrorBoundary>
  );
}

2) Property Hero – use server KPIs when present; correct % format; test IDs

File: src/pages/card/property/HeroBlock.tsx
Action: Prefer data.kpis from RPC; fallback compute; consistent formatting; add data-testids.

import { useMemo } from "react";
import { KPIBlockSkeleton } from "@/components/Skeletons";

type Props = { data: any; isLoading?: boolean };

export default function PropertyHero({ data, isLoading }: Props) {
  if (isLoading) return <KPIBlockSkeleton />;

  const { units = [], leases = [], kpis, property } = data || {};

  const calc = useMemo(() => {
    if (kpis) {
      return {
        unitsCount: Number(kpis.units ?? 0),
        active: Number(kpis.activeLeases ?? 0),
        occupancy: Number(kpis.occupancyPct ?? 0) / 100, // backend is percent
        avgRentCents: Number(kpis.avgRentCents ?? 0),
      };
    }
    const unitsCount = Array.isArray(units) ? units.length : 0;
    const active = (Array.isArray(leases) ? leases : [])
      .filter((l: any) => String(l?.status ?? "").toLowerCase() === "active").length;
    const occupancy = unitsCount ? active / unitsCount : 0;
    const rents = (Array.isArray(leases) ? leases : [])
      .filter((l: any) => String(l?.status ?? "").toLowerCase() === "active")
      .map((l: any) => Number(l?.rent_cents ?? l?.rent ?? 0));
    const avgRentCents = rents.length ? Math.round(rents.reduce((a, b) => a + b, 0) / rents.length) : 0;
    return { unitsCount, active, occupancy, avgRentCents };
  }, [kpis, units, leases]);

  const city = property?.city ?? property?.address_city ?? "—";
  const state = property?.state ?? property?.address_state ?? "—";
  const zip = property?.zip ?? property?.address_zip ?? "—";

  return (
    <div className="grid grid-cols-4 gap-4">
      <div data-testid="kpi-units">
        <div className="text-xs opacity-70">Units</div>
        <div className="text-2xl">{calc.unitsCount}</div>
      </div>
      <div data-testid="kpi-active">
        <div className="text-xs opacity-70">Active Leases</div>
        <div className="text-2xl">{calc.active}</div>
      </div>
      <div data-testid="kpi-occupancy">
        <div className="text-xs opacity-70">Occupancy</div>
        <div className="text-2xl">{(calc.occupancy * 100).toFixed(1)}%</div>
      </div>
      <div data-testid="kpi-avgrent">
        <div className="text-xs opacity-70">Avg Rent</div>
        <div className="text-2xl">${Math.round((calc.avgRentCents ?? 0) / 100)}</div>
      </div>

      <div className="col-span-4 text-sm opacity-80" data-testid="address">
        {city}, {state} {zip}
      </div>
    </div>
  );
}

3) Portfolio Properties – consume normalized endpoint (no field drift)

File: src/lib/ecc-resolvers.ts
Action: point list hook at normalized endpoint (you approved this in audit), leaving entities as fallback if needed elsewhere. No operational changes.

export function useAllProperties() {
  return useQuery({
    queryKey: ["portfolio","properties"],
    queryFn: async ({ signal }) => {
      const r = await fetch("/api/portfolio/properties", { signal });
      if (!r.ok) throw new Error(await r.text());
      return r.json();
    },
  });
}


Optional fallback mapper (if some view still pulls raw entities): in your table mapper, prefer city/state/zip and fall back to address_*. (Keep it in the table layer only; do not alter API.)

4) Unit Card – dual-key mapping (without touching server)

File: src/pages/card/unit/index.tsx (or wherever you render the unit’s property name)
Action: defend against missing FK by showing property from DTO (server now tries PK or DoorLoop), and fallback to “Unlinked”.

const propName =
  data?.property?.name ??
  data?.property?.address_street1 ??
  data?.property?.street1 ??
  "Unlinked";


(Your RPC is already dual-key; this just prevents blank UI if a record is still orphaned.)

5) Guardrail – enforce test IDs (already added in Fix Pack v4)

Run the guardrail. It should PASS with the new test IDs on the Property Hero; extend to other cards when you add their KPIs.

npm run guardrail

6) How to validate (no server file edits)

Start dev:

npm run dev


API proof (same as audit):

curl -s "http://localhost:8787/api/rpc/get_property_card?id=42" | jq '{kpis:.kpis, city:.property.city, state:.property.state, zip:.property.zip}'


Frontend proof (use Vite):

Open http://localhost:5173/card/property/42

Confirm:

Units / Active / Occupancy / Avg Rent populate (not dashes)

data-testid="kpi-units|kpi-active|kpi-occupancy|kpi-avgrent" present in DOM

City/State/Zip render from normalized fields