Hooks Law Fix Pack: resolvers + guardrails (no more “Rendered more hooks…”)

You are in PATCH MODE. Apply exactly. Show diffs and run verification at the end.

1) Refactor relation resolvers to constant hook calls

Edit: src/lib/ecc-resolvers.ts
Do not change URLs/queryFns you already use; just restructure calls so the hook count is constant across renders. For each relations hook:

Call the same set of useQuery hooks unconditionally (always the same order).

Use enabled: Boolean(id) (and any additional flags) to skip network work without skipping the hook call.

No if (...) useQuery(...) and no loops (for, .map) around hooks.

Implement this exact pattern for all five:

import { useQuery } from "@tanstack/react-query";
import { apiGet } from "./ecc-api";

/** PROPERTY */
export function usePropertyRelations(id?: string | number) {
  const pid = id == null ? "" : String(id);
  const on = Boolean(id);

  // KEEP EXISTING ENDPOINTS / QUERYFNs — only the structure changes.
  const property = useQuery({
    queryKey: ["property", pid],
    queryFn: () => apiGet(`/api/entities/properties/${pid}`),
    enabled: on,
  });
  const units = useQuery({
    queryKey: ["property", pid, "units"],
    queryFn: () => apiGet(`/api/entities/properties/${pid}/units`),
    enabled: on,
  });
  const leases = useQuery({
    queryKey: ["property", pid, "leases"],
    queryFn: () => apiGet(`/api/entities/properties/${pid}/leases`),
    enabled: on,
  });
  const tenants = useQuery({
    queryKey: ["property", pid, "tenants"],
    queryFn: () => apiGet(`/api/entities/properties/${pid}/tenants`),
    enabled: on,
  });
  const owner = useQuery({
    queryKey: ["property", pid, "owner"],
    queryFn: () => apiGet(`/api/entities/properties/${pid}/owner`),
    enabled: on,
  });

  const isLoading = on && [property, units, leases, tenants, owner].some(q => q.isLoading);
  return {
    property: property.data ?? null,
    units: units.data ?? [],
    leases: leases.data ?? [],
    tenants: tenants.data ?? [],
    owner: owner.data ?? null,
    isLoading,
    queries: { property, units, leases, tenants, owner },
  };
}

/** UNIT */
export function useUnitRelations(id?: string | number) {
  const uid = id == null ? "" : String(id);
  const on = Boolean(id);

  const unit = useQuery({
    queryKey: ["unit", uid],
    queryFn: () => apiGet(`/api/entities/units/${uid}`),
    enabled: on,
  });
  const property = useQuery({
    queryKey: ["unit", uid, "property"],
    queryFn: () => apiGet(`/api/entities/units/${uid}/property`),
    enabled: on,
  });
  const activeLease = useQuery({
    queryKey: ["unit", uid, "activeLease"],
    queryFn: () => apiGet(`/api/entities/units/${uid}/active-lease`),
    enabled: on,
  });
  const primaryTenant = useQuery({
    queryKey: ["unit", uid, "primaryTenant"],
    queryFn: () => apiGet(`/api/entities/units/${uid}/primary-tenant`),
    enabled: on,
  });

  const isLoading = on && [unit, property, activeLease, primaryTenant].some(q => q.isLoading);
  return {
    unit: unit.data ?? null,
    property: property.data ?? null,
    activeLease: activeLease.data ?? null,
    primaryTenant: primaryTenant.data ?? null,
    isLoading,
    queries: { unit, property, activeLease, primaryTenant },
  };
}

/** LEASE */
export function useLeaseRelations(id?: string | number) {
  const lid = id == null ? "" : String(id);
  const on = Boolean(id);

  const lease = useQuery({
    queryKey: ["lease", lid],
    queryFn: () => apiGet(`/api/entities/leases/${lid}`),
    enabled: on,
  });
  const property = useQuery({
    queryKey: ["lease", lid, "property"],
    queryFn: () => apiGet(`/api/entities/leases/${lid}/property`),
    enabled: on,
  });
  const unit = useQuery({
    queryKey: ["lease", lid, "unit"],
    queryFn: () => apiGet(`/api/entities/leases/${lid}/unit`),
    enabled: on,
  });
  const tenant = useQuery({
    queryKey: ["lease", lid, "tenant"],
    queryFn: () => apiGet(`/api/entities/leases/${lid}/tenant`),
    enabled: on,
  });

  const isLoading = on && [lease, property, unit, tenant].some(q => q.isLoading);
  return {
    lease: lease.data ?? null,
    property: property.data ?? null,
    unit: unit.data ?? null,
    tenant: tenant.data ?? null,
    isLoading,
    queries: { lease, property, unit, tenant },
  };
}

/** TENANT */
export function useTenantRelations(id?: string | number) {
  const tid = id == null ? "" : String(id);
  const on = Boolean(id);

  const tenant = useQuery({
    queryKey: ["tenant", tid],
    queryFn: () => apiGet(`/api/entities/tenants/${tid}`),
    enabled: on,
  });
  const leases = useQuery({
    queryKey: ["tenant", tid, "leases"],
    queryFn: () => apiGet(`/api/entities/tenants/${tid}/leases`),
    enabled: on,
  });
  const properties = useQuery({
    queryKey: ["tenant", tid, "properties"],
    queryFn: () => apiGet(`/api/entities/tenants/${tid}/properties`),
    enabled: on,
  });

  const isLoading = on && [tenant, leases, properties].some(q => q.isLoading);
  return {
    tenant: tenant.data ?? null,
    leases: leases.data ?? [],
    properties: properties.data ?? [],
    isLoading,
    queries: { tenant, leases, properties },
  };
}

/** OWNER */
export function useOwnerRelations(id?: string | number) {
  const oid = id == null ? "" : String(id);
  const on = Boolean(id);

  const owner = useQuery({
    queryKey: ["owner", oid],
    queryFn: () => apiGet(`/api/entities/owners/${oid}`),
    enabled: on,
  });
  const properties = useQuery({
    queryKey: ["owner", oid, "properties"],
    queryFn: () => apiGet(`/api/entities/owners/${oid}/properties`),
    enabled: on,
  });

  const isLoading = on && [owner, properties].some(q => q.isLoading);
  return {
    owner: owner.data ?? null,
    properties: properties.data ?? [],
    isLoading,
    queries: { owner, properties },
  };
}


Important: Keep your actual endpoint paths (don’t change them). If your file already uses helper queryFns, reuse them—just keep the structure above: fixed hook calls + enabled flags.

2) Lift any conditional or looped hook calls out of pages

Edit each card page:
src/pages/card/property/index.tsx
src/pages/card/unit/index.tsx
src/pages/card/lease/index.tsx
src/pages/card/tenant/index.tsx
src/pages/card/owner/index.tsx

Ensure all hooks are declared at the top level of the component.
If a hook depends on a tab (e.g., Activity), call it always with enabled: tab === "activity" (don’t wrap the hook in an if or render branch).

No .map(...) => useQuery(...) anywhere.

3) Guardrail: ban conditional/looped hooks forever

Edit: scripts/guardrail-mega.mjs — append:

/* 11) Hooks must be unconditional (no if/for/map around React Query hooks) */
const hookRx = /(useQuery|useQueries|useMutation)\s*\(/;
for (const f of files) {
  const src = fs.readFileSync(f, "utf8");
  // if (...) { ... useQuery( ... ) }
  if (/if\s*\([^)]*\)\s*{[\s\S]*?(useQuery|useQueries|useMutation)\s*\(/.test(src)) {
    flag(f, "conditional hook usage forbidden: call hooks unconditionally and use `enabled:`");
  }
  // loops with hooks
  if (/for\s*\([^)]*\)\s*{[\s\S]*?(useQuery|useQueries|useMutation)\s*\(/.test(src)) {
    flag(f, "looped hook usage forbidden");
  }
  if (/\.map\s*\([^)]*=>\s*(?:{[\s\S]*?(useQuery|useQueries|useMutation)\s*\(|(useQuery|useQueries|useMutation)\s*\()/.test(src)) {
    flag(f, "hooks inside .map forbidden");
  }
}

4) Verify

Run:

node scripts/guardrail-mega.mjs
node scripts/guardrail-overlays.mjs
npx tsc -p tsconfig.cards.json


Expected: all ✅.

Open real IDs for each route that previously failed. The error panel should disappear, and the pages should render. Paste a 5-line checklist (one per route) with “renders ✅ / page cover ❌ / map rule respected”.

Why this will fix it

The “Rendered more hooks…” crash happens only when the number/order of hooks changes between renders. Refactoring to constant, unconditional hook calls and using enabled: removes that failure mode entirely.

Lifting hooks out of conditionals and loops + the new guardrail ensures we can’t regress.

Once green, we can continue filling out the Property tabs (Financials/Legal now render), then replicate per-card specifics for Unit/Lease/Tenant/Owner without fighting runtime crashes.