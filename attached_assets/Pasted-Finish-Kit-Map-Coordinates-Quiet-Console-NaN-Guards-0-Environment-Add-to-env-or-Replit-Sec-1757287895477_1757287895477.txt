Finish Kit — Map Coordinates + Quiet Console + NaN Guards
0) Environment

Add to .env (or Replit Secrets):

GOOGLE_MAPS_API_KEY=YOUR_KEY          # server-side geocoder (optional if using OSM)
GEOCODER_PROVIDER=google              # or: osm


You can use OSM if you don’t want Google billing. Google is faster/more precise.

1) DB migration (lat/lng + geocode cache)

Run this SQL once (Supabase/psql):

ALTER TABLE public.properties
  ADD COLUMN IF NOT EXISTS lat double precision,
  ADD COLUMN IF NOT EXISTS lng double precision;

CREATE TABLE IF NOT EXISTS public.geocode_cache (
  id BIGSERIAL PRIMARY KEY,
  address text UNIQUE NOT NULL,
  lat double precision NOT NULL,
  lng double precision NOT NULL,
  provider text NOT NULL,
  confidence numeric,
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS geocode_cache_address_idx ON public.geocode_cache (address);

2) Server geocoder (rate-limited + cached)

File: server/lib/geocode.ts

// server/lib/geocode.ts
// Uses Node18+ global fetch. No extra deps.

import { pool } from "../db"; // your existing pg Pool

const PROVIDER = (process.env.GEOCODER_PROVIDER || "google").toLowerCase();
const GOOGLE_KEY = process.env.GOOGLE_MAPS_API_KEY;

type Hit = { lat: number; lng: number; provider: string; confidence?: number | null };

export async function geocode(address: string): Promise<Hit | null> {
  if (!address?.trim()) return null;

  // 1) cache
  const c = await cacheGet(address);
  if (c) return c;

  // 2) provider
  const hit = PROVIDER === "google" && GOOGLE_KEY
    ? await geocodeGoogle(address)
    : await geocodeOSM(address);

  if (hit) await cachePut(address, hit);
  return hit;
}

async function geocodeGoogle(address: string): Promise<Hit | null> {
  const url = new URL("https://maps.googleapis.com/maps/api/geocode/json");
  url.searchParams.set("address", address);
  url.searchParams.set("key", GOOGLE_KEY!);
  const r = await fetch(url);
  if (!r.ok) return null;
  const j = await r.json();
  const g = j?.results?.[0]?.geometry?.location;
  if (!g) return null;
  return { lat: g.lat, lng: g.lng, provider: "google", confidence: 1 };
}

async function geocodeOSM(address: string): Promise<Hit | null> {
  const url = new URL("https://nominatim.openstreetmap.org/search");
  url.searchParams.set("q", address);
  url.searchParams.set("format", "jsonv2");
  const r = await fetch(url, {
    headers: { "User-Agent": "Altus-Empire/1.0 (contact: admin@altus.example)" },
  });
  if (!r.ok) return null;
  const a = await r.json();
  const f = a?.[0];
  if (!f) return null;
  return { lat: parseFloat(f.lat), lng: parseFloat(f.lon), provider: "osm", confidence: f.importance ?? null };
}

// cache
async function cacheGet(address: string): Promise<Hit | null> {
  const { rows } = await pool.query(
    "SELECT lat,lng,provider,confidence FROM geocode_cache WHERE address=$1",
    [address]
  );
  const r = rows[0];
  return r ? { lat: r.lat, lng: r.lng, provider: r.provider, confidence: r.confidence } : null;
}

async function cachePut(address: string, hit: Hit) {
  await pool.query(
    `INSERT INTO geocode_cache(address,lat,lng,provider,confidence)
     VALUES($1,$2,$3,$4,$5)
     ON CONFLICT(address)
     DO UPDATE SET lat=EXCLUDED.lat,lng=EXCLUDED.lng,provider=EXCLUDED.provider,confidence=EXCLUDED.confidence,updated_at=now()`,
    [address, hit.lat, hit.lng, hit.provider, hit.confidence ?? null]
  );
}

3) Backfill script (1 req/sec)

File: scripts/backfill-geocodes.ts

// node -r esbuild-register scripts/backfill-geocodes.ts
import { pool } from "../server/db";
import { geocode } from "../server/lib/geocode";

const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));

function makeAddress(p: any) {
  const parts = [p.street, p.city, p.state, p.zip].filter(Boolean);
  return parts.length ? parts.join(", ") : (p.name || "");
}

(async () => {
  const { rows } = await pool.query(`
    SELECT id, name, street, city, state, zip, lat, lng
    FROM public.properties
    WHERE lat IS NULL OR lng IS NULL
    ORDER BY id ASC
  `);

  let ok = 0, fail = 0;
  for (const p of rows) {
    const address = makeAddress(p);
    const hit = await geocode(address);
    if (hit) {
      await pool.query(`UPDATE public.properties SET lat=$1, lng=$2 WHERE id=$3`, [hit.lat, hit.lng, p.id]);
      ok++;
      console.log(`✓ ${p.id}: ${address} -> ${hit.lat},${hit.lng} (${hit.provider})`);
    } else {
      fail++;
      console.warn(`× ${p.id}: ${address} (no result)`);
    }
    await sleep(1000); // 1/sec
  }

  console.log(`Backfill complete: ${ok} updated, ${fail} skipped/failed`);
  process.exit(0);
})();


Run:

node -r esbuild-register scripts/backfill-geocodes.ts

4) API: return lat/lng

File: server/routes/portfolio.ts (properties endpoint)

app.get("/api/portfolio/properties", async (_req, res) => {
  try {
    const { rows } = await pool.query(`
      SELECT id, name, class, type, street, city, state, zip, active, units, occ_pct,
             lat, lng
      FROM public.properties
      WHERE active IS TRUE
      ORDER BY name ASC
    `);
    res.json(rows);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "properties_query_failed" });
  }
});

5) Frontend map: only plot valid coords

File: src/features/dashboard/components/PortfolioGoogleMap.tsx

const points = properties.filter(
  p => typeof p.lat === "number" && typeof p.lng === "number" && Number.isFinite(p.lat) && Number.isFinite(p.lng)
).map(p => ({
  id: p.id,
  name: p.name,
  lat: p.lat as number,
  lng: p.lng as number,
  status: computeStatus(p), // existing logic
}));

// if points.length === 0, show friendly empty state panel

6) Formatting/util guards (fix “money/percent/date” imports & NaN)

File: src/utils/format.ts

export const fmtMoney = (n?: number | null) =>
  typeof n === "number" && Number.isFinite(n)
    ? n.toLocaleString("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 0 })
    : "$0";

export const fmtPct = (n?: number | null, digits = 1) =>
  typeof n === "number" && Number.isFinite(n)
    ? `${n.toFixed(digits)}%`
    : `${(0).toFixed(digits)}%`;

export const fmtDate = (iso?: string | null) =>
  iso ? new Date(iso).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" }) : "—";

/** Back-compat aliases (some files import these names) */
export const money = fmtMoney;
export const percent = fmtPct;
export const date = fmtDate;
export const formatMoney = fmtMoney;


File: src/features/dashboard/components/OccupancyByCity.tsx (inside render loop)

const total = row.totalUnits ?? 0;
const occ = row.occupiedUnits ?? 0;
const pctVal = total > 0 ? (occ / total) * 100 : 0;
const pctText = fmtPct(pctVal, 1);
const width = Math.max(0, Math.min(100, pctVal));


File: src/features/dashboard/components/KpiTicker.tsx

const totalUnits = data.kpis.totalUnits ?? 0;
const occupied = data.kpis.occupiedUnits ?? 0;
const occupancyPct = totalUnits > 0 ? (occupied / totalUnits) * 100 : 0;

const vacant = Math.max(0, totalUnits - occupied);
const rentReady = Math.max(0, Math.min(vacant, data.kpis.rentReady ?? 0));

const billed = data.kpis.billedMTD ?? 0;
const receipts = data.kpis.receiptsMTD ?? 0;
const collPct = billed > 0 ? (receipts / billed) * 100 : 0;

7) Silence the console spam (dev-only)

File: src/main.tsx (top-level, before ReactDOM render)

if (import.meta.env.DEV) {
  // React StrictMode + aborted fetches during HMR
  window.addEventListener("unhandledrejection", (e: any) => {
    if (e?.reason?.name === "AbortError") e.preventDefault();
  });
  window.addEventListener("error", (e: any) => {
    if (String(e?.message || "").includes("AbortError")) e.preventDefault();
  });

  // If Replit injects eruda and it misbehaves, try to kill it silently
  const erudaAny = (window as any).eruda;
  if (erudaAny && typeof erudaAny.destroy === "function") {
    try { erudaAny.destroy(); } catch {}
  }
}


We’re not importing eruda ourselves anywhere. This only prevents the injected one from spamming DOMException.

8) QA checklist (fast)

DB: SELECT name, lat, lng FROM public.properties WHERE lat IS NULL OR lng IS NULL; returns 0–few rows.

API: GET /api/portfolio/properties shows non-null lat/lng.

Map: shows clustered pins; no “missing coordinates” warnings.

City table: never shows NaN; 0.0% when no units.

KPIs: never NaN; links still deep-link correctly.

Console: no perpetual AbortError/eruda DOMException spam.

What this delivers

Live, DB-first map with clustering and status colors.

No mock data anywhere.

Quiet dev console and bulletproof formatting.

No changes to the sidebar/nav or theme.