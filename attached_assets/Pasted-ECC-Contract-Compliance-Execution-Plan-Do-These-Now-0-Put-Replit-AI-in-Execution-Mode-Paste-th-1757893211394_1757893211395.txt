ECC Contract Compliance — Execution Plan (Do These Now)
0) Put Replit AI in Execution Mode

Paste this first:

MODE: Contract Compliance Executor (CSP v2)
Rules: No scope drift. Only edit files listed below. Backup before write. After each step, post file diffs + proof (curl + page screenshots + guardrail).

1) Drop in the Hardening Files (full replacements)

Open the canvas “ECC Asset Card Contract Hardening — Fix Pack v4 …” and paste these files verbatim, overwriting existing ones:

server/lib/mapping.ts

server/routes/rpc.ts (dual-key joins + KPIs + normalized address)

src/lib/dto.ts (Zod schemas for all cards)

src/lib/ecc-resolvers.ts (RPC-first + Zod validation + entities fallback)

src/components/ErrorBoundary.tsx

src/components/Skeletons.tsx

scripts/guardrail-check.mjs (updated to enforce testIDs)

Back up each touched file to *.bak before replacing.

2) Patch Property Card (type coercion + robust hero)

File: src/pages/card/property/index.tsx

import { useRoute } from "wouter";
import { ErrorBoundary } from "@/components/ErrorBoundary";
import PropertyHero from "./HeroBlock";

export default function PropertyCardPage() {
  const [, params] = useRoute("/card/property/:id");
  const idNum = Number(params?.id);
  const { data, isLoading, isError, error } = usePropertyCard(idNum);

  if (!Number.isFinite(idNum)) return <div data-testid="prop-invalid">Invalid property id</div>;

  return (
    <ErrorBoundary>
      {isError ? (
        <div data-testid="prop-error">Failed to load: {String(error)}</div>
      ) : (
        <div className="grid grid-cols-12 gap-4">
          <section className="col-span-12 ecc-object">
            <PropertyHero data={data} isLoading={isLoading} />
          </section>
          {/* tabs/sections unchanged */}
        </div>
      )}
    </ErrorBoundary>
  );
}


File: src/pages/card/property/HeroBlock.tsx

import { useMemo } from "react";
import { KPIBlockSkeleton } from "@/components/Skeletons";

export default function PropertyHero({ data, isLoading }: { data:any; isLoading?:boolean }) {
  if (isLoading) return <KPIBlockSkeleton />;

  const { units = [], leases = [], kpis, property } = data || {};
  const calc = useMemo(() => {
    if (kpis) {
      return {
        unitsCount: Number(kpis.units ?? 0),
        active: Number(kpis.activeLeases ?? 0),
        occupancy: Number(kpis.occupancyPct ?? 0) / 100, // backend in %
        avgRentCents: Number(kpis.avgRentCents ?? 0),
      };
    }
    const unitsCount = Array.isArray(units) ? units.length : 0;
    const active = (Array.isArray(leases) ? leases : [])
      .filter((l:any) => String(l?.status ?? "").toLowerCase()==="active").length;
    const occupancy = unitsCount ? active/unitsCount : 0;
    const rents = (Array.isArray(leases) ? leases : [])
      .filter((l:any)=>String(l?.status ?? "").toLowerCase()==="active")
      .map((l:any)=>Number(l?.rent_cents ?? l?.rent ?? 0));
    const avgRentCents = rents.length ? Math.round(rents.reduce((a,b)=>a+b,0)/rents.length) : 0;
    return { unitsCount, active, occupancy, avgRentCents };
  }, [kpis, units, leases]);

  const city  = property?.city  ?? property?.address_city  ?? "—";
  const state = property?.state ?? property?.address_state ?? "—";
  const zip   = property?.zip   ?? property?.address_zip   ?? "—";

  return (
    <div className="grid grid-cols-4 gap-4">
      <div data-testid="kpi-units"><div className="text-xs opacity-70">Units</div><div className="text-2xl">{calc.unitsCount}</div></div>
      <div data-testid="kpi-active"><div className="text-xs opacity-70">Active Leases</div><div className="text-2xl">{calc.active}</div></div>
      <div data-testid="kpi-occupancy"><div className="text-xs opacity-70">Occupancy</div><div className="text-2xl">{(calc.occupancy*100).toFixed(1)}%</div></div>
      <div data-testid="kpi-avgrent"><div className="text-xs opacity-70">Avg Rent</div><div className="text-2xl">${Math.round((calc.avgRentCents||0)/100)}</div></div>
      <div className="col-span-4 text-sm opacity-80" data-testid="address">{city}, {state} {zip}</div>
    </div>
  );
}

3) Portfolio Properties → normalized endpoint

File: src/lib/ecc-resolvers.ts (collection hook)

export function useAllProperties() {
  return useQuery({
    queryKey: ["portfolio","properties"],
    queryFn: async ({ signal }) => {
      const r = await fetch("/api/portfolio/properties", { signal });
      if (!r.ok) throw new Error(await r.text());
      return r.json();
    },
  });
}


(If any legacy table still reads /api/entities/properties, keep a mapper fallback to address_* in that table file—don’t touch the API.)

4) Unit Card UI — safe property name

File: src/pages/card/unit/index.tsx (where you display property)

const propName =
  data?.property?.name ??
  data?.property?.street1 ??
  data?.property?.address_street1 ??
  "Unlinked";

5) Run Guardrails & Dev
npm run guardrail
npm run dev

6) Proof (copy/paste)
# API proof
curl -s "http://localhost:8787/api/rpc/get_property_card?id=42" | jq '{units:.kpis.units, active:.kpis.activeLeases, occ:.kpis.occupancyPct, city:.property.city, state:.property.state, zip:.property.zip}'

# Frontend proof (use Vite):
# open http://localhost:5173/card/property/42
# verify DOM contains data-testid: kpi-units, kpi-active, kpi-occupancy, kpi-avgrent, address

# Portfolio list proof:
# open http://localhost:5173/portfolio/properties
# verify CITY/STATE/ZIP populated; UNITS/OCC% non-zero

7) Commit the Compliance Gate
git add .
git commit -m "ECC: Contract compliance — DTOs, dual-key RPC, testIDs, address mapping, guardrail pass"


If any step fails, stop and post the exact error output. Otherwise, this locks 100% contract compliance: normalized fields, dual-key joins, validated DTOs for all cards, enforced test IDs, and guardrails to block regressions.