REPLIT GUARDRAILED TASK: Reconcile Portfolio V3 data + columns (no theme drift)

Do not change any theming, layout, or global styles.
Only touch the files listed below. Keep class names and CSS tokens as-is. Preserve the DataTable API and current look/feel.

Scope

Standardize and correct the table column sets and row mapping for:

/portfolio/properties

/portfolio/units

/portfolio/leases

/portfolio/tenants

/portfolio/owners

Ensure the following exports exist from src/pages/portfolio/columns.tsx (exact names):

export const PROPERTY_COLUMNS: ColumnDef[];
export const UNIT_COLUMNS: ColumnDef[];
export const LEASE_COLUMNS: ColumnDef[];
export const TENANT_COLUMNS: ColumnDef[];
export const OWNER_COLUMNS: ColumnDef[];

export function mapProperty(d: any): RowData;
export function mapUnit(d: any): RowData;
export function mapLease(d: any): RowData;
export function mapTenant(d: any): RowData;
export function mapOwner(d: any): RowData;


Make each portfolio page import only from the file above and pass rows/columns to DataTable:

import DataTable from "../../../components/DataTable";
import {
  PROPERTY_COLUMNS, mapProperty,
  UNIT_COLUMNS, mapUnit,
  LEASE_COLUMNS, mapLease,
  TENANT_COLUMNS, mapTenant,
  OWNER_COLUMNS, mapOwner,
} from "../columns";


No other column definitions scattered elsewhere.

Keep double-click row navigation working:

If the entity has an asset card route, set onRowDoubleClick to push to it.

Routes you should wire (adjust if different in project):

Property → /portfolio/properties/{id}

Unit → /portfolio/units/{id}

Lease → /portfolio/leases/{id}

Tenant → /portfolio/tenants/{id}

Owner → /portfolio/owners/{id}

Do not alter theme files, table.css, sidebar/nav, or KPI cards.

Do not rename DataTable props or change its public interface.

Files to edit

src/pages/portfolio/columns.tsx ← canonical home for all table configs + mappers

src/pages/portfolio/properties/index.tsx

src/pages/portfolio/units/index.tsx

src/pages/portfolio/leases/index.tsx

src/pages/portfolio/tenants/index.tsx

src/pages/portfolio/owners/index.tsx

src/utils/format.tsx (only if any formatter is missing)

Column sets (required)

Use these exact columns/keys/filters. All numeric columns right-align. Status/boolean columns use existing badge helpers. For progress UI, use the same progress cell already used on Properties (no new styles).

PROPERTIES

Required fields:

property (display address or name)

type

class

state

city

zip ✅ (new)

units (number)

occ (occupancy % with progress bar)

active (badge)

Column config:

export const PROPERTY_COLUMNS: ColumnDef[] = [
  { key: "property", header: "PROPERTY", filter: "text" },
  { key: "type", header: "TYPE", filter: "select" },
  { key: "class", header: "CLASS", filter: "select" },
  { key: "state", header: "STATE", filter: "select", width: 84 },
  { key: "city", header: "CITY", filter: "text" },
  { key: "zip", header: "ZIP", filter: "text", width: 96 },
  { key: "units", header: "UNITS", align: "right", sort: "numeric", filter: "numberRange", width: 84 },
  { key: "occ", header: "OCCUPANCY", align: "right", sort: "numeric", filter: "numberRange", render: "progress" },
  { key: "active", header: "ACTIVE", filter: "select-bool", render: "badge" },
];

UNITS

Required fields:

property (full address or property name)

unit (unit address/number)

bd (beds)

ba (baths)

sqft

status (Occupied/Vacant/Other)

market_rent (money)

export const UNIT_COLUMNS: ColumnDef[] = [
  { key: "property", header: "PROPERTY", filter: "text" },
  { key: "unit", header: "UNIT", filter: "text" },
  { key: "bd", header: "BEDS", align: "right", sort: "numeric", filter: "numberRange", width: 84 },
  { key: "ba", header: "BATHS", align: "right", sort: "numeric", filter: "numberRange", width: 84 },
  { key: "sqft", header: "SQFT", align: "right", sort: "numeric", filter: "numberRange", width: 100 },
  { key: "status", header: "STATUS", filter: "select", render: "badge" },
  { key: "market_rent", header: "MARKET RENT", align: "right", sort: "numeric", filter: "numberRange", render: "money" },
];

LEASES

Required fields:

tenant (primary tenant; append “+N” if multiple tenants on lease)

property

unit

status (active/ended/pending, badge)

start (short date)

end (short date)

rent (money)

export const LEASE_COLUMNS: ColumnDef[] = [
  { key: "tenant", header: "TENANT(S)", filter: "text" },
  { key: "property", header: "PROPERTY", filter: "text" },
  { key: "unit", header: "UNIT", filter: "text" },
  { key: "status", header: "STATUS", filter: "select", render: "badge" },
  { key: "start", header: "START", sort: "date", filter: "date", render: "date" },
  { key: "end", header: "END", sort: "date", filter: "date", render: "date" },
  { key: "rent", header: "RENT", align: "right", sort: "numeric", filter: "numberRange", render: "money" },
];

TENANTS

We have two types: Lease Tenants and Prospects. Must be sortable/filterable by type. Also some households have secondary tenants—show primary name and add +N where N is additional members.

Required fields:

tenant (primary name; “+N” for household size)

email

phone

property

unit

type (Lease_Tenant | Prospect) ← filterable

balance (money)

export const TENANT_COLUMNS: ColumnDef[] = [
  { key: "tenant", header: "TENANT", filter: "text" },
  { key: "email", header: "EMAIL", filter: "text" },
  { key: "phone", header: "PHONE", filter: "text" },
  { key: "property", header: "PROPERTY", filter: "text" },
  { key: "unit", header: "UNIT", filter: "text" },
  { key: "type", header: "TYPE", filter: "select", render: "badge" }, // Lease_Tenant | Prospect
  { key: "balance", header: "BALANCE", align: "right", sort: "numeric", filter: "numberRange", render: "money" },
];

OWNERS

Do not list all properties in the table (too long). Show counts and contact info. Clicking or double-clicking goes to owner asset card for details.

Required fields:

owner (company or person display name)

email

phone

properties (count)

active (badge)

export const OWNER_COLUMNS: ColumnDef[] = [
  { key: "owner", header: "OWNER", filter: "text" },
  { key: "email", header: "EMAIL", filter: "text" },
  { key: "phone", header: "PHONE", filter: "text" },
  { key: "properties", header: "PROPERTIES", align: "right", sort: "numeric", filter: "numberRange", width: 120 },
  { key: "active", header: "ACTIVE", filter: "select-bool", render: "badge" },
];

Row mappers (robust to schema variance)

In columns.tsx, implement the 5 map* functions to safely read from the project’s actual data shapes. Use helpers that try multiple likely paths and normalize values:

Address/name fallbacks: name, displayName, address.line1, address1, fullAddress.

City/state/zip fallbacks: address.city/addr.city/city; same for state, zip, postal_code.

Occupancy %: occupancy, occupancy_percent, occPct (normalize to 0–100 number).

Units count: units, units_count, unitCount.

Active flag: boolean from active, isActive, or inferred.

Tenants: primary vs secondary:

If tenants array exists on lease, use first as primary and compute +N (N = length-1).

If household/members exist, do same.

Tenant type: if lease id present → Lease_Tenant; else if status like prospect → Prospect.

Phone/email: normalize to strings; empty → “—”.

Money: convert cents or numbers to currency via existing money() formatter.

Dates: format with shortDate().

Implement a tiny get(obj, ...paths) to try multiple dot-paths and a coercePercent, coerceMoney, coerceInt utility inside columns.tsx (local) so we don’t touch other modules.

Example (sketch—adapt to actual shapes in repo):

const get = (o:any, ...paths:string[]) => {
  for (const p of paths) {
    const v = p.split(".").reduce((x,k)=> (x ? x[k] : undefined), o);
    if (v !== undefined && v !== null && v !== "") return v;
  }
  return undefined;
};

const coerceInt = (v:any) => Number.isFinite(+v) ? +v : 0;
const coercePct = (v:any) => {
  if (v == null) return 0;
  const n = +v;
  return n > 1 ? n : Math.round(n * 100);
};

// …use money(), percent(), shortDate(), boolBadge() from utils/format


Now implement the mappers:

mapProperty(d) returns:

{
  id: get(d, "id", "uid", "_id"),
  property: get(d, "name", "displayName", "address.line1", "address1", "fullAddress") || "—",
  type: get(d, "type") || "—",
  class: get(d, "class") || "—",
  state: get(d, "address.state", "addr.state", "state") || "—",
  city: get(d, "address.city", "addr.city", "city") || "—",
  zip: get(d, "address.zip", "addr.zip", "postal_code", "zip") || "—",
  units: coerceInt(get(d, "units", "units_count", "unitCount")),
  occ: coercePct(get(d, "occupancy", "occupancy_percent", "occPct")),
  active: !!get(d, "active", "isActive", "status.active"),
}


mapUnit(d):

{
  id: get(d, "id", "uid", "_id"),
  property: get(d, "property.name", "propertyAddress", "property.address.line1", "property.address1") || "—",
  unit: get(d, "unit", "unit_label", "address.line1", "unitAddress") || "—",
  bd: coerceInt(get(d, "beds", "bd")),
  ba: +get(d, "baths", "ba") || 0,
  sqft: coerceInt(get(d, "sqft", "square_feet")),
  status: get(d, "status", "occupancy_status") || "—",
  market_rent: +get(d, "market_rent", "rent.market", "asking_rent") || 0,
}


mapLease(d):

const tenants = get(d, "tenants") || get(d, "household.members") || [];
const primary = Array.isArray(tenants) && tenants.length ? (tenants[0].name || tenants[0].fullName || tenants[0].firstName && tenants[0].lastName ? `${tenants[0].firstName} ${tenants[0].lastName}`.trim() : tenants[0]) : get(d, "tenant.name", "tenant");
const extra = Array.isArray(tenants) && tenants.length > 1 ? ` +${tenants.length-1}` : "";
{
  id: get(d, "id", "uid", "_id"),
  tenant: (primary || "—") + extra,
  property: get(d, "property.name", "propertyAddress", "unit.property.name") || "—",
  unit: get(d, "unit.label", "unit", "unitAddress") || "—",
  status: get(d, "status") || "—",
  start: get(d, "start", "start_date", "dates.start"),
  end: get(d, "end", "end_date", "dates.end"),
  rent: +get(d, "rent", "monthly_rent") || 0,
}


mapTenant(d):

const type = get(d, "type") || (get(d, "leaseId", "lease.id") ? "Lease_Tenant" : (get(d, "status") === "prospect" ? "Prospect" : "Lease_Tenant"));
const hh = coerceInt(get(d, "householdSize", "members_count"));
const extra = hh > 1 ? ` +${hh-1}` : "";
{
  id: get(d, "id", "uid", "_id"),
  tenant: (get(d, "name", "fullName", "firstName") || "—") + extra,
  email: get(d, "email") || "—",
  phone: get(d, "phone", "phone_number") || "—",
  property: get(d, "property.name", "propertyAddress") || "—",
  unit: get(d, "unit.label", "unit", "unitAddress") || "—",
  type,
  balance: +get(d, "balance", "ledger.balance", "account.balance") || 0,
}


mapOwner(d):

{
  id: get(d, "id", "uid", "_id"),
  owner: get(d, "company", "name", "displayName") || "—",
  email: get(d, "email") || "—",
  phone: get(d, "phone") || "—",
  properties: coerceInt(get(d, "properties_count", "propertyCount", "stats.properties")),
  active: !!get(d, "active", "isActive"),
}


All mappers must return flat row objects with keys matching the column key values above.

Use existing formatters from src/utils/format.tsx:

money(n) for currency

percent(n) for %

shortDate(dt) for dates

boolBadge(v, truthy = "ok", falsy = "bad") already exists; if not, create a compatible render in DataTable (but prefer existing helpers).

If any formatter is missing in utils/format.tsx, add the missing one without changing the others.

Page wiring

In each /src/pages/portfolio/*/index.tsx:

Replace any ad-hoc column arrays with imports from ../columns.

Map the fetched collection with the correct mapper before passing to DataTable.

Example pattern (adapt names to file):

const { data, loading, error } = useCollection("properties"); // keep your existing hook/source
const rows = useMemo(() => (data || []).map(mapProperty), [data]);

return (
  <DataTable
    rows={rows}
    columns={PROPERTY_COLUMNS}
    pageSizeOptions={[25,50,100,200]} // keep your footer control
    onRowDoubleClick={(r)=> navigate(`/portfolio/properties/${r.id}`)}
  />
);


Tenants page:

Add a page-level Type select that feeds the table filter for the type column (values: All, Lease_Tenant, Prospect). You can reuse the table’s column filter setter if exposed; otherwise, filter rows via memo before passing to DataTable when the page filter is not All.

Acceptance criteria

All five pages show real data, no “—” unless truly missing.

Properties table includes ZIP column and shows valid zips.

Owners table shows Owner/Company, Email, Phone, Properties (count), Active. It does not list property names.

Tenants table shows Type (Lease_Tenant vs Prospect) and correctly marks multi-member households as +N.

Numeric columns are right-aligned. Occupancy shows the same progress bar style already used.

Double-click on any row navigates to the correct asset route.

No changes to theme, tokens, CSS, or sidebar nav.

No console errors, no missing exports (e.g., mapUnit), no “DataTable export missing” issues.

HMR remains clean.

When finished, summarize which fields were bound to which source paths for each entity (property/unit/lease/tenant/owner), and list any fields that didn’t exist in source data and therefore display “—”.