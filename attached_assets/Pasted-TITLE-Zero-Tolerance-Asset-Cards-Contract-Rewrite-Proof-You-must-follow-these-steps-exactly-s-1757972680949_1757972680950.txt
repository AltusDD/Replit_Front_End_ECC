TITLE: Zero-Tolerance Asset Cards — Contract Rewrite + Proof

You must follow these steps exactly, stop after each step, and paste the raw outputs I request. If any assertion prints FAIL, fix and re-prove before proceeding.

STEP 1 — Discover the real DB schema (Ground Truth)

Task: Run this SQL on Supabase and return the output as JSON.

-- Ground truth for the 5 tables our cards depend on
select table_name, column_name, data_type, is_nullable
from information_schema.columns
where table_schema = 'public'
  and table_name in ('properties','units','leases','tenants','owners')
order by table_name, ordinal_position;


Return: Paste the raw table describing columns for all five tables.

STEP 2 — Replace RPCs with a Hardened Transformer (server/routes/rpc.ts)

Task: In server/routes/rpc.ts, keep the existing imports and router init, then add/replace with the helpers and all five endpoints below. These endpoints do all transformation & null-coalescing and always return contract-correct shapes.

// ---------- helpers (place near top of rpc.ts) ----------
const s = (v: any, d = '') => (v ?? d);
const n = (v: any, d = 0) => (typeof v === 'number' ? v : (v == null || Number.isNaN(Number(v)) ? d : Number(v)));
const cents = (v: any) => (typeof v === 'number' ? Math.round(v) : (v == null ? null : Math.round(Number(v)*100)));
const ok   = (res: any, body: any) => res.status(200).json(body);
const fail = (res: any, code: number, msg: string) => res.status(code).json({ error: msg });

async function getOneByMulti(sb: any, table: string, id: string|number, alts: string[] = []) {
  const byId = await sb.from(table).select('*').eq('id', id).limit(1);
  if (byId.error) throw byId.error;
  if (byId.data?.length) return byId.data[0];
  for (const col of alts) {
    const r = await sb.from(table).select('*').eq(col, id).limit(1);
    if (r.error) throw r.error;
    if (r.data?.length) return r.data[0];
  }
  return null;
}

function addrFrom(p: any) {
  return {
    line1: s(p?.address1 ?? p?.address_line1 ?? p?.line1),
    city:  s(p?.city),
    state: s(p?.state),
    zip:   s(p?.zip ?? p?.zipcode),
  };
}

// ---------- DIAGNOSTIC: find one id of each entity ----------
rpc.get('/diag/ids', async (_req, res) => {
  try {
    const grab = async (t: string) => (await supabase.from(t).select('id').limit(1)).data?.[0]?.id ?? null;
    ok(res, {
      property: await grab('properties'),
      unit: await grab('units'),
      lease: await grab('leases'),
      owner: await grab('owners'),
      tenant: await grab('tenants'),
    });
  } catch (e:any) { fail(res, 500, e?.message || 'diag error'); }
});

// ---------- PROPERTY ----------
rpc.get('/get_property_card', async (req, res) => {
  try {
    const id = s(req.query.id ?? '').trim();
    if (!id) return fail(res, 400, 'missing id');

    const property = await getOneByMulti(supabase, 'properties', id, ['doorloop_id']);
    if (!property) return fail(res, 404, 'property not found');

    const u = await supabase.from('units').select('id').eq('property_id', property.id);
    if (u.error) throw u.error;
    const units = Array.isArray(u.data) ? u.data : [];
    const totalUnits = units.length;

    const l = await supabase.from('leases')
      .select('status,rent_cents,rent,property_id,unit_id')
      .eq('property_id', property.id);
    if (l.error) throw l.error;
    const leases = Array.isArray(l.data) ? l.data : [];

    const activeCount = leases.filter(x => String(x?.status).toUpperCase() === 'ACTIVE').length;
    const rents = leases.map(x => (typeof x?.rent_cents === 'number' ? x.rent_cents : cents(x?.rent)))
                        .filter((v: any) => typeof v === 'number');
    const avgRentCents = rents.length ? Math.round(rents.reduce((a:number,b:number)=>a+b,0)/rents.length) : null;

    return ok(res, {
      property: {
        id: n(property.id),
        name: s(property.name),
        type: s(property.type, 'UNKNOWN'),
        address: addrFrom(property),
      },
      kpis: {
        units: n(totalUnits, 0),
        activeLeases: n(activeCount, 0),
        occupancyPct: totalUnits > 0 ? Math.round((activeCount / totalUnits) * 100) : 0,
        avgRentCents,
      },
    });
  } catch (e:any) { fail(res, 500, e?.message || 'server error'); }
});

// ---------- UNIT ----------
rpc.get('/get_unit_card', async (req, res) => {
  try {
    const id = s(req.query.id ?? '').trim();
    if (!id) return fail(res, 400, 'missing id');

    const unit = await getOneByMulti(supabase, 'units', id, ['doorloop_id']);
    if (!unit) return fail(res, 404, 'unit not found');

    const property = unit?.property_id
      ? (await supabase.from('properties').select('*').eq('id', unit.property_id).limit(1)).data?.[0] ?? null
      : null;

    const lease = (await supabase.from('leases')
      .select('id,status,rent_cents,unit_id,property_id,tenant_id,start,end')
      .eq('unit_id', unit.id).limit(1)).data?.[0] ?? null;

    return ok(res, {
      unit: {
        id: n(unit.id),
        label: s(unit.unit_label ?? unit.unit_number ?? unit.name),
        beds: n(unit.beds, 0),
        baths: n(unit.baths, 0),
        sqft: n(unit.sqft, 0),
        status: s(unit.status, 'UNKNOWN'),
      },
      property: property ? {
        id: n(property.id), name: s(property.name), address: addrFrom(property)
      } : null,
      lease: lease ? {
        id: n(lease.id), status: s(lease.status, 'UNKNOWN'),
        rentCents: n(lease.rent_cents ?? cents(lease.rent), 0)
      } : null,
    });
  } catch (e:any) { fail(res, 500, e?.message || 'server error'); }
});

// ---------- LEASE ----------
rpc.get('/get_lease_card', async (req, res) => {
  try {
    const id = s(req.query.id ?? '').trim();
    if (!id) return fail(res, 400, 'missing id');

    const lease = await getOneByMulti(supabase, 'leases', id, ['doorloop_id']);
    if (!lease) return fail(res, 404, 'lease not found');

    const unit = lease?.unit_id
      ? (await supabase.from('units').select('*').eq('id', lease.unit_id).limit(1)).data?.[0] ?? null
      : null;
    const property = lease?.property_id
      ? (await supabase.from('properties').select('*').eq('id', lease.property_id).limit(1)).data?.[0] ?? null
      : null;
    const tenant = lease?.tenant_id
      ? (await supabase.from('tenants').select('*').eq('id', lease.tenant_id).limit(1)).data?.[0] ?? null
      : null;

    return ok(res, {
      lease: {
        id: n(lease.id),
        status: s(lease.status, 'UNKNOWN'),
        rentCents: n(lease.rent_cents ?? cents(lease.rent), 0),
        start: s(lease.start ?? lease.start_date ?? ''),
        end: s(lease.end ?? lease.end_date ?? ''),
      },
      unit: unit ? { id: n(unit.id), label: s(unit.unit_label ?? unit.unit_number ?? unit.name) } : null,
      tenant: tenant ? { id: n(tenant.id), display_name: s(tenant.display_name ?? tenant.name) } : null,
      property: property ? { id: n(property.id), name: s(property.name) } : null,
    });
  } catch (e:any) { fail(res, 500, e?.message || 'server error'); }
});

// ---------- OWNER ----------
rpc.get('/get_owner_card', async (req, res) => {
  try {
    const id = s(req.query.id ?? '').trim();
    if (!id) return fail(res, 400, 'missing id');

    const owner = await getOneByMulti(supabase, 'owners', id, ['doorloop_owner_id']);
    if (!owner) return fail(res, 404, 'owner not found');

    // Try both potential FK variants: owner_id or ownerid
    const p1 = await supabase.from('properties').select('id,name,address1,city,state,zip').eq('owner_id', owner.id);
    const p2 = await supabase.from('properties').select('id,name,address1,city,state,zip').eq('ownerid', owner.id);
    const rows = (p1.data || []).concat(p2.data || []);

    return ok(res, {
      owner: { id: n(owner.id), display_name: s(owner.display_name ?? owner.name) },
      properties: rows.map((p:any) => ({
        id: n(p.id), name: s(p.name), address: addrFrom(p),
      })),
    });
  } catch (e:any) { fail(res, 500, e?.message || 'server error'); }
});

// ---------- TENANT ----------
rpc.get('/get_tenant_card', async (req, res) => {
  try {
    const id = s(req.query.id ?? '').trim();
    if (!id) return fail(res, 400, 'missing id');

    const tenant = await getOneByMulti(supabase, 'tenants', id, ['doorloop_tenant_id']);
    if (!tenant) return fail(res, 404, 'tenant not found');

    const leases = (await supabase.from('leases')
      .select('id,status,unit_id,property_id,tenant_id,rent_cents,rent,start,end')
      .eq('tenant_id', tenant.id)).data || [];

    const active = leases.find((x:any) => String(x?.status).toUpperCase() === 'ACTIVE') ?? null;

    return ok(res, {
      tenant: { id: n(tenant.id), display_name: s(tenant.display_name ?? tenant.name) },
      leases: leases.map((L:any) => ({
        id: n(L.id), status: s(L.status, 'UNKNOWN'),
        rentCents: n(L.rent_cents ?? cents(L.rent), 0),
        unit_id: n(L.unit_id, 0), property_id: n(L.property_id, 0),
      })),
      activeLease: active ? {
        id: n(active.id), status: s(active.status, 'UNKNOWN'),
        rentCents: n(active.rent_cents ?? cents(active.rent), 0)
      } : null,
    });
  } catch (e:any) { fail(res, 500, e?.message || 'server error'); }
});


Prove (raw JSON + assertions):

IDS=$(curl -s http://localhost:8787/api/rpc/diag/ids)
echo "$IDS" | jq .

PID=$(echo "$IDS" | jq -r '.property')
UID=$(echo "$IDS" | jq -r '.unit')
LID=$(echo "$IDS" | jq -r '.lease')
OID=$(echo "$IDS" | jq -r '.owner')
TID=$(echo "$IDS" | jq -r '.tenant')

echo "== property ==" && curl -s "http://localhost:8787/api/rpc/get_property_card?id=${PID}" | tee /tmp/prop.json | jq .
echo "== unit =="     && curl -s "http://localhost:8787/api/rpc/get_unit_card?id=${UID}"   | tee /tmp/unit.json | jq .
echo "== lease =="    && curl -s "http://localhost:8787/api/rpc/get_lease_card?id=${LID}"  | tee /tmp/lease.json | jq .
echo "== owner =="    && curl -s "http://localhost:8787/api/rpc/get_owner_card?id=${OID}"  | tee /tmp/owner.json | jq .
echo "== tenant =="   && curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=${TID}" | tee /tmp/tenant.json | jq .

echo "ASSERTS:"
jq -e 'has("property") and has("kpis") and (.kpis.units|type=="number") and (.property.type|type=="string")' /tmp/prop.json && echo PROP_OK || echo PROP_FAIL
jq -e 'has("unit") and has("property") and has("lease")' /tmp/unit.json && echo UNIT_OK || echo UNIT_FAIL
jq -e 'has("lease") and has("unit") and has("tenant") and has("property")' /tmp/lease.json && echo LEASE_OK || echo LEASE_FAIL
jq -e 'has("owner") and has("properties") and (.properties|type=="array")' /tmp/owner.json && echo OWNER_OK || echo OWNER_FAIL
jq -e 'has("tenant") and has("leases") and (.leases|type=="array") and has("activeLease")' /tmp/tenant.json && echo TENANT_OK || echo TENANT_FAIL


If any assertion prints FAIL, fix and re-prove before Step 3.

STEP 3 — Frontend Contract (Zod) aligned to the new shapes

Task: Create src/contracts/cards.ts with these exact Zod schemas and type exports. Use them in the card pages.

// src/contracts/cards.ts
import { z } from 'zod';

export const AddressZ = z.object({
  line1: z.string().default(''),
  city:  z.string().default(''),
  state: z.string().default(''),
  zip:   z.string().default(''),
});

export const PropertyCardZ = z.object({
  property: z.object({
    id: z.number(),
    name: z.string().default(''),
    type: z.string().default('UNKNOWN'),
    address: AddressZ,
  }),
  kpis: z.object({
    units: z.number().default(0),
    activeLeases: z.number().default(0),
    occupancyPct: z.number().default(0),
    avgRentCents: z.number().nullable().default(null),
  }),
});
export type PropertyCard = z.infer<typeof PropertyCardZ>;

export const UnitCardZ = z.object({
  unit: z.object({
    id: z.number(),
    label: z.string().default(''),
    beds: z.number().default(0),
    baths: z.number().default(0),
    sqft: z.number().default(0),
    status: z.string().default('UNKNOWN'),
  }),
  property: z.object({
    id: z.number(),
    name: z.string().default(''),
    address: AddressZ,
  }).nullable().default(null),
  lease: z.object({
    id: z.number(),
    status: z.string().default('UNKNOWN'),
    rentCents: z.number().default(0),
  }).nullable().default(null),
});
export type UnitCard = z.infer<typeof UnitCardZ>;

export const LeaseCardZ = z.object({
  lease: z.object({
    id: z.number(),
    status: z.string().default('UNKNOWN'),
    rentCents: z.number().default(0),
    start: z.string().default(''),
    end: z.string().default(''),
  }),
  unit: z.object({ id: z.number(), label: z.string().default('') }).nullable().default(null),
  tenant: z.object({ id: z.number(), display_name: z.string().default('') }).nullable().default(null),
  property: z.object({ id: z.number(), name: z.string().default('') }).nullable().default(null),
});
export type LeaseCard = z.infer<typeof LeaseCardZ>;

export const OwnerCardZ = z.object({
  owner: z.object({ id: z.number(), display_name: z.string().default('') }),
  properties: z.array(z.object({
    id: z.number(),
    name: z.string().default(''),
    address: AddressZ,
  })).default([]),
});
export type OwnerCard = z.infer<typeof OwnerCardZ>;

export const TenantCardZ = z.object({
  tenant: z.object({ id: z.number(), display_name: z.string().default('') }),
  leases: z.array(z.object({
    id: z.number(),
    status: z.string().default('UNKNOWN'),
    rentCents: z.number().default(0),
    unit_id: z.number().default(0),
    property_id: z.number().default(0),
  })).default([]),
  activeLease: z.object({
    id: z.number(),
    status: z.string().default('UNKNOWN'),
    rentCents: z.number().default(0)
  }).nullable().default(null),
});
export type TenantCard = z.infer<typeof TenantCardZ>;


Wire-up (each card page):

Fetch its RPC.

const data = Schema.parse(await response.json()).

Render using the parsed data. No additional defensive logic.

Prove: From the browser, open these six routes using the IDs from Step 2:

/portfolio/properties
/card/property/<PID>
/card/unit/<UID>
/card/lease/<LID>
/card/owner/<OID>
/card/tenant/<TID>


You must confirm all render with zero red overlays and no Zod violations.

DONE criteria (non-negotiable)

Step 1: Schema dump pasted.

Step 2: All five RPCs pass the jq assertions (PROP_OK, UNIT_OK, LEASE_OK, OWNER_OK, TENANT_OK).

Step 3: All six routes render with no contract errors.

If anything fails, fix it, re-run the exact proof commands, and paste the raw outputs.

Notes (so we stop going in circles)

The RPC layer is now the single place that coalesces nulls and constructs nested shapes. The frontend just parses & renders.

property.type must always be a string; we default to 'UNKNOWN'.

kpis.units must always be a number; we default to 0.

Any missing relation returns null (object) or [] (collections) — never undefined.

Execute now.