REPLIT: Portfolio V3 — Final Data Fix (Relationship-Driven)

ROLE: Senior full-stack dev.
Goal: Stop guessing field paths. Implement a relationship-driven, backend-first mapping so every Portfolio V3 table (Properties, Units, Leases, Tenants, Owners) is fully populated from our normalized DB exactly per the relationship pack.
Guardrails (do NOT break):

❌ No CSS/theme/UX changes.

❌ No routing/links/menus changes.

❌ No DataTable component changes.

✅ Only touch server/API, light utils, and strictly limited column renderers if a field name has to change to match API.

✅ Keep existing Altus “Genesis” styling and DataTable behavior intact.

0) Sources of truth (MUST use these)

/mnt/data/DoorLoop API - Relationships.docx (relationship glossary)

/mnt/data/empire_schema_pack.zip (schema & FK plan; unzip and use)

Build the mapping from these—not from current frontend columns.

1) Set up a canonical field map (single place)

Create server/mappings/portfolio_map.py with explicit DB→API mappings per entity. Use the names below (camelCase in API). No inference, no front-end fallbacks.

# server/mappings/portfolio_map.py
from typing import TypedDict, List

class PropertyOut(TypedDict):
    id: int
    name: str
    type: str
    class_: str  # map as "class" in JSON
    state: str | None
    city: str | None
    zip: str | None
    units: int
    occPct: float
    active: bool

class UnitOut(TypedDict):
    id: int
    propertyName: str
    unitLabel: str
    beds: float | int | None
    baths: float | int | None
    sqft: float | int | None
    status: str | None
    marketRent: float | int | None

class LeaseOut(TypedDict):
    id: int
    propertyName: str
    unitLabel: str
    tenants: List[str]
    status: str
    start: str | None
    end: str | None
    rent: float | int | None  # dollars

class TenantOut(TypedDict):
    id: int
    name: str
    email: str | None
    phone: str | None
    propertyName: str | None
    unitLabel: str | None
    type: str
    balance: float | int | None

class OwnerOut(TypedDict):
    id: int
    company: str
    email: str | None
    phone: str | None
    active: bool


Note: class_ is emitted as "class" in JSON (don’t collide with Python keyword).

2) Implement backend-only resolvers (no frontend joins)

Create/replace these handlers to select from normalized tables only (per schema pack), with safe ID normalization and relationship joins. File locations: server/routes/portfolio/*.py.

2.1 Properties
# server/routes/portfolio/properties.py
from flask import Blueprint, jsonify, request
from psycopg2.extras import RealDictCursor
from server.db import get_conn
from server.mappings.portfolio_map import PropertyOut

bp = Blueprint("properties_api", __name__)

@bp.get("/api/portfolio/properties")
def get_properties():
    with get_conn() as conn, conn.cursor(cursor_factory=RealDictCursor) as cur:
        # Units + occupancy derived on the server, never in FE.
        cur.execute("""
        SELECT
          p.id,
          p.name,
          p.type,
          p.class AS class_,
          p.address_state AS state,
          p.address_city AS city,
          COALESCE(p.address_zip, p.zipcode, p.postal_code) AS zip,
          COALESCE(p.unit_count, COUNT(u.id))::int AS units,
          COALESCE(
            p.occupancy_rate,
            CASE WHEN COUNT(u.id) = 0 THEN 0
                 ELSE ROUND(100.0 * SUM(CASE WHEN u.status ILIKE 'occupied' THEN 1 ELSE 0 END)::numeric
                            / NULLIF(COUNT(u.id),0), 1)
            END
          )::float AS occPct,
          COALESCE(p.active, false) AS active
        FROM properties p
        LEFT JOIN units u ON u.property_id = p.id
        GROUP BY p.id
        ORDER BY p.name ASC;
        """)
        rows = cur.fetchall()
        # Emit "class" (not class_) and keep other keys as-is
        out = []
        for r in rows:
            d: PropertyOut = {
                "id": r["id"],
                "name": r["name"],
                "type": r.get("type"),
                "class": r.get("class_"),
                "state": r.get("state"),
                "city": r.get("city"),
                "zip": r.get("zip"),
                "units": r.get("units", 0),
                "occPct": float(r.get("occPct") or 0),
                "active": bool(r.get("active")),
            }
            out.append(d)
        return jsonify(out)

2.2 Units
# server/routes/portfolio/units.py
from flask import Blueprint, jsonify
from psycopg2.extras import RealDictCursor
from server.db import get_conn
from server.mappings.portfolio_map import UnitOut

bp = Blueprint("units_api", __name__)

@bp.get("/api/portfolio/units")
def get_units():
    with get_conn() as conn, conn.cursor(cursor_factory=RealDictCursor) as cur:
        cur.execute("""
        SELECT
          u.id,
          p.name AS property_name,
          COALESCE(u.unit_number, u.label, u.name, '') AS unit_label,
          u.beds,
          u.baths,
          COALESCE(u.sq_ft, u.square_feet) AS sqft,
          u.status,
          COALESCE(u.rent_amount, 0) AS market_rent
        FROM units u
        LEFT JOIN properties p ON p.id = u.property_id
        ORDER BY p.name, unit_label;
        """)
        rows = cur.fetchall()
        out = [{
            "id": r["id"],
            "propertyName": r["property_name"] or "—",
            "unitLabel": r["unit_label"] or "—",
            "beds": r["beds"],
            "baths": r["baths"],
            "sqft": r["sqft"],
            "status": r["status"],
            "marketRent": r["market_rent"],
        } for r in rows]
        return jsonify(out)

2.3 Leases
# server/routes/portfolio/leases.py
from flask import Blueprint, jsonify
from psycopg2.extras import RealDictCursor
from server.db import get_conn

bp = Blueprint("leases_api", __name__)

@bp.get("/api/portfolio/leases")
def get_leases():
    with get_conn() as conn, conn.cursor(cursor_factory=RealDictCursor) as cur:
        # primary + secondary tenants via UNION/ARRAY_AGG if link table exists; fall back to single tenant_id.
        cur.execute("""
        WITH ten AS (
          SELECT l.id AS lease_id,
                 ARRAY_REMOVE(ARRAY[
                   t1.display_name, t1.full_name, t1.name
                 ], NULL) AS names1,
                 ARRAY_AGG(DISTINCT COALESCE(t2.display_name, t2.full_name, t2.name)) FILTER (WHERE t2.id IS NOT NULL) AS names2
          FROM leases l
          LEFT JOIN tenants t1 ON t1.id = l.tenant_id
          LEFT JOIN lease_tenants lt ON lt.lease_id = l.id
          LEFT JOIN tenants t2 ON t2.id = lt.tenant_id
          GROUP BY l.id, t1.display_name, t1.full_name, t1.name
        )
        SELECT
          l.id,
          p.name AS property_name,
          COALESCE(u.unit_number, u.label, u.name) AS unit_label,
          COALESCE(l.status,'unknown') AS status,
          l.start_date AS start,
          l.end_date AS "end",
          COALESCE(l.total_recurring_rent, l.rent_cents/100.0, 0) AS rent,
          ARRAY_REMOVE(ARRAY_CAT(
            COALESCE(ten.names2, ARRAY[]::text[]),
            COALESCE(ten.names1, ARRAY[]::text[])
          ), NULL) AS tenants
        FROM leases l
        LEFT JOIN properties p ON p.id = l.property_id
        LEFT JOIN units u ON u.id = l.unit_id
        LEFT JOIN ten ON ten.lease_id = l.id
        ORDER BY p.name, unit_label, start;
        """)
        rows = cur.fetchall()
        out = [{
            "id": r["id"],
            "propertyName": r["property_name"] or "—",
            "unitLabel": r["unit_label"] or "—",
            "tenants": r["tenants"] or [],
            "status": r["status"],
            "start": r["start"].isoformat() if r["start"] else None,
            "end": r["end"].isoformat() if r["end"] else None,
            "rent": r["rent"],
        } for r in rows]
        return jsonify(out)

2.4 Tenants
# server/routes/portfolio/tenants.py
from flask import Blueprint, jsonify
from psycopg2.extras import RealDictCursor
from server.db import get_conn

bp = Blueprint("tenants_api", __name__)

@bp.get("/api/portfolio/tenants")
def get_tenants():
    with get_conn() as conn, conn.cursor(cursor_factory=RealDictCursor) as cur:
        # latest lease for context
        cur.execute("""
        WITH latest AS (
          SELECT DISTINCT ON (t.id)
                 t.id AS tenant_id, l.id AS lease_id, l.start_date, l.status,
                 p.name AS property_name,
                 COALESCE(u.unit_number, u.label, u.name) AS unit_label
          FROM tenants t
          LEFT JOIN leases l ON l.tenant_id = t.id
          LEFT JOIN properties p ON p.id = l.property_id
          LEFT JOIN units u ON u.id = l.unit_id
          ORDER BY t.id, l.start_date DESC NULLS LAST
        )
        SELECT
          t.id,
          COALESCE(t.display_name, t.full_name, t.first_name || ' ' || t.last_name, '') AS name,
          COALESCE(t.primary_email,
                   (t.emails_json->0->>'address'),
                   t.email) AS email,
          COALESCE(t.primary_phone,
                   (t.phones_json->0->>'number')) AS phone,
          COALESCE(t.type, 'PROSPECT_TENANT') AS type,
          COALESCE(t.balance, 0) AS balance,
          latest.property_name,
          latest.unit_label
        FROM tenants t
        LEFT JOIN latest ON latest.tenant_id = t.id
        ORDER BY name;
        """)
        rows = cur.fetchall()
        out = [{
            "id": r["id"],
            "name": r["name"] or "—",
            "email": r["email"],
            "phone": r["phone"],
            "propertyName": r["property_name"],
            "unitLabel": r["unit_label"],
            "type": r["type"],
            "balance": r["balance"],
        } for r in rows]
        return jsonify(out)

2.5 Owners
# server/routes/portfolio/owners.py
from flask import Blueprint, jsonify
from psycopg2.extras import RealDictCursor
from server.db import get_conn

bp = Blueprint("owners_api", __name__)

@bp.get("/api/portfolio/owners")
def get_owners():
    with get_conn() as conn, conn.cursor(cursor_factory=RealDictCursor) as cur:
        cur.execute("""
        SELECT
          o.id,
          COALESCE(o.company_name, o.display_name, o.full_name, '—') AS company,
          COALESCE(o.primary_email, (o.emails_json->0->>'address')) AS email,
          COALESCE(o.primary_phone, (o.phones_json->0->>'number')) AS phone,
          COALESCE(o.active, false) AS active
        FROM owners o
        ORDER BY company;
        """)
        rows = cur.fetchall()
        out = [{
            "id": r["id"],
            "company": r["company"],
            "email": r["email"],
            "phone": r["phone"],
            "active": r["active"],
        } for r in rows]
        return jsonify(out)


Register these blueprints in your API app if not already.

3) Utils: normalize IDs, money(0) semantics (server)

If not present, add a tiny normalizer and ensure zero-money is preserved (server side too):

# server/utils/ids.py
def normalize_id(v):
    return None if v is None else str(v).strip()


(Frontend already fixed money(0); keep server values numeric and let FE format.)

4) Lightweight debug endpoints (read-only)

Add a tiny debug route to see exact rows we emit to the FE:

# server/routes/portfolio/debug.py
from flask import Blueprint, jsonify, request
from psycopg2.extras import RealDictCursor
from server.db import get_conn

bp = Blueprint("portfolio_debug", __name__)

@bp.get("/api/portfolio/_debug/sql")
def debug_sql():
    q = request.args.get("q", "")
    limit = min(int(request.args.get("limit", "10") or 10), 50)
    if not q.lower().startswith("select"):
        return jsonify({"error":"SELECT only"}), 400
    with get_conn() as conn, conn.cursor(cursor_factory=RealDictCursor) as cur:
        cur.execute(f"{q} LIMIT {limit}")
        return jsonify(cur.fetchall())


Strictly SELECT-only; use for quick snapshots while validating mappings.

5) Frontend: do not join; only rename fields if needed

Ensure columns renderers consume exact field names above:

Properties: name, type, class, state, city, zip, units, occPct, active

Units: propertyName, unitLabel, beds, baths, sqft, status, marketRent

Leases: propertyName, unitLabel, tenants[], status, start, end, rent

Tenants: name, email, phone, propertyName, unitLabel, type, balance

Owners: company (render <strong>), email, phone, active

Remove any remaining getPath()/fallback logic from FE mappers for these pages; the backend now guarantees shape.

6) Verification script (must pass)

Create scripts/audit_portfolio_data.ts (Node) to hit our endpoints and assert coverage:

// scripts/audit_portfolio_data.ts
import fetch from "node-fetch";

type Check = { name: string; url: string; keys: string[]; min: number };

const checks: Check[] = [
  { name: "properties", url: "http://localhost:5000/api/portfolio/properties", keys: ["name","zip","units","occPct","active"], min: 150 },
  { name: "units",      url: "http://localhost:5000/api/portfolio/units",      keys: ["propertyName","unitLabel","beds","baths","sqft","status","marketRent"], min: 150 },
  { name: "leases",     url: "http://localhost:5000/api/portfolio/leases",     keys: ["propertyName","unitLabel","tenants","status","start","end","rent"], min: 80 },
  { name: "tenants",    url: "http://localhost:5000/api/portfolio/tenants",    keys: ["name","type","email","phone","propertyName","unitLabel","balance"], min: 40 },
  { name: "owners",     url: "http://localhost:5000/api/portfolio/owners",     keys: ["company","email","phone","active"], min: 30 },
];

(async () => {
  let ok = true;
  for (const c of checks) {
    const res = await fetch(c.url);
    const data = await res.json();
    const count = Array.isArray(data) ? data.length : 0;
    const hasKeys = count > 0 && c.keys.every(k => k in data[0]);
    console.log(`${c.name}: items=${count} keys=${hasKeys}`);
    if (count < c.min || !hasKeys) ok = false;
  }
  process.exit(ok ? 0 : 1);
})();


Run:

node scripts/audit_portfolio_data.ts

7) DB-level sanity checks (must match what you see in UI)

Run and paste counts back to console:

-- counts must be non-zero and sensible
SELECT COUNT(*) FROM properties;
SELECT COUNT(*) FROM units;
SELECT COUNT(*) FROM leases;
SELECT COUNT(*) FROM tenants;
SELECT COUNT(*) FROM owners;

-- KPI parity checks
-- total units on properties KPI must equal COUNT(units)
SELECT SUM(x.units) AS total_units
FROM (
  SELECT p.id, COALESCE(p.unit_count, COUNT(u.id)) AS units
  FROM properties p LEFT JOIN units u ON u.property_id = p.id
  GROUP BY p.id
) x;

-- monthly revenue: sum of active lease rent (dollars)
SELECT ROUND(SUM(COALESCE(l.total_recurring_rent, l.rent_cents/100.0, 0))::numeric, 2)
FROM leases l
WHERE l.status ILIKE 'active';

8) Acceptance criteria (block merge if any fail)

Every table row shows real values (no “—”) except when truly NULL from DB.

KPI cards line up with DB queries above.

Tenants show names + types; property/unit context present for those with leases.

Owners show bold company, active pill, email/phone when present.

No front-end joins/fallbacks remain on these five pages.

scripts/audit_portfolio_data.ts exits with code 0.

Commit: feat(portfolio): relationship-driven API mapping; zero-guess data for Properties/Units/Leases/Tenants/Owners

9) If any field is still missing

Use /api/portfolio/_debug/sql?q=SELECT+*+FROM+<table> to inspect real rows and adjust the server SQL only.

Update server/mappings/portfolio_map.py and the corresponding route.

Never add new FE fallbacks for these pages.

Run this plan now. When done, post:

The audit script output

The 5 endpoint sample item (first row from each)

The SQL KPI parity numbers (units total + monthly revenue)

This locks us to the relationship map and ends guesswork.