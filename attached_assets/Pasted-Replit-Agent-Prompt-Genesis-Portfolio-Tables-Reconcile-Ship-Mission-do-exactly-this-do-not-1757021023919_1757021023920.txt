Replit Agent Prompt — “Genesis Portfolio Tables: Reconcile & Ship”

Mission (do exactly this; do not drift):

We’re running a React + Vite + TypeScript app. Our portfolio pages work but some columns show the wrong fields or are missing fields. You will reconcile the table data for all 5 pages using the live collection payloads and only modify the files listed below. Do not change the theme or app structure.

Guardrails (non-negotiable)

Do not modify global styles, theme tokens, Tailwind config, or any non-table components.

Do not change routes, side nav styles, or page layouts beyond table columns.

Do not rename exported symbols that pages already import (keep the same named exports).

Keep DataTable props and API stable.

Keep pagination control at the bottom (already working).

No extra dependencies.

Produce small, readable commits.

Files you may touch

src/pages/portfolio/columns.tsx (columns + mappers only)

src/pages/portfolio/properties/index.tsx

src/pages/portfolio/units/index.tsx

src/pages/portfolio/leases/index.tsx

src/pages/portfolio/tenants/index.tsx

src/pages/portfolio/owners/index.tsx

src/utils/format.ts (only if a helper is missing; keep current exports)

Do not edit anything else.

Acceptance criteria (all must pass)

Data shows correctly on all 5 tables with proper values (no “—” where data exists).

Columns (names & order) match the specs below.

Sorting works on all sortable columns (text & numeric).

Filters work (text contains; number min/max; select lists where noted).

Row double-click navigates to the asset card (properties/units/leases/tenants/owners).

Owners table shows Company, Email, Phone, Active and NOT a property list column.

Tenants table shows actual tenants and prospects, with the ability to filter by Type (primary, secondary, prospect).

Properties table includes ZIP and Occupancy progress rendering (keep current bar).

Units table includes Beds, Baths, SQFT, Status, Market Rent.

Leases table includes Tenant(s) (joined), Property, Unit, Status, Start, End, Rent.

No TS errors, no console errors.

Step 1 — Inspect live collection shapes (read-only)

Open each page, then in devtools log the first item returned by the page’s collection hook so we can map accurately.

Add temporary logs (and then remove them):

// Add at top of each page inside the component, just after data load:
if (rows && rows.length) {
  console.debug("AUDIT/<entity>", rows[0], JSON.parse(JSON.stringify(rows[0])));
}


Entities:

properties

units

leases

tenants

owners

From these logs, confirm the actual key paths for:

Properties: id, display name/address, type, class, state, city, zip, totalUnits, occupiedUnits or occupancyPct, active flag.

Units: id, property (name/address), unit label, beds, baths, sqft, status, marketRent.

Leases: id, property name, unit label, tenant names array, status, start, end, rent.

Tenants: id, full name, email, phone, property name, unit label, type (primary|secondary|prospect), balance.

Owners: id, company (or owner name if individual), email, phone, active flag, propertiesCount (for KPIs only, not a table column).

Use optional chaining and fallbacks only where the data truly doesn’t exist. If a field exists under a different key, map it.

Step 2 — Centralize safe getters & formatters

In src/utils/format.ts ensure we have (or add if missing) these non-breaking helpers:

export const dash = "—";

// Safe getter by path: get(obj, "a.b.c", default)
export function getPath<T = any>(obj: any, path: string, d?: T): T | undefined {
  try {
    return path.split(".").reduce<any>((v, k) => (v == null ? v : v[k]), obj) ?? d;
  } catch { return d; }
}

// Basic formatters (keep existing ones; add only if missing)
export function money(n?: number | null) {
  const v = typeof n === "number" ? n : 0;
  return v.toLocaleString(undefined, { style: "currency", currency: "USD", maximumFractionDigits: 0 });
}
export function percent(n?: number | null) {
  if (n == null || Number.isNaN(n)) return "0%";
  return `${Math.round(n)}%`;
}
export function shortDate(iso?: string | null) {
  if (!iso) return dash;
  const d = new Date(iso);
  return Number.isNaN(+d) ? dash : d.toISOString().slice(0,10);
}
export function boolBadge(ok?: boolean | null) {
  const isTrue = !!ok;
  const cls = isTrue ? "ecc-badge ecc-badge--ok" : "ecc-badge ecc-badge--bad";
  return <span className={cls}>{isTrue ? "ACTIVE" : "INACTIVE"}</span>;
}

Step 3 — Fix columns.tsx (mappers + column defs)

Open src/pages/portfolio/columns.tsx. Keep any exports other pages import. Implement both a mapper and a column array per entity.

For each mapper, use the real key paths found in Step 1. Use getPath for safety but do not mask real fields with dash if present under a different key.

3A. Properties

Desired columns (left→right):

Property (display string; address or name)

Type (domain enum string)

Class (e.g., RESIDENTIAL)

State

City

ZIP

Units (number; right-aligned; numeric sort)

Occupancy (progress bar; numeric sort; also show %)

Active (badge; select filter: All/Active/Inactive)

Mapper (example; replace key paths with correct ones):

export type PropertyRow = {
  id: string;
  name: string;
  type: string;
  class: string;
  state: string;
  city: string;
  zip: string;
  units: number;
  occPct: number; // 0..100
  active: boolean;
};

export function mapProperty(src: any): PropertyRow {
  const units = Number(getPath(src, "units.total", 0)) || Number(getPath(src, "units", 0)) || 0;
  const occupied = Number(getPath(src, "units.occupied", 0)) || 0;
  const occPctFromFields = Number(getPath(src, "occupancyPct", NaN));
  const occPct = Number.isFinite(occPctFromFields)
    ? Math.max(0, Math.min(100, occPctFromFields))
    : (units > 0 ? Math.round((occupied / units) * 100) : 0);

  return {
    id: String(getPath(src, "id") ?? getPath(src, "_id")),
    name: String(getPath(src, "displayName") ?? getPath(src, "address.line1") ?? getPath(src, "name") ?? dash),
    type: String(getPath(src, "type") ?? dash),
    class: String(getPath(src, "class") ?? dash),
    state: String(getPath(src, "address.state") ?? getPath(src, "state") ?? dash),
    city: String(getPath(src, "address.city") ?? getPath(src, "city") ?? dash),
    zip: String(getPath(src, "address.zip") ?? getPath(src, "zip") ?? dash),
    units,
    occPct,
    active: !!getPath(src, "active"),
  };
}


Columns:

export const PROPERTY_COLUMNS = [
  { key: "name",  header: "PROPERTY", filter: "text", minWidth: 260 },
  { key: "type",  header: "TYPE",     filter: "text" },
  { key: "class", header: "CLASS",    filter: "text" },
  { key: "state", header: "STATE",    filter: "text", width: 80 },
  { key: "city",  header: "CITY",     filter: "text" },
  { key: "zip",   header: "ZIP",      filter: "text", width: 100 },
  { key: "units", header: "UNITS",    align: "right", sort: "numeric", filter: "numberRange", width: 90 },
  {
    key: "occPct", header: "OCCUPANCY", sort: "numeric",
    render: (r: any) => (
      <div className="ecc-occ">
        <div className="ecc-occ-bar"><div style={{width: `${r.occPct}%`}} /></div>
        <span className="ecc-occ-label">{percent(r.occPct)}</span>
      </div>
    ),
  },
  {
    key: "active", header: "ACTIVE",
    filter: { type: "select", options: ["All","Active","Inactive"], normalize: (v:any)=>v },
    render: (r:any)=> boolBadge(!!r.active),
  },
];

3B. Units

Columns:

Property, Unit, Beds, Baths, SQFT, Status, Market Rent

Mapper (fix paths):

export type UnitRow = {
  id: string;
  property: string;
  unit: string;
  beds: number;
  baths: number;
  sqft: number;
  status: string;
  marketRent: number;
};

export function mapUnit(src:any): UnitRow {
  return {
    id: String(getPath(src,"id") ?? getPath(src,"_id")),
    property: String(getPath(src,"property.displayName") ?? getPath(src,"property.name") ?? dash),
    unit: String(getPath(src,"label") ?? getPath(src,"unit") ?? dash),
    beds: Number(getPath(src,"beds",0)),
    baths: Number(getPath(src,"baths",0)),
    sqft: Number(getPath(src,"sqft",0)),
    status: String(getPath(src,"status") ?? dash),
    marketRent: Number(getPath(src,"marketRent",0)),
  };
}

export const UNIT_COLUMNS = [
  { key:"property", header:"PROPERTY", filter:"text", minWidth:260 },
  { key:"unit", header:"UNIT", filter:"text", width:120 },
  { key:"beds", header:"BEDS", align:"right", sort:"numeric", filter:"numberRange", width:80 },
  { key:"baths", header:"BATHS", align:"right", sort:"numeric", filter:"numberRange", width:90 },
  { key:"sqft", header:"SQFT", align:"right", sort:"numeric", filter:"numberRange" },
  { key:"status", header:"STATUS", filter:{type:"select", options:["All","Occupied","Vacant","Make-Ready","Down"]}},
  { key:"marketRent", header:"MARKET RENT", align:"right", sort:"numeric", filter:"numberRange",
    render:(r:any)=>money(r.marketRent) },
];

3C. Leases

Columns:

Property, Unit, Tenant(s), Status, Start, End, Rent

Mapper:

export type LeaseRow = {
  id: string;
  property: string;
  unit: string;
  tenants: string; // joined
  status: string;
  start: string;
  end: string;
  rent: number;
};

export function mapLease(src:any): LeaseRow {
  const names = (getPath<any[]>(src,"tenants") ?? [])
    .map(t => String(getPath(t,"fullName") ?? getPath(t,"name") ?? ""))
    .filter(Boolean)
    .join(", ");
  return {
    id: String(getPath(src,"id") ?? getPath(src,"_id")),
    property: String(getPath(src,"property.displayName") ?? getPath(src,"property.name") ?? dash),
    unit: String(getPath(src,"unit.label") ?? getPath(src,"unit") ?? dash),
    tenants: names || dash,
    status: String(getPath(src,"status") ?? dash),
    start: String(getPath(src,"startDate") ?? getPath(src,"start") ?? ""),
    end: String(getPath(src,"endDate") ?? getPath(src,"end") ?? ""),
    rent: Number(getPath(src,"rent",0)),
  };
}

export const LEASE_COLUMNS = [
  { key:"property", header:"PROPERTY", filter:"text", minWidth:260 },
  { key:"unit", header:"UNIT", filter:"text", width:120 },
  { key:"tenants", header:"TENANT(S)", filter:"text", minWidth:220 },
  { key:"status", header:"STATUS", filter:{type:"select", options:["All","active","ended","pending"]}},
  { key:"start", header:"START", sort:"text", render:(r:any)=>shortDate(r.start) },
  { key:"end", header:"END", sort:"text", render:(r:any)=>shortDate(r.end) },
  { key:"rent", header:"RENT", align:"right", sort:"numeric", filter:"numberRange", render:(r:any)=>money(r.rent) },
];

3D. Tenants

Columns:

Tenant, Email, Phone, Property, Unit, Type (primary|secondary|prospect), Balance

Mapper:

export type TenantRow = {
  id: string;
  name: string;
  email: string;
  phone: string;
  property: string;
  unit: string;
  type: "primary" | "secondary" | "prospect" | string;
  balance: number;
};

export function mapTenant(src:any): TenantRow {
  const type =
    (getPath(src,"type") ?? getPath(src,"role") ?? "").toString().toLowerCase() ||
    (!getPath(src,"leaseId") ? "prospect" : "primary");
  return {
    id: String(getPath(src,"id") ?? getPath(src,"_id")),
    name: String(getPath(src,"fullName") ?? getPath(src,"name") ?? dash),
    email: String(getPath(src,"email") ?? dash),
    phone: String(getPath(src,"phone") ?? getPath(src,"phoneNumber") ?? dash),
    property: String(getPath(src,"property.displayName") ?? getPath(src,"property.name") ?? dash),
    unit: String(getPath(src,"unit.label") ?? getPath(src,"unit") ?? dash),
    type: type as any,
    balance: Number(getPath(src,"balance",0)),
  };
}

export const TENANT_COLUMNS = [
  { key:"name", header:"TENANT", filter:"text", minWidth:200 },
  { key:"email", header:"EMAIL", filter:"text" },
  { key:"phone", header:"PHONE", filter:"text" },
  { key:"property", header:"PROPERTY", filter:"text", minWidth:220 },
  { key:"unit", header:"UNIT", filter:"text", width:120 },
  { key:"type", header:"TYPE", filter:{type:"select", options:["All","primary","secondary","prospect"]}},
  { key:"balance", header:"BALANCE", align:"right", sort:"numeric", filter:"numberRange",
    render:(r:any)=>money(r.balance) },
];

3E. Owners

Columns (no property list column):

Company (owner company or name), Email, Phone, Active

Mapper:

export type OwnerRow = {
  id: string;
  company: string;
  email: string;
  phone: string;
  active: boolean;
};

export function mapOwner(src:any): OwnerRow {
  const company = String(
    getPath(src,"company") ??
    getPath(src,"companyName") ??
    getPath(src,"name") ??
    getPath(src,"ownerName") ??
    dash
  );
  return {
    id: String(getPath(src,"id") ?? getPath(src,"_id")),
    company,
    email: String(getPath(src,"email") ?? dash),
    phone: String(getPath(src,"phone") ?? getPath(src,"phoneNumber") ?? dash),
    active: !!getPath(src,"active"),
  };
}

export const OWNER_COLUMNS = [
  { key:"company", header:"COMPANY", filter:"text", minWidth:240 },
  { key:"email", header:"EMAIL", filter:"text" },
  { key:"phone", header:"PHONE", filter:"text" },
  { key:"active", header:"ACTIVE",
    filter:{type:"select", options:["All","Active","Inactive"]},
    render:(r:any)=>boolBadge(!!r.active) },
];

Step 4 — Wire up double-click navigation

Open each page’s index.tsx and pass rowHref or onRowDoubleClick (whichever DataTable supports) to navigate to the asset card. Do not change layout or theme.

Examples (adjust route to existing conventions):

// properties/index.tsx
<DataTable
  rows={propsRows}
  columns={PROPERTY_COLUMNS}
  getRowId={(r)=>r.id}
  onRowDoubleClick={(r)=> navigate(`/portfolio/properties/${r.id}`)}
/>

// units
onRowDoubleClick={(r)=> navigate(`/portfolio/units/${r.id}`)}

// leases
onRowDoubleClick={(r)=> navigate(`/portfolio/leases/${r.id}`)}

// tenants
onRowDoubleClick={(r)=> navigate(`/portfolio/tenants/${r.id}`)}

// owners
onRowDoubleClick={(r)=> navigate(`/portfolio/owners/${r.id}`)}


If rowHref is the supported prop instead:

rowHref={(r)=> `/portfolio/<entity>/${r.id}`}

Step 5 — Verify filters & sorting

Text columns: filter: "text"

Numbers: filter: "numberRange", sort: "numeric", right-align

Selects: use filter: { type: "select", options:[...] }

Confirm:

Properties: state/city/zip text filters work; units numeric; occupancy numeric; active select.

Units: beds/baths/sqft/rent numeric; status select.

Leases: status select; start/end dates rendered; rent numeric.

Tenants: type select; balance numeric.

Owners: active select.

Step 6 — Remove temporary logs and run final checks

No console errors or TypeScript errors.

All five pages show >0 results from the existing data source.

Double-click opens the correct route.

Do not alter table/theme styling.

Commit with message:

feat(portfolio): reconcile table mappers & columns for properties/units/leases/tenants/owners; add ZIP, owner company/email/phone; tenant type; fix sorting/filters; enable double-click nav (no style changes)

Notes / Hints you may need while mapping

If a value is an enum object, render the label string (not the raw object).

If property has address pieces, build displayName = line1, City, ST ZIP when displayName isn’t provided.

Tenants: determine type as:

explicit type/role field if present,

otherwise prospect when no leaseId,

otherwise default primary.

Leases: if tenants is a single object instead of an array, normalize to array.

End of prompt.