1) Schema migration (Supabase SQL)

Adds the minimal DoorLoop keys + missing FKs the RPCs expect. Safe to run multiple times.

-- === PROPERTIES ===
ALTER TABLE public.properties
  ADD COLUMN IF NOT EXISTS doorloop_id text,
  ADD COLUMN IF NOT EXISTS owner_id bigint;

CREATE INDEX IF NOT EXISTS idx_properties_doorloop_id ON public.properties(doorloop_id);
CREATE INDEX IF NOT EXISTS idx_properties_owner_id     ON public.properties(owner_id);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'fk_properties_owner'
  ) THEN
    ALTER TABLE public.properties
      ADD CONSTRAINT fk_properties_owner
      FOREIGN KEY (owner_id) REFERENCES public.owners(id) ON DELETE SET NULL;
  END IF;
END$$;

-- === UNITS ===
ALTER TABLE public.units
  ADD COLUMN IF NOT EXISTS doorloop_id text;

CREATE INDEX IF NOT EXISTS idx_units_doorloop_id ON public.units(doorloop_id);

-- === LEASES ===
ALTER TABLE public.leases
  ADD COLUMN IF NOT EXISTS doorloop_id text,
  ADD COLUMN IF NOT EXISTS tenant_id  bigint,
  ADD COLUMN IF NOT EXISTS unit_id    bigint;

CREATE INDEX IF NOT EXISTS idx_leases_doorloop_id ON public.leases(doorloop_id);
CREATE INDEX IF NOT EXISTS idx_leases_tenant_id   ON public.leases(tenant_id);
CREATE INDEX IF NOT EXISTS idx_leases_unit_id     ON public.leases(unit_id);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'fk_leases_tenant'
  ) THEN
    ALTER TABLE public.leases
      ADD CONSTRAINT fk_leases_tenant
      FOREIGN KEY (tenant_id) REFERENCES public.tenants(id) ON DELETE SET NULL;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'fk_leases_unit'
  ) THEN
    ALTER TABLE public.leases
      ADD CONSTRAINT fk_leases_unit
      FOREIGN KEY (unit_id) REFERENCES public.units(id) ON DELETE SET NULL;
  END IF;
END$$;

-- === TENANTS ===
ALTER TABLE public.tenants
  ADD COLUMN IF NOT EXISTS doorloop_tenant_id text;
CREATE INDEX IF NOT EXISTS idx_tenants_doorloop_tenant_id ON public.tenants(doorloop_tenant_id);

-- === OWNERS ===
ALTER TABLE public.owners
  ADD COLUMN IF NOT EXISTS doorloop_owner_id text;
CREATE INDEX IF NOT EXISTS idx_owners_doorloop_owner_id ON public.owners(doorloop_owner_id);


Backfill can be done later, deterministically (e.g., import DoorLoop IDs). The app works with NULL keys; they’re used only for secondary (dual-key) lookups.

2) RPC hardening (server/routes/rpc.ts)
2.1 Add a multi-field dual-key helper (top of file)
async function fetchOneMulti(
  sb: any,
  table: string,
  id: string | number,
  altFields: string[] // e.g., ["doorloop_unit_id","doorloop_id"]
) {
  const v = String(id);
  const ors = ["id.eq." + v, ...altFields.map(f => `${f}.eq.${v}`)].join(",");
  const { data, error } = await sb.from(table).select("*").or(ors).limit(1).maybeSingle();
  if (error) throw error;
  return data ?? null;
}
const norm = (s:any) => String(s ?? "").toLowerCase();

2.2 Property card (ensure kpIs include avgRentCents)
app.get("/api/rpc/get_property_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    // Try by id, doorloop_property_id, or doorloop_id
    const property = await fetchOneMulti(supabase, "properties", id, ["doorloop_property_id","doorloop_id"]);
    if (!property) return res.status(404).json({ error: "property not found", id });

    const { data: units = [] }  = await supabase.from("units").select("*").eq("property_id", property.id);
    const { data: leases = [] } = await supabase.from("leases").select("*").eq("property_id", property.id);

    const active = leases.filter((l:any)=> norm(l.status) === "active");
    const unitsCount   = units.length;
    const activeCount  = active.length;
    const occupancyPct = unitsCount ? Math.round((activeCount/unitsCount)*1000)/10 : 0;

    const rents = active
      .map((l:any)=> Number(l.rent_cents ?? l.rent ?? 0))
      .filter((n:number)=> Number.isFinite(n) && n >= 0);
    const avgRentCents = rents.length ? Math.round(rents.reduce((a:number,b:number)=>a+b,0)/rents.length) : null;

    return res.json({
      property: { ...property, ...mapAddress(property) },
      units, leases,
      kpis: { units: unitsCount, activeLeases: activeCount, occupancyPct, avgRentCents }
    });
  } catch (e:any) {
    console.error("[rpc:get_property_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

2.3 Unit card (robust keys, JSON errors)
app.get("/api/rpc/get_unit_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const unit = await fetchOneMulti(supabase, "units", id, ["doorloop_unit_id","doorloop_id"]);
    if (!unit) return res.status(404).json({ error: "unit not found", id });

    const property = unit.property_id
      ? await fetchOneMulti(supabase, "properties", unit.property_id, ["doorloop_property_id","doorloop_id"])
      : null;

    const { data: leaseRows, error: lerr } = await supabase
      .from("leases").select("*")
      .or(`unit_id.eq.${unit.id},doorloop_unit_id.eq.${unit.doorloop_unit_id ?? ""}`);
    if (lerr) throw lerr;
    const lease = leaseRows?.[0] ?? null;

    const tenant = lease?.tenant_id
      ? await fetchOneMulti(supabase, "tenants", lease.tenant_id, ["doorloop_tenant_id"])
      : null;

    return res.json({ unit, property: property ? { ...property, ...mapAddress(property)} : null, lease, tenant });
  } catch (e:any) {
    console.error("[rpc:get_unit_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

2.4 Lease card (robust keys, relationships)
app.get("/api/rpc/get_lease_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const lease = await fetchOneMulti(supabase, "leases", id, ["doorloop_lease_id","doorloop_id"]);
    if (!lease) return res.status(404).json({ error: "lease not found", id });

    const unit = lease.unit_id
      ? await fetchOneMulti(supabase, "units", lease.unit_id, ["doorloop_unit_id","doorloop_id"])
      : null;

    const property = unit?.property_id
      ? await fetchOneMulti(supabase, "properties", unit.property_id, ["doorloop_property_id","doorloop_id"])
      : null;

    const tenant = lease.tenant_id
      ? await fetchOneMulti(supabase, "tenants", lease.tenant_id, ["doorloop_tenant_id"])
      : null;

    return res.json({ lease, unit, property: property ? { ...property, ...mapAddress(property)} : null, tenant });
  } catch (e:any) {
    console.error("[rpc:get_lease_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

2.5 Owner + Tenant cards (wrap in try/catch and use robust lookups)
app.get("/api/rpc/get_owner_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const owner = await fetchOneMulti(supabase, "owners", id, ["doorloop_owner_id"]);
    if (!owner) return res.status(404).json({ error: "owner not found", id });

    const { data: properties = [] } = await supabase.from("properties").select("*").eq("owner_id", owner.id);
    const propIds = properties.map((p:any)=> p.id);
    const { data: units = [] }  = propIds.length ? await supabase.from("units").select("*").in("property_id", propIds) : { data: [] };
    const { data: leases = [] } = propIds.length ? await supabase.from("leases").select("*").in("property_id", propIds) : { data: [] };

    const active = leases.filter((l:any)=> norm(l.status) === "active");
    const occupancyPct = units.length ? Math.round((active.length/units.length)*1000)/10 : 0;

    const rents = active.map((l:any)=> Number(l.rent_cents ?? l.rent ?? 0)).filter((n:number)=>Number.isFinite(n)&&n>=0);
    const avgRentCents = rents.length ? Math.round(rents.reduce((a:number,b:number)=>a+b,0)/rents.length) : null;

    return res.json({
      owner,
      properties: properties.map((p:any)=> ({ ...p, ...mapAddress(p) })),
      kpis: { units: units.length, activeLeases: active.length, occupancyPct, avgRentCents }
    });
  } catch (e:any) {
    console.error("[rpc:get_owner_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

app.get("/api/rpc/get_tenant_card", async (req, res) => {
  try {
    const id = String(req.query.id ?? "");
    if (!id) return res.status(400).json({ error: "missing id" });

    const tenant = await fetchOneMulti(supabase, "tenants", id, ["doorloop_tenant_id"]);
    if (!tenant) return res.status(404).json({ error: "tenant not found", id });

    const { data: leases = [] } = await supabase.from("leases").select("*").eq("tenant_id", tenant.id);
    const unitIds  = leases.map((l:any)=> l.unit_id).filter(Boolean);
    const { data: units = [] } = unitIds.length ? await supabase.from("units").select("*").in("id", unitIds) : { data: [] };
    const propIds  = units.map((u:any)=> u.property_id).filter(Boolean);
    const { data: properties = [] } = propIds.length ? await supabase.from("properties").select("*").in("id", propIds) : { data: [] };

    const activeLease = leases.find((l:any)=> norm(l.status)==="active") || null;

    return res.json({
      tenant,
      leases,
      properties: properties.map((p:any)=> ({ ...p, ...mapAddress(p) })),
      activeLease
    });
  } catch (e:any) {
    console.error("[rpc:get_tenant_card]", e);
    return res.status(500).json({ error: String(e?.message || e) });
  }
});

3) Frontend: compute-branch accepts “no active leases”

Edit src/pages/card/property/HeroBlock.tsx (compute-from-arrays branch only)

- if (!rents.length) throw new Error("[CONTRACT] No active leases to compute avg rent");
- const avgRentCents = Math.round(rents.reduce((a,b)=>a+b,0)/rents.length);
+ const avgRentCents = rents.length ? Math.round(rents.reduce((a,b)=>a+b,0)/rents.length) : null;


(We still never use ?? 0 or || "—"; we render "—" in the KPI only when the value is explicitly null.)

4) Run + verify
npm run dev
# Property (id 59 from your screenshot)
curl -s "http://localhost:8787/api/rpc/get_property_card?id=59" | jq '.kpis'
# Unit (45)
curl -s "http://localhost:8787/api/rpc/get_unit_card?id=45" | jq '{unit:.unit?.id, lease:.lease?.id}'
# Lease (21)
curl -s "http://localhost:8787/api/rpc/get_lease_card?id=21" | jq '{lease:.lease?.id, unit:.unit?.id, tenant:.tenant?.id}'
# Owner (11)
curl -s "http://localhost:8787/api/rpc/get_owner_card?id=11" | jq '{owner:.owner?.id, kpis:.kpis}'
# Tenant (1)
curl -s "http://localhost:8787/api/rpc/get_tenant_card?id=1" | jq '{tenant:.tenant?.id, active:.activeLease!=null}'


Then open the same four card routes—you should see heroes render.
If a specific record truly doesn’t exist, you’ll get a 404 JSON (not HTML) and the page will show the fail-fast error box (by design).

What this delivers

No more “kpis.avgRentCents” violations. Valid null is allowed, both from KPIs and compute branch.

Dual-key lookups actually work. The schema now has the DoorLoop columns; endpoints try both legacy and new names.

Lease↔Tenant / Property↔Owner links restored. We added tenant_id on leases and owner_id on properties with FKs.

All RPCs return JSON with try/catch. No HTML error pages; users see accurate error states.

No table/UI drift. We didn’t touch tables; when you’re ready, we’ll use a targeted table audit to fix widths/overflow.

If any curl above doesn’t return the expected keys, paste the JSON it returns and I’ll give you a one-file micro-patch for that endpoint.