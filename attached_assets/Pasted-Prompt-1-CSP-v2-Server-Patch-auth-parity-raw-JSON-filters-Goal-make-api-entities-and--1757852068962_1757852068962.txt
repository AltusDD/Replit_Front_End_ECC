Prompt 1: CSP v2 ‚Äî Server Patch (auth parity + raw JSON + filters)

Goal: make /api/entities/* and /api/rpc/* return flat JSON that the cards can actually consume; use the same Supabase auth everywhere.

Create/Update these files exactly:

server/lib/supabase.ts (new)
import { createClient } from '@supabase/supabase-js';

const SUPABASE_URL =
  process.env.SUPABASE_URL ??
  process.env.VITE_SUPABASE_URL ?? '';

const SUPABASE_KEY =
  process.env.SUPABASE_SERVICE_ROLE_KEY ??
  process.env.SUPABASE_SERVICE_KEY ??
  process.env.SUPABASE_KEY ??
  process.env.SUPABASE_ANON_KEY ??
  process.env.VITE_SUPABASE_ANON_KEY ?? '';

export function getSupabase() {
  if (!SUPABASE_URL || !SUPABASE_KEY) {
    console.warn('[ECC/API] Missing Supabase envs; url:', !!SUPABASE_URL, ' key:', !!SUPABASE_KEY);
  }
  return createClient(SUPABASE_URL, SUPABASE_KEY, { auth: { persistSession: false } });
}

server/routes/entities.ts (use shared client + flat shapes + simple filters)
import { Router } from 'express';
import { getSupabase } from '../lib/supabase';
const r = Router();
const supabase = getSupabase();

// GET /api/entities/:table/:id  -> raw object
r.get('/:table/:id', async (req, res) => {
  const { table, id } = req.params;
  const { data, error } = await supabase.from(table).select('*').eq('id', id).single();
  if (error) return res.status(500).json({ error: error.message });
  res.json(data);
});

// GET /api/entities/:table?field=eq.value&limit=10  -> raw array
r.get('/:table', async (req, res) => {
  const { table } = req.params;
  let q = supabase.from(table).select('*');
  for (const [key, val] of Object.entries(req.query)) {
    if (key === 'limit') continue;
    const [op, value] = String(val).split('=');
    if (op === 'eq') q = q.eq(key, value);
  }
  if (req.query.limit) q = q.limit(Number(req.query.limit));
  const { data, error } = await q;
  if (error) return res.status(500).json({ error: error.message });
  res.json(data);
});

export default r;

server/routes/rpc.ts (use shared client + best-effort abort)
import { Router } from 'express';
import { getSupabase } from '../lib/supabase';
const r = Router();

r.get('/get_property_card', async (req, res) => {
  const supabase = getSupabase();
  const ac = new AbortController();
  req.on('close', () => ac.abort());

  const id = String(req.query.id ?? '');
  if (!id) return res.status(400).json({ error: 'id required' });

  const { data: property, error: pe } =
    await supabase.from('properties').select('*').eq('id', id).single();
  if (pe || !property) return res.status(404).json({ error: 'property not found' });

  const { data: units } =
    await supabase.from('units').select('*').eq('doorloop_property_id', property.doorloop_id);
  const { data: leases } =
    await supabase.from('leases').select('*').eq('property_id', property.id);

  res.json({ property, units: units ?? [], leases: leases ?? [], owner: null });
});

// (similar patterns for get_unit_card / get_lease_card if you decide to add them)
export default r;


DoD (server):

GET /api/entities/properties/42 returns a single JSON object (no {ok,item} wrapper).

GET /api/entities/leases?property_id=eq.42&limit=2 returns a JSON array.

(If implemented) GET /api/rpc/get_property_card?id=42 returns { property, units, leases, owner }.

üëâ Prompt 2: CSP v2 ‚Äî Client Patch (one contract everywhere)

Goal: stop ‚Äúunwrapping‚Äù on the client; use the same flat data contract across all cards; normalize query keys; satisfy the guardrail import.

src/lib/ecc-api-client.ts (simplify fetcher)
export async function j<T>(url: string, init?: RequestInit): Promise<T> {
  const r = await fetch(url, init);
  if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
  return (await r.json()) as T; // server already returns raw JSON
}

src/lib/ecc-resolvers.ts (guardrail import)
export {
  usePropertyCard,
  useUnitCard,
  useLeaseCard,
  useTenantCard,
  useOwnerCard,
} from './ecc-card-queries';

src/lib/ecc-card-queries.ts (normalized keys + flat shapes; sample)
import { useQuery } from '@tanstack/react-query';
import { j } from './ecc-api-client';
type Id = string | number;

export function usePropertyCard(id: Id) {
  return useQuery({
    queryKey: ['card','property', id],
    queryFn: async () => {
      try {
        return await j<{ property:any; units:any[]; leases:any[]; owner?:any }>(
          `/api/rpc/get_property_card?id=${id}`
        );
      } catch {
        const property = await j<any>(`/api/entities/properties/${id}`);
        const units = await j<any[]>(`/api/entities/units?doorloop_property_id=eq.${property.doorloop_id}`);
        const leases = await j<any[]>(`/api/entities/leases?property_id=eq.${property.id}`);
        return { property, units: units ?? [], leases: leases ?? [], owner: null };
      }
    },
    staleTime: 60_000,
  });
}

export function useUnitCard(id: Id) {
  return useQuery({
    queryKey: ['card','unit', id],
    queryFn: async () => {
      try {
        return await j<{ unit:any; property?:any; lease?:any; tenant?:any }>(
          `/api/rpc/get_unit_card?id=${id}`
        );
      } catch {
        const unit = await j<any>(`/api/entities/units/${id}`);
        const property = unit?.doorloop_property_id
          ? (await j<any[]>(`/api/entities/properties?doorloop_id=eq.${unit.doorloop_property_id}&limit=1`))[0] ?? null
          : null;
        const lease = (await j<any[]>(`/api/entities/leases?unit_id=eq.${unit.id}&limit=1`))[0] ?? null;
        const tenant = lease?.primary_tenant_id ? await j<any>(`/api/entities/tenants/${lease.primary_tenant_id}`) : null;
        return { unit, property, lease, tenant };
      }
    },
    staleTime: 60_000,
  });
}

// Do the same normalized queryKey style for useLeaseCard/useTenantCard/useOwnerCard

Update all 5 card pages to:

Import hooks from @/lib/ecc-resolvers

Use flat properties (no .raw or .item anywhere)

Example ‚Äì src/pages/card/property/index.tsx:

import { usePropertyCard } from '@/lib/ecc-resolvers';

const { data, isLoading, error } = usePropertyCard(id);
const property = data?.property;
const units = data?.units ?? [];
const leases = data?.leases ?? [];
const owner = data?.owner ?? null;

How to verify (fast)

Start the app normally.

Hit these in a new browser tab (adjust ids you know exist):

/api/entities/properties/42 ‚Üí raw object

/api/entities/leases?property_id=eq.42&limit=2 ‚Üí array

/card/property/42 ‚Üí KPIs non-zero if data exists (Units/Active Leases/Occupancy)

/card/unit/45, /card/lease/1, /card/tenant/1, /card/owner/1 ‚Üí fields populated, not ‚Äú‚Äî‚Äù